{"version":3,"file":"kabel.js","mappings":"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CA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA,yBAAyB,EAAE,UAAU,EAAE,UAAU,EAAE;;AAEnD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,EAAE,aAAa,EAAE;;AAE3C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,IAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,eAAe,EAAE,EAAE,EAAE,EAAE,EAAE;AACzB;AACA;AACA;AACA,0BAA0B,GAAG,GAAG,GAAG,GAAG,GAAG;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oJAAoJ;AACpJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,iDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0HAA0H;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,kDAAkD,iBAAiB,qBAAqB,aAAa;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iBAAiB;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,CAAC;AACD;;AAEA,YAAY,gBAAgB;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mHAAmH;AACnH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,IAAI;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA,uCAAuC,sCAAsC;AAC7E;AACA;AACA,QAAQ;AACR,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,IAAI;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,SAAS;AACvD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,0BAA0B;AAC1B,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,8CAA8C;AAC9C;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT,gBAAgB;AAChB,aAAa;AACb,WAAW;AACX,cAAc;AACd,gBAAgB;AAChB,aAAa;AACb,iBAAiB;AACjB,kBAAkB;AAClB,YAAY;AACZ,WAAW;AACX,YAAY;AACZ,eAAe;AACf,eAAe;AACf,mBAAmB;AACnB,qBAAqB;AACrB,gBAAgB;AAChB,SAAS;AACT,gBAAgB;AAChB,aAAa;AACb,YAAY;AACZ,YAAY;AACZ,cAAc;AACd,YAAY;AACZ,cAAc;AACd,iBAAiB;AACjB,oBAAoB;AACpB,cAAc;AACd,iBAAiB;AACjB,WAAW;AACX,YAAY;AACZ,iBAAiB;AACjB,eAAe;AACf,aAAa;AACb,kBAAkB;AAClB,eAAe;AACf,gBAAgB;AAChB,aAAa;AACb,YAAY;AACZ,cAAc;AACd,WAAW;AACX,aAAa;AACb,cAAc;AACd,YAAY;AACZ,aAAa;AACb,WAAW;AACX,cAAc;AACd,YAAY;AACZ,gBAAgB;AAChB,gBAAgB;AAChB,oBAAoB;AACpB,aAAa;AACb,WAAW;AACX,aAAa;AACb,mBAAmB;AACnB,mBAAmB;AACnB,cAAc;AACd,gBAAgB;AAChB,gBAAgB;AAChB,cAAc;AACd,WAAW;AACX,cAAc;AACd,YAAY;AACZ,gBAAgB;AAChB,sBAAsB;AACtB,iBAAiB;AACjB,iBAAiB;AACjB,oBAAoB;AACpB,qBAAqB;AACrB,iBAAiB;AACjB,kBAAkB;AAClB,iBAAiB;AACjB,WAAW;AACX,UAAU;AACV,cAAc;AACd,aAAa;AACb,gBAAgB;AAChB,6BAA6B;AAC7B,sBAAsB;AACtB,qBAAqB;AACrB,YAAY;AACZ,kBAAkB;AAClB,aAAa;AACb,oBAAoB;AACpB,kBAAkB;AAClB,yBAAyB;AACzB;;;;;;;;;;;;AC7vNa;;AAEb,kGAAyC;;;;;;;;;;;;ACFzC;AACA;AACa;;;AAGb;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;;;;;AC3La;;AAEb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,MAAM,OAAO;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvGa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,mCAAmC;AACnC,qBAAqB;AACrB,qBAAqB;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;AC/Ia;;;AAGb,oBAAoB;;AAEpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT,0BAA0B,OAAO;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;;AAGb,qBAAqB,mBAAO,CAAC,8DAAc;AAC3C,qBAAqB,mBAAO,CAAC,wEAAmB;AAChD,qBAAqB,mBAAO,CAAC,sDAAU;AACvC,qBAAqB,mBAAO,CAAC,gDAAO;AACpC,qBAAqB,mBAAO,CAAC,wDAAW;;;AAGxC;AACA;AACA;AACA,oCAAoC;;AAEpC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,qBAAqB;AACxE;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA,yBAAyB;;AAEzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,8CAA8C,SAAS;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;;AAEA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA,SAAS;AACT;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA,sBAAsB;;AAEtB;;AAEA,cAAc,qBAAqB;AACnC;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC,iCAAiC;AACjC;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;;AAE3B;AACA,uCAAuC;;AAEvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC,iCAAiC;AACjC;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB;;AAEhB,0BAA0B;AAC1B;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAM,2BAA2B;AACjC;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;;;;;;;;;;;;ACxpBa;;;AAGb,aAAa,mBAAO,CAAC,sDAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AAC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","sources":["webpack://Kabel/webpack/universalModuleDefinition","webpack://Kabel/./controllers/base.ts","webpack://Kabel/./controllers/wasd.ts","webpack://Kabel/./events/draggable.ts","webpack://Kabel/./events/events.ts","webpack://Kabel/./events/input-box.ts","webpack://Kabel/./events/node-x-btn.ts","webpack://Kabel/./node_modules/@svgdotjs/svg.js/dist/svg.node.cjs","webpack://Kabel/./node_modules/svgpath/index.js","webpack://Kabel/./node_modules/svgpath/lib/a2c.js","webpack://Kabel/./node_modules/svgpath/lib/ellipse.js","webpack://Kabel/./node_modules/svgpath/lib/matrix.js","webpack://Kabel/./node_modules/svgpath/lib/path_parse.js","webpack://Kabel/./node_modules/svgpath/lib/svgpath.js","webpack://Kabel/./node_modules/svgpath/lib/transform_parse.js","webpack://Kabel/./renderers/constants.ts","webpack://Kabel/./renderers/renderer.ts","webpack://Kabel/./src/colors.ts","webpack://Kabel/./src/connection.ts","webpack://Kabel/./src/context-menu.ts","webpack://Kabel/./src/coordinates.ts","webpack://Kabel/./src/core.ts","webpack://Kabel/./src/ctx-menu-registry.ts","webpack://Kabel/./src/field.ts","webpack://Kabel/./src/flyout.ts","webpack://Kabel/./src/headless-node.ts","webpack://Kabel/./src/index.ts","webpack://Kabel/./src/inject.ts","webpack://Kabel/./src/main-workspace.ts","webpack://Kabel/./src/nodesvg.ts","webpack://Kabel/./src/prototypes.ts","webpack://Kabel/./src/renderer-map.ts","webpack://Kabel/./src/styles.css","webpack://Kabel/./src/toolbox.ts","webpack://Kabel/./src/widget-prototypes.ts","webpack://Kabel/./src/widget.ts","webpack://Kabel/./src/workspace-coords.ts","webpack://Kabel/./src/workspace-svg.ts","webpack://Kabel/./util/emitter.ts","webpack://Kabel/./util/escape-html.ts","webpack://Kabel/./util/eventer.ts","webpack://Kabel/./util/has-prop.ts","webpack://Kabel/./util/parse-color.ts","webpack://Kabel/./util/path.ts","webpack://Kabel/./util/styler.ts","webpack://Kabel/./util/uid.ts","webpack://Kabel/./util/unescape-html.ts","webpack://Kabel/./util/user-state.ts","webpack://Kabel/webpack/bootstrap","webpack://Kabel/webpack/runtime/define property getters","webpack://Kabel/webpack/runtime/hasOwnProperty shorthand","webpack://Kabel/webpack/runtime/make namespace object","webpack://Kabel/webpack/before-startup","webpack://Kabel/webpack/startup","webpack://Kabel/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kabel\"] = factory();\n\telse\n\t\troot[\"Kabel\"] = factory();\n})(this, () => {\nreturn ","import WorkspaceSvg from '../src/workspace-svg';\r\nimport userState from '../util/user-state';\r\n\r\ninterface Vec2 { x: number; y: number; }\r\n\r\nexport default class WorkspaceController {\r\n\tworkspace: WorkspaceSvg;\r\n\r\n\tkeysDown: Set<string>;\r\n\tmouseBtns: Set<number>;\r\n\tmousePos: Vec2;\r\n\tlastMousePos: Vec2;\r\n\tisDragging: boolean;\r\n\r\n\twheelDelta: number;\r\n\r\n\tprivate _updateInt: any;\r\n\r\n\tconstructor(workspace: WorkspaceSvg) {\r\n\t\tthis.workspace = workspace;\r\n\r\n\t\tthis.keysDown = new Set();\r\n\t\tthis.mouseBtns = new Set();\r\n\t\tthis.mousePos = { x: 0, y: 0 };\r\n\t\tthis.lastMousePos = { x: 0, y: 0 };\r\n\t\tthis.isDragging = false;\r\n        this.wheelDelta = 0;\r\n\r\n\t\tthis._setupListeners();\r\n\r\n\t\tthis._updateInt = setInterval(() => this.update(), 16);\r\n\t}\r\n    canMove() {\r\n        return !userState.hasState('typing');\r\n    }\r\n\tprivate _setupListeners() {\r\n\t\twindow.addEventListener('keydown', e => this.keysDown.add(e.key));\r\n\t\twindow.addEventListener('keyup', e => this.keysDown.delete(e.key));\r\n\r\n\t\twindow.addEventListener('mousedown', e => this.mouseBtns.add(e.button));\r\n\t\twindow.addEventListener('mouseup', e => this.mouseBtns.delete(e.button));\r\n\r\n\t\twindow.addEventListener('mousemove', e => {\r\n\t\t\tthis.lastMousePos = { ...this.mousePos };\r\n\t\t\tthis.mousePos = { x: e.clientX, y: e.clientY };\r\n\t\t});\r\n\r\n\t\twindow.addEventListener('wheel', e => {\r\n\t\t\tthis.wheelDelta = e.deltaY;\r\n\t\t});\r\n\r\n\t\twindow.addEventListener('mousedown', e => {\r\n\t\t\tif (e.button === 0) this.isDragging = true;\r\n\t\t});\r\n\t\twindow.addEventListener('mouseup', e => {\r\n\t\t\tif (e.button === 0) this.isDragging = false;\r\n\t\t});\r\n\t}\r\n\r\n\tupdate() {\r\n\t\t// Can handle keyboard shortcuts or auto-pan here\r\n\t}\r\n\r\n\t// --- Camera methods ---\r\n\tpan(dx: number, dy: number) {\r\n\t\tthis.workspace._camera.x += dx;\r\n\t\tthis.workspace._camera.y += dy;\r\n\t\tthis.refreshPos();\r\n\t}\r\n\r\n\tsetCamera(pos: Vec2) {\r\n\t\tthis.workspace._camera.x = pos.x;\r\n\t\tthis.workspace._camera.y = pos.y;\r\n\t\tthis.refreshPos();\r\n\t}\r\n\r\n\tcenterOn(pos: Vec2) {\r\n\t\tconst wsSize = this.workspace.getSize?.() ?? { width: 0, height: 0 };\r\n\t\tthis.setCamera({\r\n\t\t\tx: pos.x - wsSize.width / 2,\r\n\t\t\ty: pos.y - wsSize.height / 2\r\n\t\t});\r\n\t}\r\n\r\n\r\n\r\n\t// --- Coordinate conversion ---\r\n\tscreenToWorkspace(x: number, y: number): Vec2 {\r\n\t\tconst cam = this.workspace._camera;\r\n\t\treturn {\r\n\t\t\tx: x + cam.x,\r\n\t\t\ty: y + cam.y\r\n\t\t};\r\n\t}\r\n\r\n\tworkspaceToScreen(x: number, y: number): Vec2 {\r\n\t\tconst cam = this.workspace._camera;\r\n\t\treturn {\r\n\t\t\tx: (x - cam.x),\r\n\t\t\ty: (y - cam.y)\r\n\t\t};\r\n\t}\r\n\r\n\t// --- Refresh ---\r\n\trefreshPos() {\r\n\t\tthis.workspace.refresh?.();\r\n\t}\r\n\r\n\tredraw() {\r\n\t\tthis.workspace.redraw?.();\r\n\t}\r\n\r\n\t// --- Cleanup ---\r\n\tstop() {\r\n\t\tclearInterval(this._updateInt);\r\n\t}\r\n}\r\n","import WorkspaceController from './base';\r\nimport WorkspaceSvg from '../src/workspace-svg';\r\n\r\ninterface Vec2 { x: number; y: number; }\r\n\r\nexport default class WASDController extends WorkspaceController {\r\n\tmoveSpeed: number;\r\n\tdoAccelerate?: boolean;\r\n\taccelSpeed: number;\r\n\tfriction: number;\r\n\tvelocity: Vec2;\r\n\r\n\tconstructor(workspace: WorkspaceSvg, moveSpeed?: number) {\r\n\t\tsuper(workspace);\r\n\t\tthis.moveSpeed = workspace.options.moveSpeed || moveSpeed || 5;\r\n\r\n\t\tthis.doAccelerate = workspace.options?.controls?.wasdSmooth ?? false;\r\n\t\tthis.accelSpeed = workspace.options?.controls?.wasdAccelerate ?? 0.2;\r\n\t\tthis.friction = workspace.options?.controls?.wasdFriction ?? 0.85;\r\n\r\n\t\tthis.velocity = { x: 0, y: 0 };\r\n\t}\r\n\r\n\tupdate() {\r\n\t\tsuper.update();\r\n\t\tif (!this.canMove()) return;\r\n\r\n\t\tlet inputX = 0;\r\n\t\tlet inputY = 0;\r\n\r\n\t\tif (this.keysDown.has('w') || this.keysDown.has('ArrowUp')) inputY -= 1;\r\n\t\tif (this.keysDown.has('s') || this.keysDown.has('ArrowDown')) inputY += 1;\r\n\t\tif (this.keysDown.has('a') || this.keysDown.has('ArrowLeft')) inputX -= 1;\r\n\t\tif (this.keysDown.has('d') || this.keysDown.has('ArrowRight')) inputX += 1;\r\n\r\n\t\tif (this.doAccelerate) {\r\n\t\t\t// Accelerate velocity towards input direction\r\n\t\t\tthis.velocity.x += inputX * this.accelSpeed;\r\n\t\t\tthis.velocity.y += inputY * this.accelSpeed;\r\n\r\n\t\t\t// Apply friction\r\n\t\t\tthis.velocity.x *= this.friction;\r\n\t\t\tthis.velocity.y *= this.friction;\r\n\r\n\t\t\t// Only pan if velocity is noticeable\r\n\t\t\tif (Math.abs(this.velocity.x) > 0.01 || Math.abs(this.velocity.y) > 0.01) {\r\n\t\t\t\tthis.pan(this.velocity.x, this.velocity.y);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Instant movement\r\n\t\t\tconst dx = inputX * this.moveSpeed;\r\n\t\t\tconst dy = inputY * this.moveSpeed;\r\n\t\t\tif (dx !== 0 || dy !== 0) this.pan(dx, dy);\r\n\t\t}\r\n\t}\r\n}\r\n","import { Element } from '@svgdotjs/svg.js';\r\nimport NodeSvg from '../src/nodesvg';\r\nimport eventer from '../util/eventer';\r\nimport type { EventSetupFn } from '../util/eventer';\r\nimport WorkspaceSvg from '../src/workspace-svg';\r\nimport userState from '../util/user-state';\r\n\r\nconst draggableStore: Record<string, { x: number, y: number }> = {};\r\n\r\nfunction initDraggable(element: Element, args: Record<string, any>): () => void {\r\n    let isDragging = false;\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n\r\n    // fallback to element itself if no drag handle is given\r\n    const dragTarget: Element = args.dragel ?? element;\r\n\r\n    // Restore position if previously stored (type 3)\r\n    if (args.type === 3 && args.id && draggableStore[args.id]) {\r\n        const pos = draggableStore[args.id];\r\n        if (pos) element.move(pos.x, pos.y);\r\n    }\r\n\r\n    function onMouseDown(e: MouseEvent) {\r\n        if (args.type === 2 && args.node) {\r\n            const ws = args.node.workspace;\r\n            if (!ws) return;\r\n\r\n            const start = ws.screenToWorkspace(e.clientX, e.clientY);\r\n            const nodePos = args.node.relativeCoords;\r\n\r\n            offsetX = start.x - nodePos.x;\r\n            offsetY = start.y - nodePos.y;\r\n        } else {\r\n            const bbox = element.bbox();\r\n            offsetX = e.clientX - bbox.x;\r\n            offsetY = e.clientY - bbox.y;\r\n        }\r\n\r\n        isDragging = false;\r\n\r\n        // Mark user as dragging\r\n        userState.setState('dragging');\r\n\r\n        document.addEventListener('mousemove', onMouseMove);\r\n        document.addEventListener('mouseup', onMouseUp);\r\n\r\n        if (args.type === 1 && args.ondrag) args.ondrag(e);\r\n    }\r\n\r\n\r\n    function onMouseMove(e: MouseEvent) {\r\n        if (!isDragging) {\r\n            const dx = e.movementX || 0;\r\n            const dy = e.movementY || 0;\r\n            if (Math.abs(dx) > 2 || Math.abs(dy) > 2) isDragging = true;\r\n        }\r\n        if (!isDragging) return;\r\n\r\n        if (args.type === 2 && args.node && args.node instanceof NodeSvg) {\r\n            const ws: WorkspaceSvg = args.node.workspace as WorkspaceSvg;\r\n            if (!ws) return;\r\n\r\n            // Compute new workspace coordinates\r\n            const mouseWS = ws.screenToWorkspace(e.clientX, e.clientY);\r\n            const newX = mouseWS.x - offsetX;\r\n            const newY = mouseWS.y - offsetY;\r\n\r\n            args.node.relativeCoords.set(newX, newY);\r\n            ws.refresh();\r\n            // Move node visually\r\n            const screenPos = ws.workspaceToScreen(newX, newY);\r\n            element.attr({ transform: `translate(${screenPos.x}, ${screenPos.y})` });\r\n\r\n            args.node.emit('NODE_DRAG', null);\r\n        } else if (args.type === 1 && args.onmove) {\r\n            const newX = e.clientX - offsetX;\r\n            const newY = e.clientY - offsetY;\r\n            element.move(newX, newY);\r\n            args.onmove({ x: newX, y: newY });\r\n        } else if (args.type === 3 && args.id) {\r\n            const newX = e.clientX - offsetX;\r\n            const newY = e.clientY - offsetY;\r\n            element.move(newX, newY);\r\n            draggableStore[args.id] = { x: newX, y: newY };\r\n        }\r\n    }\r\n\r\n    function onMouseUp(e: MouseEvent) {\r\n        document.removeEventListener('mousemove', onMouseMove);\r\n        document.removeEventListener('mouseup', onMouseUp);\r\n\r\n        // Remove dragging state\r\n        userState.removeState('dragging');\r\n\r\n        if (args.type === 1 && args.enddrag) args.enddrag(e);\r\n        isDragging = false;\r\n    }\r\n\r\n    dragTarget.node.addEventListener('mousedown', onMouseDown);\r\n\r\n    // cleanup\r\n    return () => {\r\n        dragTarget.node.removeEventListener('mousedown', onMouseDown);\r\n        document.removeEventListener('mousemove', onMouseMove);\r\n        document.removeEventListener('mouseup', onMouseUp);\r\n    };\r\n}\r\n\r\neventer.registerEvent('k_draggable', initDraggable as EventSetupFn);\r\n","import './draggable';\r\nimport './input-box';\r\nimport './node-x-btn';","import { Element, Rect } from \"@svgdotjs/svg.js\";\r\nimport eventer, { EventSetupFn } from \"../util/eventer\";\r\nimport Renderer from \"../renderers/renderer\";\r\n\r\nimport userState from '../util/user-state';\r\n\r\n\r\nfunction initInputBox(element: Element, args: Record<string, any>) {\r\n    let editing = false;\r\n    let skipNextClick = false;\r\n    let buffer = args.field.getDisplayValue?.() ?? \"\";\r\n    let cursorPos = buffer.length; // index in buffer\r\n\r\n    const txt = args.text;\r\n    const rect = element as Rect;\r\n    const renderer: Renderer = args.renderer;\r\n    txt.style('user-select', 'none');\r\n    //@ts-ignore\r\n    rect.style('user-select', 'none');\r\n\r\n    const { height } = renderer.measureRawField(\"\");\r\n    const offsetY = (height - txt.bbox().height) / 2;\r\n\r\n    function updateText() {\r\n        // insert caret as a vertical bar into string\r\n        const display = buffer.slice(0, cursorPos) + (editing ? '|' : '') + buffer.slice(cursorPos);\r\n        txt.text(display);\r\n\r\n        const { width } = renderer.measureRawField(buffer);\r\n        rect.size(width, height);\r\n        rect.move(args.startX, 0);\r\n        txt.move(args.startX + renderer.constants.INPUT_BOX_PADDING, offsetY);\r\n    }\r\n\r\n    function onKeyDown(e: KeyboardEvent) {\r\n        if (!editing) return;\r\n\r\n        if (e.key === \"Enter\") {\r\n            stopEditing();\r\n            return;\r\n        }\r\n        if (e.key === \"Backspace\") {\r\n            if (cursorPos > 0) {\r\n                buffer = buffer.slice(0, cursorPos - 1) + buffer.slice(cursorPos);\r\n                cursorPos--;\r\n            }\r\n        } else if (e.key === \"Delete\") {\r\n            buffer = buffer.slice(0, cursorPos) + buffer.slice(cursorPos + 1);\r\n        } else if (e.key === \"ArrowLeft\") {\r\n            if (cursorPos > 0) cursorPos--;\r\n        } else if (e.key === \"ArrowRight\") {\r\n            if (cursorPos < buffer.length) cursorPos++;\r\n        } else if (e.key.length === 1) {\r\n            let ch = e.key;\r\n            if (e.shiftKey) ch = ch.toUpperCase();\r\n            buffer = buffer.slice(0, cursorPos) + ch + buffer.slice(cursorPos);\r\n            cursorPos++;\r\n        } else return;\r\n\r\n        e.preventDefault();\r\n        updateText();\r\n        args.field.setValue(buffer);\r\n    }\r\n\r\n    function onClickOutside(ev: MouseEvent) {\r\n        if (!editing) return;\r\n        if (skipNextClick) {\r\n            skipNextClick = false;\r\n            return;\r\n        }\r\n        const target = ev.target as Node;\r\n        if (target !== rect.node && target !== txt.node) stopEditing();\r\n    }\r\n\r\n    function startEditing(ev?: MouseEvent) {\r\n        editing = true;\r\n        buffer = args.field.getValue?.() ?? \"\";\r\n        cursorPos = buffer.length; // default to end\r\n\r\n        // mark that the user is typing\r\n        userState.setState('typing');\r\n\r\n        if (ev) {\r\n            const rectBox = rect.node.getBoundingClientRect();\r\n            const clickX = ev.clientX - rectBox.left - renderer.constants.INPUT_BOX_PADDING;\r\n\r\n            let cumulativeWidth = 0;\r\n            cursorPos = 0;\r\n\r\n            for (let i = 0; i < buffer.length; i++) {\r\n                const charWidth = renderer.measureTextWidth(buffer[i]);\r\n                if (cumulativeWidth + charWidth / 2 >= clickX) break; // place after closest char\r\n                cumulativeWidth += charWidth;\r\n                cursorPos = i + 1;\r\n            }\r\n        }\r\n\r\n        updateText();\r\n        skipNextClick = true;\r\n\r\n        document.addEventListener(\"keydown\", onKeyDown);\r\n        document.addEventListener(\"mousedown\", onClickOutside);\r\n    }\r\n\r\n    function stopEditing() {\r\n        editing = false;\r\n\r\n        // remove typing state\r\n        userState.removeState('typing');\r\n\r\n        document.removeEventListener(\"keydown\", onKeyDown);\r\n        document.removeEventListener(\"mousedown\", onClickOutside);\r\n        args.field.setValue(buffer); // store without caret\r\n        updateText();\r\n        renderer.getWs().redraw();\r\n    }\r\n\r\n\r\n    rect.on(\"mousedown\", (ev: Event) => startEditing(ev as MouseEvent));\r\n    txt.on(\"mousedown\", (ev: Event) => startEditing(ev as MouseEvent));\r\n\r\n\r\n    updateText();\r\n\r\n    return () => {\r\n        rect.off(\"mousedown\", startEditing as EventListener);\r\n        txt.off(\"mousedown\", startEditing);\r\n        document.removeEventListener(\"keydown\", onKeyDown);\r\n        document.removeEventListener(\"mousedown\", onClickOutside);\r\n    };\r\n}\r\n\r\n\r\neventer.registerEvent(\"k_inputbox\", initInputBox as EventSetupFn);\r\n","import { Element, G } from '@svgdotjs/svg.js';\r\nimport NodeSvg from '../src/nodesvg';\r\nimport eventer, { EventSetupFn } from '../util/eventer';\r\nimport WorkspaceSvg from '../src/workspace-svg';\r\n\r\nfunction initXButton(element: Element, args: Record<string, any>): () => void {\r\n\tconst xBtnGroup = element as G;\r\n\tconst ws: WorkspaceSvg = args.workspace;\r\n\r\n\t// click handler\r\n\tconst onClick = () => {\r\n\t\tws.removeNode(args.node);\r\n\t};\r\n\r\n\t// attach\r\n\txBtnGroup.on('click', onClick);\r\n\r\n\t// return cleanup function\r\n\treturn () => {\r\n\t\txBtnGroup.off('click', onClick);\r\n\t};\r\n}\r\n\r\n// register as Kabel event\r\neventer.registerEvent('k_closenode', initXButton as EventSetupFn);\r\n","/*!\n* @svgdotjs/svg.js - A lightweight library for manipulating and animating SVG.\n* @version 3.2.4\n* https://svgjs.dev/\n*\n* @copyright Wout Fierens <wout@mick-wout.com>\n* @license MIT\n*\n* BUILT: Thu Jun 27 2024 12:00:16 GMT+0200 (Central European Summer Time)\n*/;\n'use strict';\n\nconst methods$1 = {};\nconst names = [];\nfunction registerMethods(name, m) {\n  if (Array.isArray(name)) {\n    for (const _name of name) {\n      registerMethods(_name, m);\n    }\n    return;\n  }\n  if (typeof name === 'object') {\n    for (const _name in name) {\n      registerMethods(_name, name[_name]);\n    }\n    return;\n  }\n  addMethodNames(Object.getOwnPropertyNames(m));\n  methods$1[name] = Object.assign(methods$1[name] || {}, m);\n}\nfunction getMethodsFor(name) {\n  return methods$1[name] || {};\n}\nfunction getMethodNames() {\n  return [...new Set(names)];\n}\nfunction addMethodNames(_names) {\n  names.push(..._names);\n}\n\n// Map function\nfunction map(array, block) {\n  let i;\n  const il = array.length;\n  const result = [];\n  for (i = 0; i < il; i++) {\n    result.push(block(array[i]));\n  }\n  return result;\n}\n\n// Filter function\nfunction filter(array, block) {\n  let i;\n  const il = array.length;\n  const result = [];\n  for (i = 0; i < il; i++) {\n    if (block(array[i])) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n}\n\n// Degrees to radians\nfunction radians(d) {\n  return d % 360 * Math.PI / 180;\n}\n\n// Radians to degrees\nfunction degrees(r) {\n  return r * 180 / Math.PI % 360;\n}\n\n// Convert camel cased string to dash separated\nfunction unCamelCase(s) {\n  return s.replace(/([A-Z])/g, function (m, g) {\n    return '-' + g.toLowerCase();\n  });\n}\n\n// Capitalize first letter of a string\nfunction capitalize(s) {\n  return s.charAt(0).toUpperCase() + s.slice(1);\n}\n\n// Calculate proportional width and height values when necessary\nfunction proportionalSize(element, width, height, box) {\n  if (width == null || height == null) {\n    box = box || element.bbox();\n    if (width == null) {\n      width = box.width / box.height * height;\n    } else if (height == null) {\n      height = box.height / box.width * width;\n    }\n  }\n  return {\n    width: width,\n    height: height\n  };\n}\n\n/**\n * This function adds support for string origins.\n * It searches for an origin in o.origin o.ox and o.originX.\n * This way, origin: {x: 'center', y: 50} can be passed as well as ox: 'center', oy: 50\n **/\nfunction getOrigin(o, element) {\n  const origin = o.origin;\n  // First check if origin is in ox or originX\n  let ox = o.ox != null ? o.ox : o.originX != null ? o.originX : 'center';\n  let oy = o.oy != null ? o.oy : o.originY != null ? o.originY : 'center';\n\n  // Then check if origin was used and overwrite in that case\n  if (origin != null) {\n    [ox, oy] = Array.isArray(origin) ? origin : typeof origin === 'object' ? [origin.x, origin.y] : [origin, origin];\n  }\n\n  // Make sure to only call bbox when actually needed\n  const condX = typeof ox === 'string';\n  const condY = typeof oy === 'string';\n  if (condX || condY) {\n    const {\n      height,\n      width,\n      x,\n      y\n    } = element.bbox();\n\n    // And only overwrite if string was passed for this specific axis\n    if (condX) {\n      ox = ox.includes('left') ? x : ox.includes('right') ? x + width : x + width / 2;\n    }\n    if (condY) {\n      oy = oy.includes('top') ? y : oy.includes('bottom') ? y + height : y + height / 2;\n    }\n  }\n\n  // Return the origin as it is if it wasn't a string\n  return [ox, oy];\n}\nconst descriptiveElements = new Set(['desc', 'metadata', 'title']);\nconst isDescriptive = element => descriptiveElements.has(element.nodeName);\nconst writeDataToDom = (element, data, defaults = {}) => {\n  const cloned = {\n    ...data\n  };\n  for (const key in cloned) {\n    if (cloned[key].valueOf() === defaults[key]) {\n      delete cloned[key];\n    }\n  }\n  if (Object.keys(cloned).length) {\n    element.node.setAttribute('data-svgjs', JSON.stringify(cloned)); // see #428\n  } else {\n    element.node.removeAttribute('data-svgjs');\n    element.node.removeAttribute('svgjs:data');\n  }\n};\n\nvar utils = {\n  __proto__: null,\n  capitalize: capitalize,\n  degrees: degrees,\n  filter: filter,\n  getOrigin: getOrigin,\n  isDescriptive: isDescriptive,\n  map: map,\n  proportionalSize: proportionalSize,\n  radians: radians,\n  unCamelCase: unCamelCase,\n  writeDataToDom: writeDataToDom\n};\n\n// Default namespaces\nconst svg = 'http://www.w3.org/2000/svg';\nconst html = 'http://www.w3.org/1999/xhtml';\nconst xmlns = 'http://www.w3.org/2000/xmlns/';\nconst xlink = 'http://www.w3.org/1999/xlink';\n\nvar namespaces = {\n  __proto__: null,\n  html: html,\n  svg: svg,\n  xlink: xlink,\n  xmlns: xmlns\n};\n\nconst globals = {\n  window: typeof window === 'undefined' ? null : window,\n  document: typeof document === 'undefined' ? null : document\n};\nfunction registerWindow(win = null, doc = null) {\n  globals.window = win;\n  globals.document = doc;\n}\nconst save = {};\nfunction saveWindow() {\n  save.window = globals.window;\n  save.document = globals.document;\n}\nfunction restoreWindow() {\n  globals.window = save.window;\n  globals.document = save.document;\n}\nfunction withWindow(win, fn) {\n  saveWindow();\n  registerWindow(win, win.document);\n  fn(win, win.document);\n  restoreWindow();\n}\nfunction getWindow() {\n  return globals.window;\n}\n\nclass Base {\n  // constructor (node/*, {extensions = []} */) {\n  //   // this.tags = []\n  //   //\n  //   // for (let extension of extensions) {\n  //   //   extension.setup.call(this, node)\n  //   //   this.tags.push(extension.name)\n  //   // }\n  // }\n}\n\nconst elements = {};\nconst root = '___SYMBOL___ROOT___';\n\n// Method for element creation\nfunction create(name, ns = svg) {\n  // create element\n  return globals.document.createElementNS(ns, name);\n}\nfunction makeInstance(element, isHTML = false) {\n  if (element instanceof Base) return element;\n  if (typeof element === 'object') {\n    return adopter(element);\n  }\n  if (element == null) {\n    return new elements[root]();\n  }\n  if (typeof element === 'string' && element.charAt(0) !== '<') {\n    return adopter(globals.document.querySelector(element));\n  }\n\n  // Make sure, that HTML elements are created with the correct namespace\n  const wrapper = isHTML ? globals.document.createElement('div') : create('svg');\n  wrapper.innerHTML = element;\n\n  // We can use firstChild here because we know,\n  // that the first char is < and thus an element\n  element = adopter(wrapper.firstChild);\n\n  // make sure, that element doesn't have its wrapper attached\n  wrapper.removeChild(wrapper.firstChild);\n  return element;\n}\nfunction nodeOrNew(name, node) {\n  return node && (node instanceof globals.window.Node || node.ownerDocument && node instanceof node.ownerDocument.defaultView.Node) ? node : create(name);\n}\n\n// Adopt existing svg elements\nfunction adopt(node) {\n  // check for presence of node\n  if (!node) return null;\n\n  // make sure a node isn't already adopted\n  if (node.instance instanceof Base) return node.instance;\n  if (node.nodeName === '#document-fragment') {\n    return new elements.Fragment(node);\n  }\n\n  // initialize variables\n  let className = capitalize(node.nodeName || 'Dom');\n\n  // Make sure that gradients are adopted correctly\n  if (className === 'LinearGradient' || className === 'RadialGradient') {\n    className = 'Gradient';\n\n    // Fallback to Dom if element is not known\n  } else if (!elements[className]) {\n    className = 'Dom';\n  }\n  return new elements[className](node);\n}\nlet adopter = adopt;\nfunction mockAdopt(mock = adopt) {\n  adopter = mock;\n}\nfunction register(element, name = element.name, asRoot = false) {\n  elements[name] = element;\n  if (asRoot) elements[root] = element;\n  addMethodNames(Object.getOwnPropertyNames(element.prototype));\n  return element;\n}\nfunction getClass(name) {\n  return elements[name];\n}\n\n// Element id sequence\nlet did = 1000;\n\n// Get next named element id\nfunction eid(name) {\n  return 'Svgjs' + capitalize(name) + did++;\n}\n\n// Deep new id assignment\nfunction assignNewId(node) {\n  // do the same for SVG child nodes as well\n  for (let i = node.children.length - 1; i >= 0; i--) {\n    assignNewId(node.children[i]);\n  }\n  if (node.id) {\n    node.id = eid(node.nodeName);\n    return node;\n  }\n  return node;\n}\n\n// Method for extending objects\nfunction extend(modules, methods) {\n  let key, i;\n  modules = Array.isArray(modules) ? modules : [modules];\n  for (i = modules.length - 1; i >= 0; i--) {\n    for (key in methods) {\n      modules[i].prototype[key] = methods[key];\n    }\n  }\n}\nfunction wrapWithAttrCheck(fn) {\n  return function (...args) {\n    const o = args[args.length - 1];\n    if (o && o.constructor === Object && !(o instanceof Array)) {\n      return fn.apply(this, args.slice(0, -1)).attr(o);\n    } else {\n      return fn.apply(this, args);\n    }\n  };\n}\n\n// Get all siblings, including myself\nfunction siblings() {\n  return this.parent().children();\n}\n\n// Get the current position siblings\nfunction position() {\n  return this.parent().index(this);\n}\n\n// Get the next element (will return null if there is none)\nfunction next() {\n  return this.siblings()[this.position() + 1];\n}\n\n// Get the next element (will return null if there is none)\nfunction prev() {\n  return this.siblings()[this.position() - 1];\n}\n\n// Send given element one step forward\nfunction forward() {\n  const i = this.position();\n  const p = this.parent();\n\n  // move node one step forward\n  p.add(this.remove(), i + 1);\n  return this;\n}\n\n// Send given element one step backward\nfunction backward() {\n  const i = this.position();\n  const p = this.parent();\n  p.add(this.remove(), i ? i - 1 : 0);\n  return this;\n}\n\n// Send given element all the way to the front\nfunction front() {\n  const p = this.parent();\n\n  // Move node forward\n  p.add(this.remove());\n  return this;\n}\n\n// Send given element all the way to the back\nfunction back() {\n  const p = this.parent();\n\n  // Move node back\n  p.add(this.remove(), 0);\n  return this;\n}\n\n// Inserts a given element before the targeted element\nfunction before(element) {\n  element = makeInstance(element);\n  element.remove();\n  const i = this.position();\n  this.parent().add(element, i);\n  return this;\n}\n\n// Inserts a given element after the targeted element\nfunction after(element) {\n  element = makeInstance(element);\n  element.remove();\n  const i = this.position();\n  this.parent().add(element, i + 1);\n  return this;\n}\nfunction insertBefore(element) {\n  element = makeInstance(element);\n  element.before(this);\n  return this;\n}\nfunction insertAfter(element) {\n  element = makeInstance(element);\n  element.after(this);\n  return this;\n}\nregisterMethods('Dom', {\n  siblings,\n  position,\n  next,\n  prev,\n  forward,\n  backward,\n  front,\n  back,\n  before,\n  after,\n  insertBefore,\n  insertAfter\n});\n\n// Parse unit value\nconst numberAndUnit = /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i;\n\n// Parse hex value\nconst hex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\n\n// Parse rgb value\nconst rgb = /rgb\\((\\d+),(\\d+),(\\d+)\\)/;\n\n// Parse reference id\nconst reference = /(#[a-z_][a-z0-9\\-_]*)/i;\n\n// splits a transformation chain\nconst transforms = /\\)\\s*,?\\s*/;\n\n// Whitespace\nconst whitespace = /\\s/g;\n\n// Test hex value\nconst isHex = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i;\n\n// Test rgb value\nconst isRgb = /^rgb\\(/;\n\n// Test for blank string\nconst isBlank = /^(\\s+)?$/;\n\n// Test for numeric string\nconst isNumber = /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\n\n// Test for image url\nconst isImage = /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i;\n\n// split at whitespace and comma\nconst delimiter = /[\\s,]+/;\n\n// Test for path letter\nconst isPathLetter = /[MLHVCSQTAZ]/i;\n\nvar regex = {\n  __proto__: null,\n  delimiter: delimiter,\n  hex: hex,\n  isBlank: isBlank,\n  isHex: isHex,\n  isImage: isImage,\n  isNumber: isNumber,\n  isPathLetter: isPathLetter,\n  isRgb: isRgb,\n  numberAndUnit: numberAndUnit,\n  reference: reference,\n  rgb: rgb,\n  transforms: transforms,\n  whitespace: whitespace\n};\n\n// Return array of classes on the node\nfunction classes() {\n  const attr = this.attr('class');\n  return attr == null ? [] : attr.trim().split(delimiter);\n}\n\n// Return true if class exists on the node, false otherwise\nfunction hasClass(name) {\n  return this.classes().indexOf(name) !== -1;\n}\n\n// Add class to the node\nfunction addClass(name) {\n  if (!this.hasClass(name)) {\n    const array = this.classes();\n    array.push(name);\n    this.attr('class', array.join(' '));\n  }\n  return this;\n}\n\n// Remove class from the node\nfunction removeClass(name) {\n  if (this.hasClass(name)) {\n    this.attr('class', this.classes().filter(function (c) {\n      return c !== name;\n    }).join(' '));\n  }\n  return this;\n}\n\n// Toggle the presence of a class on the node\nfunction toggleClass(name) {\n  return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);\n}\nregisterMethods('Dom', {\n  classes,\n  hasClass,\n  addClass,\n  removeClass,\n  toggleClass\n});\n\n// Dynamic style generator\nfunction css(style, val) {\n  const ret = {};\n  if (arguments.length === 0) {\n    // get full style as object\n    this.node.style.cssText.split(/\\s*;\\s*/).filter(function (el) {\n      return !!el.length;\n    }).forEach(function (el) {\n      const t = el.split(/\\s*:\\s*/);\n      ret[t[0]] = t[1];\n    });\n    return ret;\n  }\n  if (arguments.length < 2) {\n    // get style properties as array\n    if (Array.isArray(style)) {\n      for (const name of style) {\n        const cased = name;\n        ret[name] = this.node.style.getPropertyValue(cased);\n      }\n      return ret;\n    }\n\n    // get style for property\n    if (typeof style === 'string') {\n      return this.node.style.getPropertyValue(style);\n    }\n\n    // set styles in object\n    if (typeof style === 'object') {\n      for (const name in style) {\n        // set empty string if null/undefined/'' was given\n        this.node.style.setProperty(name, style[name] == null || isBlank.test(style[name]) ? '' : style[name]);\n      }\n    }\n  }\n\n  // set style for property\n  if (arguments.length === 2) {\n    this.node.style.setProperty(style, val == null || isBlank.test(val) ? '' : val);\n  }\n  return this;\n}\n\n// Show element\nfunction show() {\n  return this.css('display', '');\n}\n\n// Hide element\nfunction hide() {\n  return this.css('display', 'none');\n}\n\n// Is element visible?\nfunction visible() {\n  return this.css('display') !== 'none';\n}\nregisterMethods('Dom', {\n  css,\n  show,\n  hide,\n  visible\n});\n\n// Store data values on svg nodes\nfunction data(a, v, r) {\n  if (a == null) {\n    // get an object of attributes\n    return this.data(map(filter(this.node.attributes, el => el.nodeName.indexOf('data-') === 0), el => el.nodeName.slice(5)));\n  } else if (a instanceof Array) {\n    const data = {};\n    for (const key of a) {\n      data[key] = this.data(key);\n    }\n    return data;\n  } else if (typeof a === 'object') {\n    for (v in a) {\n      this.data(v, a[v]);\n    }\n  } else if (arguments.length < 2) {\n    try {\n      return JSON.parse(this.attr('data-' + a));\n    } catch (e) {\n      return this.attr('data-' + a);\n    }\n  } else {\n    this.attr('data-' + a, v === null ? null : r === true || typeof v === 'string' || typeof v === 'number' ? v : JSON.stringify(v));\n  }\n  return this;\n}\nregisterMethods('Dom', {\n  data\n});\n\n// Remember arbitrary data\nfunction remember(k, v) {\n  // remember every item in an object individually\n  if (typeof arguments[0] === 'object') {\n    for (const key in k) {\n      this.remember(key, k[key]);\n    }\n  } else if (arguments.length === 1) {\n    // retrieve memory\n    return this.memory()[k];\n  } else {\n    // store memory\n    this.memory()[k] = v;\n  }\n  return this;\n}\n\n// Erase a given memory\nfunction forget() {\n  if (arguments.length === 0) {\n    this._memory = {};\n  } else {\n    for (let i = arguments.length - 1; i >= 0; i--) {\n      delete this.memory()[arguments[i]];\n    }\n  }\n  return this;\n}\n\n// This triggers creation of a new hidden class which is not performant\n// However, this function is not rarely used so it will not happen frequently\n// Return local memory object\nfunction memory() {\n  return this._memory = this._memory || {};\n}\nregisterMethods('Dom', {\n  remember,\n  forget,\n  memory\n});\n\nfunction sixDigitHex(hex) {\n  return hex.length === 4 ? ['#', hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join('') : hex;\n}\nfunction componentHex(component) {\n  const integer = Math.round(component);\n  const bounded = Math.max(0, Math.min(255, integer));\n  const hex = bounded.toString(16);\n  return hex.length === 1 ? '0' + hex : hex;\n}\nfunction is(object, space) {\n  for (let i = space.length; i--;) {\n    if (object[space[i]] == null) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getParameters(a, b) {\n  const params = is(a, 'rgb') ? {\n    _a: a.r,\n    _b: a.g,\n    _c: a.b,\n    _d: 0,\n    space: 'rgb'\n  } : is(a, 'xyz') ? {\n    _a: a.x,\n    _b: a.y,\n    _c: a.z,\n    _d: 0,\n    space: 'xyz'\n  } : is(a, 'hsl') ? {\n    _a: a.h,\n    _b: a.s,\n    _c: a.l,\n    _d: 0,\n    space: 'hsl'\n  } : is(a, 'lab') ? {\n    _a: a.l,\n    _b: a.a,\n    _c: a.b,\n    _d: 0,\n    space: 'lab'\n  } : is(a, 'lch') ? {\n    _a: a.l,\n    _b: a.c,\n    _c: a.h,\n    _d: 0,\n    space: 'lch'\n  } : is(a, 'cmyk') ? {\n    _a: a.c,\n    _b: a.m,\n    _c: a.y,\n    _d: a.k,\n    space: 'cmyk'\n  } : {\n    _a: 0,\n    _b: 0,\n    _c: 0,\n    space: 'rgb'\n  };\n  params.space = b || params.space;\n  return params;\n}\nfunction cieSpace(space) {\n  if (space === 'lab' || space === 'xyz' || space === 'lch') {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction hueToRgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\nclass Color {\n  constructor(...inputs) {\n    this.init(...inputs);\n  }\n\n  // Test if given value is a color\n  static isColor(color) {\n    return color && (color instanceof Color || this.isRgb(color) || this.test(color));\n  }\n\n  // Test if given value is an rgb object\n  static isRgb(color) {\n    return color && typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number';\n  }\n\n  /*\n  Generating random colors\n  */\n  static random(mode = 'vibrant', t) {\n    // Get the math modules\n    const {\n      random,\n      round,\n      sin,\n      PI: pi\n    } = Math;\n\n    // Run the correct generator\n    if (mode === 'vibrant') {\n      const l = (81 - 57) * random() + 57;\n      const c = (83 - 45) * random() + 45;\n      const h = 360 * random();\n      const color = new Color(l, c, h, 'lch');\n      return color;\n    } else if (mode === 'sine') {\n      t = t == null ? random() : t;\n      const r = round(80 * sin(2 * pi * t / 0.5 + 0.01) + 150);\n      const g = round(50 * sin(2 * pi * t / 0.5 + 4.6) + 200);\n      const b = round(100 * sin(2 * pi * t / 0.5 + 2.3) + 150);\n      const color = new Color(r, g, b);\n      return color;\n    } else if (mode === 'pastel') {\n      const l = (94 - 86) * random() + 86;\n      const c = (26 - 9) * random() + 9;\n      const h = 360 * random();\n      const color = new Color(l, c, h, 'lch');\n      return color;\n    } else if (mode === 'dark') {\n      const l = 10 + 10 * random();\n      const c = (125 - 75) * random() + 86;\n      const h = 360 * random();\n      const color = new Color(l, c, h, 'lch');\n      return color;\n    } else if (mode === 'rgb') {\n      const r = 255 * random();\n      const g = 255 * random();\n      const b = 255 * random();\n      const color = new Color(r, g, b);\n      return color;\n    } else if (mode === 'lab') {\n      const l = 100 * random();\n      const a = 256 * random() - 128;\n      const b = 256 * random() - 128;\n      const color = new Color(l, a, b, 'lab');\n      return color;\n    } else if (mode === 'grey') {\n      const grey = 255 * random();\n      const color = new Color(grey, grey, grey);\n      return color;\n    } else {\n      throw new Error('Unsupported random color mode');\n    }\n  }\n\n  // Test if given value is a color string\n  static test(color) {\n    return typeof color === 'string' && (isHex.test(color) || isRgb.test(color));\n  }\n  cmyk() {\n    // Get the rgb values for the current color\n    const {\n      _a,\n      _b,\n      _c\n    } = this.rgb();\n    const [r, g, b] = [_a, _b, _c].map(v => v / 255);\n\n    // Get the cmyk values in an unbounded format\n    const k = Math.min(1 - r, 1 - g, 1 - b);\n    if (k === 1) {\n      // Catch the black case\n      return new Color(0, 0, 0, 1, 'cmyk');\n    }\n    const c = (1 - r - k) / (1 - k);\n    const m = (1 - g - k) / (1 - k);\n    const y = (1 - b - k) / (1 - k);\n\n    // Construct the new color\n    const color = new Color(c, m, y, k, 'cmyk');\n    return color;\n  }\n  hsl() {\n    // Get the rgb values\n    const {\n      _a,\n      _b,\n      _c\n    } = this.rgb();\n    const [r, g, b] = [_a, _b, _c].map(v => v / 255);\n\n    // Find the maximum and minimum values to get the lightness\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = (max + min) / 2;\n\n    // If the r, g, v values are identical then we are grey\n    const isGrey = max === min;\n\n    // Calculate the hue and saturation\n    const delta = max - min;\n    const s = isGrey ? 0 : l > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n    const h = isGrey ? 0 : max === r ? ((g - b) / delta + (g < b ? 6 : 0)) / 6 : max === g ? ((b - r) / delta + 2) / 6 : max === b ? ((r - g) / delta + 4) / 6 : 0;\n\n    // Construct and return the new color\n    const color = new Color(360 * h, 100 * s, 100 * l, 'hsl');\n    return color;\n  }\n  init(a = 0, b = 0, c = 0, d = 0, space = 'rgb') {\n    // This catches the case when a falsy value is passed like ''\n    a = !a ? 0 : a;\n\n    // Reset all values in case the init function is rerun with new color space\n    if (this.space) {\n      for (const component in this.space) {\n        delete this[this.space[component]];\n      }\n    }\n    if (typeof a === 'number') {\n      // Allow for the case that we don't need d...\n      space = typeof d === 'string' ? d : space;\n      d = typeof d === 'string' ? 0 : d;\n\n      // Assign the values straight to the color\n      Object.assign(this, {\n        _a: a,\n        _b: b,\n        _c: c,\n        _d: d,\n        space\n      });\n      // If the user gave us an array, make the color from it\n    } else if (a instanceof Array) {\n      this.space = b || (typeof a[3] === 'string' ? a[3] : a[4]) || 'rgb';\n      Object.assign(this, {\n        _a: a[0],\n        _b: a[1],\n        _c: a[2],\n        _d: a[3] || 0\n      });\n    } else if (a instanceof Object) {\n      // Set the object up and assign its values directly\n      const values = getParameters(a, b);\n      Object.assign(this, values);\n    } else if (typeof a === 'string') {\n      if (isRgb.test(a)) {\n        const noWhitespace = a.replace(whitespace, '');\n        const [_a, _b, _c] = rgb.exec(noWhitespace).slice(1, 4).map(v => parseInt(v));\n        Object.assign(this, {\n          _a,\n          _b,\n          _c,\n          _d: 0,\n          space: 'rgb'\n        });\n      } else if (isHex.test(a)) {\n        const hexParse = v => parseInt(v, 16);\n        const [, _a, _b, _c] = hex.exec(sixDigitHex(a)).map(hexParse);\n        Object.assign(this, {\n          _a,\n          _b,\n          _c,\n          _d: 0,\n          space: 'rgb'\n        });\n      } else throw Error(\"Unsupported string format, can't construct Color\");\n    }\n\n    // Now add the components as a convenience\n    const {\n      _a,\n      _b,\n      _c,\n      _d\n    } = this;\n    const components = this.space === 'rgb' ? {\n      r: _a,\n      g: _b,\n      b: _c\n    } : this.space === 'xyz' ? {\n      x: _a,\n      y: _b,\n      z: _c\n    } : this.space === 'hsl' ? {\n      h: _a,\n      s: _b,\n      l: _c\n    } : this.space === 'lab' ? {\n      l: _a,\n      a: _b,\n      b: _c\n    } : this.space === 'lch' ? {\n      l: _a,\n      c: _b,\n      h: _c\n    } : this.space === 'cmyk' ? {\n      c: _a,\n      m: _b,\n      y: _c,\n      k: _d\n    } : {};\n    Object.assign(this, components);\n  }\n  lab() {\n    // Get the xyz color\n    const {\n      x,\n      y,\n      z\n    } = this.xyz();\n\n    // Get the lab components\n    const l = 116 * y - 16;\n    const a = 500 * (x - y);\n    const b = 200 * (y - z);\n\n    // Construct and return a new color\n    const color = new Color(l, a, b, 'lab');\n    return color;\n  }\n  lch() {\n    // Get the lab color directly\n    const {\n      l,\n      a,\n      b\n    } = this.lab();\n\n    // Get the chromaticity and the hue using polar coordinates\n    const c = Math.sqrt(a ** 2 + b ** 2);\n    let h = 180 * Math.atan2(b, a) / Math.PI;\n    if (h < 0) {\n      h *= -1;\n      h = 360 - h;\n    }\n\n    // Make a new color and return it\n    const color = new Color(l, c, h, 'lch');\n    return color;\n  }\n  /*\n  Conversion Methods\n  */\n\n  rgb() {\n    if (this.space === 'rgb') {\n      return this;\n    } else if (cieSpace(this.space)) {\n      // Convert to the xyz color space\n      let {\n        x,\n        y,\n        z\n      } = this;\n      if (this.space === 'lab' || this.space === 'lch') {\n        // Get the values in the lab space\n        let {\n          l,\n          a,\n          b\n        } = this;\n        if (this.space === 'lch') {\n          const {\n            c,\n            h\n          } = this;\n          const dToR = Math.PI / 180;\n          a = c * Math.cos(dToR * h);\n          b = c * Math.sin(dToR * h);\n        }\n\n        // Undo the nonlinear function\n        const yL = (l + 16) / 116;\n        const xL = a / 500 + yL;\n        const zL = yL - b / 200;\n\n        // Get the xyz values\n        const ct = 16 / 116;\n        const mx = 0.008856;\n        const nm = 7.787;\n        x = 0.95047 * (xL ** 3 > mx ? xL ** 3 : (xL - ct) / nm);\n        y = 1.0 * (yL ** 3 > mx ? yL ** 3 : (yL - ct) / nm);\n        z = 1.08883 * (zL ** 3 > mx ? zL ** 3 : (zL - ct) / nm);\n      }\n\n      // Convert xyz to unbounded rgb values\n      const rU = x * 3.2406 + y * -1.5372 + z * -0.4986;\n      const gU = x * -0.9689 + y * 1.8758 + z * 0.0415;\n      const bU = x * 0.0557 + y * -0.204 + z * 1.057;\n\n      // Convert the values to true rgb values\n      const pow = Math.pow;\n      const bd = 0.0031308;\n      const r = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU;\n      const g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU;\n      const b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU;\n\n      // Make and return the color\n      const color = new Color(255 * r, 255 * g, 255 * b);\n      return color;\n    } else if (this.space === 'hsl') {\n      // https://bgrins.github.io/TinyColor/docs/tinycolor.html\n      // Get the current hsl values\n      let {\n        h,\n        s,\n        l\n      } = this;\n      h /= 360;\n      s /= 100;\n      l /= 100;\n\n      // If we are grey, then just make the color directly\n      if (s === 0) {\n        l *= 255;\n        const color = new Color(l, l, l);\n        return color;\n      }\n\n      // TODO I have no idea what this does :D If you figure it out, tell me!\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n\n      // Get the rgb values\n      const r = 255 * hueToRgb(p, q, h + 1 / 3);\n      const g = 255 * hueToRgb(p, q, h);\n      const b = 255 * hueToRgb(p, q, h - 1 / 3);\n\n      // Make a new color\n      const color = new Color(r, g, b);\n      return color;\n    } else if (this.space === 'cmyk') {\n      // https://gist.github.com/felipesabino/5066336\n      // Get the normalised cmyk values\n      const {\n        c,\n        m,\n        y,\n        k\n      } = this;\n\n      // Get the rgb values\n      const r = 255 * (1 - Math.min(1, c * (1 - k) + k));\n      const g = 255 * (1 - Math.min(1, m * (1 - k) + k));\n      const b = 255 * (1 - Math.min(1, y * (1 - k) + k));\n\n      // Form the color and return it\n      const color = new Color(r, g, b);\n      return color;\n    } else {\n      return this;\n    }\n  }\n  toArray() {\n    const {\n      _a,\n      _b,\n      _c,\n      _d,\n      space\n    } = this;\n    return [_a, _b, _c, _d, space];\n  }\n  toHex() {\n    const [r, g, b] = this._clamped().map(componentHex);\n    return `#${r}${g}${b}`;\n  }\n  toRgb() {\n    const [rV, gV, bV] = this._clamped();\n    const string = `rgb(${rV},${gV},${bV})`;\n    return string;\n  }\n  toString() {\n    return this.toHex();\n  }\n  xyz() {\n    // Normalise the red, green and blue values\n    const {\n      _a: r255,\n      _b: g255,\n      _c: b255\n    } = this.rgb();\n    const [r, g, b] = [r255, g255, b255].map(v => v / 255);\n\n    // Convert to the lab rgb space\n    const rL = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n    const gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n    const bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\n\n    // Convert to the xyz color space without bounding the values\n    const xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047;\n    const yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1.0;\n    const zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883;\n\n    // Get the proper xyz values by applying the bounding\n    const x = xU > 0.008856 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116;\n    const y = yU > 0.008856 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116;\n    const z = zU > 0.008856 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116;\n\n    // Make and return the color\n    const color = new Color(x, y, z, 'xyz');\n    return color;\n  }\n\n  /*\n  Input and Output methods\n  */\n\n  _clamped() {\n    const {\n      _a,\n      _b,\n      _c\n    } = this.rgb();\n    const {\n      max,\n      min,\n      round\n    } = Math;\n    const format = v => max(0, min(round(v), 255));\n    return [_a, _b, _c].map(format);\n  }\n\n  /*\n  Constructing colors\n  */\n}\n\nclass Point {\n  // Initialize\n  constructor(...args) {\n    this.init(...args);\n  }\n\n  // Clone point\n  clone() {\n    return new Point(this);\n  }\n  init(x, y) {\n    const base = {\n      x: 0,\n      y: 0\n    };\n\n    // ensure source as object\n    const source = Array.isArray(x) ? {\n      x: x[0],\n      y: x[1]\n    } : typeof x === 'object' ? {\n      x: x.x,\n      y: x.y\n    } : {\n      x: x,\n      y: y\n    };\n\n    // merge source\n    this.x = source.x == null ? base.x : source.x;\n    this.y = source.y == null ? base.y : source.y;\n    return this;\n  }\n  toArray() {\n    return [this.x, this.y];\n  }\n  transform(m) {\n    return this.clone().transformO(m);\n  }\n\n  // Transform point with matrix\n  transformO(m) {\n    if (!Matrix.isMatrixLike(m)) {\n      m = new Matrix(m);\n    }\n    const {\n      x,\n      y\n    } = this;\n\n    // Perform the matrix multiplication\n    this.x = m.a * x + m.c * y + m.e;\n    this.y = m.b * x + m.d * y + m.f;\n    return this;\n  }\n}\nfunction point(x, y) {\n  return new Point(x, y).transformO(this.screenCTM().inverseO());\n}\n\nfunction closeEnough(a, b, threshold) {\n  return Math.abs(b - a) < (1e-6);\n}\nclass Matrix {\n  constructor(...args) {\n    this.init(...args);\n  }\n  static formatTransforms(o) {\n    // Get all of the parameters required to form the matrix\n    const flipBoth = o.flip === 'both' || o.flip === true;\n    const flipX = o.flip && (flipBoth || o.flip === 'x') ? -1 : 1;\n    const flipY = o.flip && (flipBoth || o.flip === 'y') ? -1 : 1;\n    const skewX = o.skew && o.skew.length ? o.skew[0] : isFinite(o.skew) ? o.skew : isFinite(o.skewX) ? o.skewX : 0;\n    const skewY = o.skew && o.skew.length ? o.skew[1] : isFinite(o.skew) ? o.skew : isFinite(o.skewY) ? o.skewY : 0;\n    const scaleX = o.scale && o.scale.length ? o.scale[0] * flipX : isFinite(o.scale) ? o.scale * flipX : isFinite(o.scaleX) ? o.scaleX * flipX : flipX;\n    const scaleY = o.scale && o.scale.length ? o.scale[1] * flipY : isFinite(o.scale) ? o.scale * flipY : isFinite(o.scaleY) ? o.scaleY * flipY : flipY;\n    const shear = o.shear || 0;\n    const theta = o.rotate || o.theta || 0;\n    const origin = new Point(o.origin || o.around || o.ox || o.originX, o.oy || o.originY);\n    const ox = origin.x;\n    const oy = origin.y;\n    // We need Point to be invalid if nothing was passed because we cannot default to 0 here. That is why NaN\n    const position = new Point(o.position || o.px || o.positionX || NaN, o.py || o.positionY || NaN);\n    const px = position.x;\n    const py = position.y;\n    const translate = new Point(o.translate || o.tx || o.translateX, o.ty || o.translateY);\n    const tx = translate.x;\n    const ty = translate.y;\n    const relative = new Point(o.relative || o.rx || o.relativeX, o.ry || o.relativeY);\n    const rx = relative.x;\n    const ry = relative.y;\n\n    // Populate all of the values\n    return {\n      scaleX,\n      scaleY,\n      skewX,\n      skewY,\n      shear,\n      theta,\n      rx,\n      ry,\n      tx,\n      ty,\n      ox,\n      oy,\n      px,\n      py\n    };\n  }\n  static fromArray(a) {\n    return {\n      a: a[0],\n      b: a[1],\n      c: a[2],\n      d: a[3],\n      e: a[4],\n      f: a[5]\n    };\n  }\n  static isMatrixLike(o) {\n    return o.a != null || o.b != null || o.c != null || o.d != null || o.e != null || o.f != null;\n  }\n\n  // left matrix, right matrix, target matrix which is overwritten\n  static matrixMultiply(l, r, o) {\n    // Work out the product directly\n    const a = l.a * r.a + l.c * r.b;\n    const b = l.b * r.a + l.d * r.b;\n    const c = l.a * r.c + l.c * r.d;\n    const d = l.b * r.c + l.d * r.d;\n    const e = l.e + l.a * r.e + l.c * r.f;\n    const f = l.f + l.b * r.e + l.d * r.f;\n\n    // make sure to use local variables because l/r and o could be the same\n    o.a = a;\n    o.b = b;\n    o.c = c;\n    o.d = d;\n    o.e = e;\n    o.f = f;\n    return o;\n  }\n  around(cx, cy, matrix) {\n    return this.clone().aroundO(cx, cy, matrix);\n  }\n\n  // Transform around a center point\n  aroundO(cx, cy, matrix) {\n    const dx = cx || 0;\n    const dy = cy || 0;\n    return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy);\n  }\n\n  // Clones this matrix\n  clone() {\n    return new Matrix(this);\n  }\n\n  // Decomposes this matrix into its affine parameters\n  decompose(cx = 0, cy = 0) {\n    // Get the parameters from the matrix\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const e = this.e;\n    const f = this.f;\n\n    // Figure out if the winding direction is clockwise or counterclockwise\n    const determinant = a * d - b * c;\n    const ccw = determinant > 0 ? 1 : -1;\n\n    // Since we only shear in x, we can use the x basis to get the x scale\n    // and the rotation of the resulting matrix\n    const sx = ccw * Math.sqrt(a * a + b * b);\n    const thetaRad = Math.atan2(ccw * b, ccw * a);\n    const theta = 180 / Math.PI * thetaRad;\n    const ct = Math.cos(thetaRad);\n    const st = Math.sin(thetaRad);\n\n    // We can then solve the y basis vector simultaneously to get the other\n    // two affine parameters directly from these parameters\n    const lam = (a * c + b * d) / determinant;\n    const sy = c * sx / (lam * a - b) || d * sx / (lam * b + a);\n\n    // Use the translations\n    const tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy);\n    const ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy);\n\n    // Construct the decomposition and return it\n    return {\n      // Return the affine parameters\n      scaleX: sx,\n      scaleY: sy,\n      shear: lam,\n      rotate: theta,\n      translateX: tx,\n      translateY: ty,\n      originX: cx,\n      originY: cy,\n      // Return the matrix parameters\n      a: this.a,\n      b: this.b,\n      c: this.c,\n      d: this.d,\n      e: this.e,\n      f: this.f\n    };\n  }\n\n  // Check if two matrices are equal\n  equals(other) {\n    if (other === this) return true;\n    const comp = new Matrix(other);\n    return closeEnough(this.a, comp.a) && closeEnough(this.b, comp.b) && closeEnough(this.c, comp.c) && closeEnough(this.d, comp.d) && closeEnough(this.e, comp.e) && closeEnough(this.f, comp.f);\n  }\n\n  // Flip matrix on x or y, at a given offset\n  flip(axis, around) {\n    return this.clone().flipO(axis, around);\n  }\n  flipO(axis, around) {\n    return axis === 'x' ? this.scaleO(-1, 1, around, 0) : axis === 'y' ? this.scaleO(1, -1, 0, around) : this.scaleO(-1, -1, axis, around || axis); // Define an x, y flip point\n  }\n\n  // Initialize\n  init(source) {\n    const base = Matrix.fromArray([1, 0, 0, 1, 0, 0]);\n\n    // ensure source as object\n    source = source instanceof Element ? source.matrixify() : typeof source === 'string' ? Matrix.fromArray(source.split(delimiter).map(parseFloat)) : Array.isArray(source) ? Matrix.fromArray(source) : typeof source === 'object' && Matrix.isMatrixLike(source) ? source : typeof source === 'object' ? new Matrix().transform(source) : arguments.length === 6 ? Matrix.fromArray([].slice.call(arguments)) : base;\n\n    // Merge the source matrix with the base matrix\n    this.a = source.a != null ? source.a : base.a;\n    this.b = source.b != null ? source.b : base.b;\n    this.c = source.c != null ? source.c : base.c;\n    this.d = source.d != null ? source.d : base.d;\n    this.e = source.e != null ? source.e : base.e;\n    this.f = source.f != null ? source.f : base.f;\n    return this;\n  }\n  inverse() {\n    return this.clone().inverseO();\n  }\n\n  // Inverses matrix\n  inverseO() {\n    // Get the current parameters out of the matrix\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const e = this.e;\n    const f = this.f;\n\n    // Invert the 2x2 matrix in the top left\n    const det = a * d - b * c;\n    if (!det) throw new Error('Cannot invert ' + this);\n\n    // Calculate the top 2x2 matrix\n    const na = d / det;\n    const nb = -b / det;\n    const nc = -c / det;\n    const nd = a / det;\n\n    // Apply the inverted matrix to the top right\n    const ne = -(na * e + nc * f);\n    const nf = -(nb * e + nd * f);\n\n    // Construct the inverted matrix\n    this.a = na;\n    this.b = nb;\n    this.c = nc;\n    this.d = nd;\n    this.e = ne;\n    this.f = nf;\n    return this;\n  }\n  lmultiply(matrix) {\n    return this.clone().lmultiplyO(matrix);\n  }\n  lmultiplyO(matrix) {\n    const r = this;\n    const l = matrix instanceof Matrix ? matrix : new Matrix(matrix);\n    return Matrix.matrixMultiply(l, r, this);\n  }\n\n  // Left multiplies by the given matrix\n  multiply(matrix) {\n    return this.clone().multiplyO(matrix);\n  }\n  multiplyO(matrix) {\n    // Get the matrices\n    const l = this;\n    const r = matrix instanceof Matrix ? matrix : new Matrix(matrix);\n    return Matrix.matrixMultiply(l, r, this);\n  }\n\n  // Rotate matrix\n  rotate(r, cx, cy) {\n    return this.clone().rotateO(r, cx, cy);\n  }\n  rotateO(r, cx = 0, cy = 0) {\n    // Convert degrees to radians\n    r = radians(r);\n    const cos = Math.cos(r);\n    const sin = Math.sin(r);\n    const {\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    } = this;\n    this.a = a * cos - b * sin;\n    this.b = b * cos + a * sin;\n    this.c = c * cos - d * sin;\n    this.d = d * cos + c * sin;\n    this.e = e * cos - f * sin + cy * sin - cx * cos + cx;\n    this.f = f * cos + e * sin - cx * sin - cy * cos + cy;\n    return this;\n  }\n\n  // Scale matrix\n  scale() {\n    return this.clone().scaleO(...arguments);\n  }\n  scaleO(x, y = x, cx = 0, cy = 0) {\n    // Support uniform scaling\n    if (arguments.length === 3) {\n      cy = cx;\n      cx = y;\n      y = x;\n    }\n    const {\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    } = this;\n    this.a = a * x;\n    this.b = b * y;\n    this.c = c * x;\n    this.d = d * y;\n    this.e = e * x - cx * x + cx;\n    this.f = f * y - cy * y + cy;\n    return this;\n  }\n\n  // Shear matrix\n  shear(a, cx, cy) {\n    return this.clone().shearO(a, cx, cy);\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  shearO(lx, cx = 0, cy = 0) {\n    const {\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    } = this;\n    this.a = a + b * lx;\n    this.c = c + d * lx;\n    this.e = e + f * lx - cy * lx;\n    return this;\n  }\n\n  // Skew Matrix\n  skew() {\n    return this.clone().skewO(...arguments);\n  }\n  skewO(x, y = x, cx = 0, cy = 0) {\n    // support uniformal skew\n    if (arguments.length === 3) {\n      cy = cx;\n      cx = y;\n      y = x;\n    }\n\n    // Convert degrees to radians\n    x = radians(x);\n    y = radians(y);\n    const lx = Math.tan(x);\n    const ly = Math.tan(y);\n    const {\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    } = this;\n    this.a = a + b * lx;\n    this.b = b + a * ly;\n    this.c = c + d * lx;\n    this.d = d + c * ly;\n    this.e = e + f * lx - cy * lx;\n    this.f = f + e * ly - cx * ly;\n    return this;\n  }\n\n  // SkewX\n  skewX(x, cx, cy) {\n    return this.skew(x, 0, cx, cy);\n  }\n\n  // SkewY\n  skewY(y, cx, cy) {\n    return this.skew(0, y, cx, cy);\n  }\n  toArray() {\n    return [this.a, this.b, this.c, this.d, this.e, this.f];\n  }\n\n  // Convert matrix to string\n  toString() {\n    return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')';\n  }\n\n  // Transform a matrix into another matrix by manipulating the space\n  transform(o) {\n    // Check if o is a matrix and then left multiply it directly\n    if (Matrix.isMatrixLike(o)) {\n      const matrix = new Matrix(o);\n      return matrix.multiplyO(this);\n    }\n\n    // Get the proposed transformations and the current transformations\n    const t = Matrix.formatTransforms(o);\n    const current = this;\n    const {\n      x: ox,\n      y: oy\n    } = new Point(t.ox, t.oy).transform(current);\n\n    // Construct the resulting matrix\n    const transformer = new Matrix().translateO(t.rx, t.ry).lmultiplyO(current).translateO(-ox, -oy).scaleO(t.scaleX, t.scaleY).skewO(t.skewX, t.skewY).shearO(t.shear).rotateO(t.theta).translateO(ox, oy);\n\n    // If we want the origin at a particular place, we force it there\n    if (isFinite(t.px) || isFinite(t.py)) {\n      const origin = new Point(ox, oy).transform(transformer);\n      // TODO: Replace t.px with isFinite(t.px)\n      // Doesn't work because t.px is also 0 if it wasn't passed\n      const dx = isFinite(t.px) ? t.px - origin.x : 0;\n      const dy = isFinite(t.py) ? t.py - origin.y : 0;\n      transformer.translateO(dx, dy);\n    }\n\n    // Translate now after positioning\n    transformer.translateO(t.tx, t.ty);\n    return transformer;\n  }\n\n  // Translate matrix\n  translate(x, y) {\n    return this.clone().translateO(x, y);\n  }\n  translateO(x, y) {\n    this.e += x || 0;\n    this.f += y || 0;\n    return this;\n  }\n  valueOf() {\n    return {\n      a: this.a,\n      b: this.b,\n      c: this.c,\n      d: this.d,\n      e: this.e,\n      f: this.f\n    };\n  }\n}\nfunction ctm() {\n  return new Matrix(this.node.getCTM());\n}\nfunction screenCTM() {\n  try {\n    /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\n       This is needed because FF does not return the transformation matrix\n       for the inner coordinate system when getScreenCTM() is called on nested svgs.\n       However all other Browsers do that */\n    if (typeof this.isRoot === 'function' && !this.isRoot()) {\n      const rect = this.rect(1, 1);\n      const m = rect.node.getScreenCTM();\n      rect.remove();\n      return new Matrix(m);\n    }\n    return new Matrix(this.node.getScreenCTM());\n  } catch (e) {\n    console.warn(`Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`);\n    return new Matrix();\n  }\n}\nregister(Matrix, 'Matrix');\n\nfunction parser() {\n  // Reuse cached element if possible\n  if (!parser.nodes) {\n    const svg = makeInstance().size(2, 0);\n    svg.node.style.cssText = ['opacity: 0', 'position: absolute', 'left: -100%', 'top: -100%', 'overflow: hidden'].join(';');\n    svg.attr('focusable', 'false');\n    svg.attr('aria-hidden', 'true');\n    const path = svg.path().node;\n    parser.nodes = {\n      svg,\n      path\n    };\n  }\n  if (!parser.nodes.svg.node.parentNode) {\n    const b = globals.document.body || globals.document.documentElement;\n    parser.nodes.svg.addTo(b);\n  }\n  return parser.nodes;\n}\n\nfunction isNulledBox(box) {\n  return !box.width && !box.height && !box.x && !box.y;\n}\nfunction domContains(node) {\n  return node === globals.document || (globals.document.documentElement.contains || function (node) {\n    // This is IE - it does not support contains() for top-level SVGs\n    while (node.parentNode) {\n      node = node.parentNode;\n    }\n    return node === globals.document;\n  }).call(globals.document.documentElement, node);\n}\nclass Box {\n  constructor(...args) {\n    this.init(...args);\n  }\n  addOffset() {\n    // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\n    this.x += globals.window.pageXOffset;\n    this.y += globals.window.pageYOffset;\n    return new Box(this);\n  }\n  init(source) {\n    const base = [0, 0, 0, 0];\n    source = typeof source === 'string' ? source.split(delimiter).map(parseFloat) : Array.isArray(source) ? source : typeof source === 'object' ? [source.left != null ? source.left : source.x, source.top != null ? source.top : source.y, source.width, source.height] : arguments.length === 4 ? [].slice.call(arguments) : base;\n    this.x = source[0] || 0;\n    this.y = source[1] || 0;\n    this.width = this.w = source[2] || 0;\n    this.height = this.h = source[3] || 0;\n\n    // Add more bounding box properties\n    this.x2 = this.x + this.w;\n    this.y2 = this.y + this.h;\n    this.cx = this.x + this.w / 2;\n    this.cy = this.y + this.h / 2;\n    return this;\n  }\n  isNulled() {\n    return isNulledBox(this);\n  }\n\n  // Merge rect box with another, return a new instance\n  merge(box) {\n    const x = Math.min(this.x, box.x);\n    const y = Math.min(this.y, box.y);\n    const width = Math.max(this.x + this.width, box.x + box.width) - x;\n    const height = Math.max(this.y + this.height, box.y + box.height) - y;\n    return new Box(x, y, width, height);\n  }\n  toArray() {\n    return [this.x, this.y, this.width, this.height];\n  }\n  toString() {\n    return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;\n  }\n  transform(m) {\n    if (!(m instanceof Matrix)) {\n      m = new Matrix(m);\n    }\n    let xMin = Infinity;\n    let xMax = -Infinity;\n    let yMin = Infinity;\n    let yMax = -Infinity;\n    const pts = [new Point(this.x, this.y), new Point(this.x2, this.y), new Point(this.x, this.y2), new Point(this.x2, this.y2)];\n    pts.forEach(function (p) {\n      p = p.transform(m);\n      xMin = Math.min(xMin, p.x);\n      xMax = Math.max(xMax, p.x);\n      yMin = Math.min(yMin, p.y);\n      yMax = Math.max(yMax, p.y);\n    });\n    return new Box(xMin, yMin, xMax - xMin, yMax - yMin);\n  }\n}\nfunction getBox(el, getBBoxFn, retry) {\n  let box;\n  try {\n    // Try to get the box with the provided function\n    box = getBBoxFn(el.node);\n\n    // If the box is worthless and not even in the dom, retry\n    // by throwing an error here...\n    if (isNulledBox(box) && !domContains(el.node)) {\n      throw new Error('Element not in the dom');\n    }\n  } catch (e) {\n    // ... and calling the retry handler here\n    box = retry(el);\n  }\n  return box;\n}\nfunction bbox() {\n  // Function to get bbox is getBBox()\n  const getBBox = node => node.getBBox();\n\n  // Take all measures so that a stupid browser renders the element\n  // so we can get the bbox from it when we try again\n  const retry = el => {\n    try {\n      const clone = el.clone().addTo(parser().svg).show();\n      const box = clone.node.getBBox();\n      clone.remove();\n      return box;\n    } catch (e) {\n      // We give up...\n      throw new Error(`Getting bbox of element \"${el.node.nodeName}\" is not possible: ${e.toString()}`);\n    }\n  };\n  const box = getBox(this, getBBox, retry);\n  const bbox = new Box(box);\n  return bbox;\n}\nfunction rbox(el) {\n  const getRBox = node => node.getBoundingClientRect();\n  const retry = el => {\n    // There is no point in trying tricks here because if we insert the element into the dom ourselves\n    // it obviously will be at the wrong position\n    throw new Error(`Getting rbox of element \"${el.node.nodeName}\" is not possible`);\n  };\n  const box = getBox(this, getRBox, retry);\n  const rbox = new Box(box);\n\n  // If an element was passed, we want the bbox in the coordinate system of that element\n  if (el) {\n    return rbox.transform(el.screenCTM().inverseO());\n  }\n\n  // Else we want it in absolute screen coordinates\n  // Therefore we need to add the scrollOffset\n  return rbox.addOffset();\n}\n\n// Checks whether the given point is inside the bounding box\nfunction inside(x, y) {\n  const box = this.bbox();\n  return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;\n}\nregisterMethods({\n  viewbox: {\n    viewbox(x, y, width, height) {\n      // act as getter\n      if (x == null) return new Box(this.attr('viewBox'));\n\n      // act as setter\n      return this.attr('viewBox', new Box(x, y, width, height));\n    },\n    zoom(level, point) {\n      // Its best to rely on the attributes here and here is why:\n      // clientXYZ: Doesn't work on non-root svgs because they dont have a CSSBox (silly!)\n      // getBoundingClientRect: Doesn't work because Chrome just ignores width and height of nested svgs completely\n      //                        that means, their clientRect is always as big as the content.\n      //                        Furthermore this size is incorrect if the element is further transformed by its parents\n      // computedStyle: Only returns meaningful values if css was used with px. We dont go this route here!\n      // getBBox: returns the bounding box of its content - that doesn't help!\n      let {\n        width,\n        height\n      } = this.attr(['width', 'height']);\n\n      // Width and height is a string when a number with a unit is present which we can't use\n      // So we try clientXYZ\n      if (!width && !height || typeof width === 'string' || typeof height === 'string') {\n        width = this.node.clientWidth;\n        height = this.node.clientHeight;\n      }\n\n      // Giving up...\n      if (!width || !height) {\n        throw new Error('Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element');\n      }\n      const v = this.viewbox();\n      const zoomX = width / v.width;\n      const zoomY = height / v.height;\n      const zoom = Math.min(zoomX, zoomY);\n      if (level == null) {\n        return zoom;\n      }\n      let zoomAmount = zoom / level;\n\n      // Set the zoomAmount to the highest value which is safe to process and recover from\n      // The * 100 is a bit of wiggle room for the matrix transformation\n      if (zoomAmount === Infinity) zoomAmount = Number.MAX_SAFE_INTEGER / 100;\n      point = point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y);\n      const box = new Box(v).transform(new Matrix({\n        scale: zoomAmount,\n        origin: point\n      }));\n      return this.viewbox(box);\n    }\n  }\n});\nregister(Box, 'Box');\n\n// import { subClassArray } from './ArrayPolyfill.js'\n\nclass List extends Array {\n  constructor(arr = [], ...args) {\n    super(arr, ...args);\n    if (typeof arr === 'number') return this;\n    this.length = 0;\n    this.push(...arr);\n  }\n}\nextend([List], {\n  each(fnOrMethodName, ...args) {\n    if (typeof fnOrMethodName === 'function') {\n      return this.map((el, i, arr) => {\n        return fnOrMethodName.call(el, el, i, arr);\n      });\n    } else {\n      return this.map(el => {\n        return el[fnOrMethodName](...args);\n      });\n    }\n  },\n  toArray() {\n    return Array.prototype.concat.apply([], this);\n  }\n});\nconst reserved = ['toArray', 'constructor', 'each'];\nList.extend = function (methods) {\n  methods = methods.reduce((obj, name) => {\n    // Don't overwrite own methods\n    if (reserved.includes(name)) return obj;\n\n    // Don't add private methods\n    if (name[0] === '_') return obj;\n\n    // Allow access to original Array methods through a prefix\n    if (name in Array.prototype) {\n      obj['$' + name] = Array.prototype[name];\n    }\n\n    // Relay every call to each()\n    obj[name] = function (...attrs) {\n      return this.each(name, ...attrs);\n    };\n    return obj;\n  }, {});\n  extend([List], methods);\n};\n\nfunction baseFind(query, parent) {\n  return new List(map((parent || globals.document).querySelectorAll(query), function (node) {\n    return adopt(node);\n  }));\n}\n\n// Scoped find method\nfunction find(query) {\n  return baseFind(query, this.node);\n}\nfunction findOne(query) {\n  return adopt(this.node.querySelector(query));\n}\n\nlet listenerId = 0;\nconst windowEvents = {};\nfunction getEvents(instance) {\n  let n = instance.getEventHolder();\n\n  // We dont want to save events in global space\n  if (n === globals.window) n = windowEvents;\n  if (!n.events) n.events = {};\n  return n.events;\n}\nfunction getEventTarget(instance) {\n  return instance.getEventTarget();\n}\nfunction clearEvents(instance) {\n  let n = instance.getEventHolder();\n  if (n === globals.window) n = windowEvents;\n  if (n.events) n.events = {};\n}\n\n// Add event binder in the SVG namespace\nfunction on(node, events, listener, binding, options) {\n  const l = listener.bind(binding || node);\n  const instance = makeInstance(node);\n  const bag = getEvents(instance);\n  const n = getEventTarget(instance);\n\n  // events can be an array of events or a string of events\n  events = Array.isArray(events) ? events : events.split(delimiter);\n\n  // add id to listener\n  if (!listener._svgjsListenerId) {\n    listener._svgjsListenerId = ++listenerId;\n  }\n  events.forEach(function (event) {\n    const ev = event.split('.')[0];\n    const ns = event.split('.')[1] || '*';\n\n    // ensure valid object\n    bag[ev] = bag[ev] || {};\n    bag[ev][ns] = bag[ev][ns] || {};\n\n    // reference listener\n    bag[ev][ns][listener._svgjsListenerId] = l;\n\n    // add listener\n    n.addEventListener(ev, l, options || false);\n  });\n}\n\n// Add event unbinder in the SVG namespace\nfunction off(node, events, listener, options) {\n  const instance = makeInstance(node);\n  const bag = getEvents(instance);\n  const n = getEventTarget(instance);\n\n  // listener can be a function or a number\n  if (typeof listener === 'function') {\n    listener = listener._svgjsListenerId;\n    if (!listener) return;\n  }\n\n  // events can be an array of events or a string or undefined\n  events = Array.isArray(events) ? events : (events || '').split(delimiter);\n  events.forEach(function (event) {\n    const ev = event && event.split('.')[0];\n    const ns = event && event.split('.')[1];\n    let namespace, l;\n    if (listener) {\n      // remove listener reference\n      if (bag[ev] && bag[ev][ns || '*']) {\n        // removeListener\n        n.removeEventListener(ev, bag[ev][ns || '*'][listener], options || false);\n        delete bag[ev][ns || '*'][listener];\n      }\n    } else if (ev && ns) {\n      // remove all listeners for a namespaced event\n      if (bag[ev] && bag[ev][ns]) {\n        for (l in bag[ev][ns]) {\n          off(n, [ev, ns].join('.'), l);\n        }\n        delete bag[ev][ns];\n      }\n    } else if (ns) {\n      // remove all listeners for a specific namespace\n      for (event in bag) {\n        for (namespace in bag[event]) {\n          if (ns === namespace) {\n            off(n, [event, ns].join('.'));\n          }\n        }\n      }\n    } else if (ev) {\n      // remove all listeners for the event\n      if (bag[ev]) {\n        for (namespace in bag[ev]) {\n          off(n, [ev, namespace].join('.'));\n        }\n        delete bag[ev];\n      }\n    } else {\n      // remove all listeners on a given node\n      for (event in bag) {\n        off(n, event);\n      }\n      clearEvents(instance);\n    }\n  });\n}\nfunction dispatch(node, event, data, options) {\n  const n = getEventTarget(node);\n\n  // Dispatch event\n  if (event instanceof globals.window.Event) {\n    n.dispatchEvent(event);\n  } else {\n    event = new globals.window.CustomEvent(event, {\n      detail: data,\n      cancelable: true,\n      ...options\n    });\n    n.dispatchEvent(event);\n  }\n  return event;\n}\n\nclass EventTarget extends Base {\n  addEventListener() {}\n  dispatch(event, data, options) {\n    return dispatch(this, event, data, options);\n  }\n  dispatchEvent(event) {\n    const bag = this.getEventHolder().events;\n    if (!bag) return true;\n    const events = bag[event.type];\n    for (const i in events) {\n      for (const j in events[i]) {\n        events[i][j](event);\n      }\n    }\n    return !event.defaultPrevented;\n  }\n\n  // Fire given event\n  fire(event, data, options) {\n    this.dispatch(event, data, options);\n    return this;\n  }\n  getEventHolder() {\n    return this;\n  }\n  getEventTarget() {\n    return this;\n  }\n\n  // Unbind event from listener\n  off(event, listener, options) {\n    off(this, event, listener, options);\n    return this;\n  }\n\n  // Bind given event to listener\n  on(event, listener, binding, options) {\n    on(this, event, listener, binding, options);\n    return this;\n  }\n  removeEventListener() {}\n}\nregister(EventTarget, 'EventTarget');\n\nfunction noop() {}\n\n// Default animation values\nconst timeline = {\n  duration: 400,\n  ease: '>',\n  delay: 0\n};\n\n// Default attribute values\nconst attrs = {\n  // fill and stroke\n  'fill-opacity': 1,\n  'stroke-opacity': 1,\n  'stroke-width': 0,\n  'stroke-linejoin': 'miter',\n  'stroke-linecap': 'butt',\n  fill: '#000000',\n  stroke: '#000000',\n  opacity: 1,\n  // position\n  x: 0,\n  y: 0,\n  cx: 0,\n  cy: 0,\n  // size\n  width: 0,\n  height: 0,\n  // radius\n  r: 0,\n  rx: 0,\n  ry: 0,\n  // gradient\n  offset: 0,\n  'stop-opacity': 1,\n  'stop-color': '#000000',\n  // text\n  'text-anchor': 'start'\n};\n\nvar defaults = {\n  __proto__: null,\n  attrs: attrs,\n  noop: noop,\n  timeline: timeline\n};\n\nclass SVGArray extends Array {\n  constructor(...args) {\n    super(...args);\n    this.init(...args);\n  }\n  clone() {\n    return new this.constructor(this);\n  }\n  init(arr) {\n    // This catches the case, that native map tries to create an array with new Array(1)\n    if (typeof arr === 'number') return this;\n    this.length = 0;\n    this.push(...this.parse(arr));\n    return this;\n  }\n\n  // Parse whitespace separated string\n  parse(array = []) {\n    // If already is an array, no need to parse it\n    if (array instanceof Array) return array;\n    return array.trim().split(delimiter).map(parseFloat);\n  }\n  toArray() {\n    return Array.prototype.concat.apply([], this);\n  }\n  toSet() {\n    return new Set(this);\n  }\n  toString() {\n    return this.join(' ');\n  }\n\n  // Flattens the array if needed\n  valueOf() {\n    const ret = [];\n    ret.push(...this);\n    return ret;\n  }\n}\n\n// Module for unit conversions\nclass SVGNumber {\n  // Initialize\n  constructor(...args) {\n    this.init(...args);\n  }\n  convert(unit) {\n    return new SVGNumber(this.value, unit);\n  }\n\n  // Divide number\n  divide(number) {\n    number = new SVGNumber(number);\n    return new SVGNumber(this / number, this.unit || number.unit);\n  }\n  init(value, unit) {\n    unit = Array.isArray(value) ? value[1] : unit;\n    value = Array.isArray(value) ? value[0] : value;\n\n    // initialize defaults\n    this.value = 0;\n    this.unit = unit || '';\n\n    // parse value\n    if (typeof value === 'number') {\n      // ensure a valid numeric value\n      this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4e38 : +3.4e38 : value;\n    } else if (typeof value === 'string') {\n      unit = value.match(numberAndUnit);\n      if (unit) {\n        // make value numeric\n        this.value = parseFloat(unit[1]);\n\n        // normalize\n        if (unit[5] === '%') {\n          this.value /= 100;\n        } else if (unit[5] === 's') {\n          this.value *= 1000;\n        }\n\n        // store unit\n        this.unit = unit[5];\n      }\n    } else {\n      if (value instanceof SVGNumber) {\n        this.value = value.valueOf();\n        this.unit = value.unit;\n      }\n    }\n    return this;\n  }\n\n  // Subtract number\n  minus(number) {\n    number = new SVGNumber(number);\n    return new SVGNumber(this - number, this.unit || number.unit);\n  }\n\n  // Add number\n  plus(number) {\n    number = new SVGNumber(number);\n    return new SVGNumber(this + number, this.unit || number.unit);\n  }\n\n  // Multiply number\n  times(number) {\n    number = new SVGNumber(number);\n    return new SVGNumber(this * number, this.unit || number.unit);\n  }\n  toArray() {\n    return [this.value, this.unit];\n  }\n  toJSON() {\n    return this.toString();\n  }\n  toString() {\n    return (this.unit === '%' ? ~~(this.value * 1e8) / 1e6 : this.unit === 's' ? this.value / 1e3 : this.value) + this.unit;\n  }\n  valueOf() {\n    return this.value;\n  }\n}\n\nconst colorAttributes = new Set(['fill', 'stroke', 'color', 'bgcolor', 'stop-color', 'flood-color', 'lighting-color']);\nconst hooks = [];\nfunction registerAttrHook(fn) {\n  hooks.push(fn);\n}\n\n// Set svg element attribute\nfunction attr(attr, val, ns) {\n  // act as full getter\n  if (attr == null) {\n    // get an object of attributes\n    attr = {};\n    val = this.node.attributes;\n    for (const node of val) {\n      attr[node.nodeName] = isNumber.test(node.nodeValue) ? parseFloat(node.nodeValue) : node.nodeValue;\n    }\n    return attr;\n  } else if (attr instanceof Array) {\n    // loop through array and get all values\n    return attr.reduce((last, curr) => {\n      last[curr] = this.attr(curr);\n      return last;\n    }, {});\n  } else if (typeof attr === 'object' && attr.constructor === Object) {\n    // apply every attribute individually if an object is passed\n    for (val in attr) this.attr(val, attr[val]);\n  } else if (val === null) {\n    // remove value\n    this.node.removeAttribute(attr);\n  } else if (val == null) {\n    // act as a getter if the first and only argument is not an object\n    val = this.node.getAttribute(attr);\n    return val == null ? attrs[attr] : isNumber.test(val) ? parseFloat(val) : val;\n  } else {\n    // Loop through hooks and execute them to convert value\n    val = hooks.reduce((_val, hook) => {\n      return hook(attr, _val, this);\n    }, val);\n\n    // ensure correct numeric values (also accepts NaN and Infinity)\n    if (typeof val === 'number') {\n      val = new SVGNumber(val);\n    } else if (colorAttributes.has(attr) && Color.isColor(val)) {\n      // ensure full hex color\n      val = new Color(val);\n    } else if (val.constructor === Array) {\n      // Check for plain arrays and parse array values\n      val = new SVGArray(val);\n    }\n\n    // if the passed attribute is leading...\n    if (attr === 'leading') {\n      // ... call the leading method instead\n      if (this.leading) {\n        this.leading(val);\n      }\n    } else {\n      // set given attribute on node\n      typeof ns === 'string' ? this.node.setAttributeNS(ns, attr, val.toString()) : this.node.setAttribute(attr, val.toString());\n    }\n\n    // rebuild if required\n    if (this.rebuild && (attr === 'font-size' || attr === 'x')) {\n      this.rebuild();\n    }\n  }\n  return this;\n}\n\nclass Dom extends EventTarget {\n  constructor(node, attrs) {\n    super();\n    this.node = node;\n    this.type = node.nodeName;\n    if (attrs && node !== attrs) {\n      this.attr(attrs);\n    }\n  }\n\n  // Add given element at a position\n  add(element, i) {\n    element = makeInstance(element);\n\n    // If non-root svg nodes are added we have to remove their namespaces\n    if (element.removeNamespace && this.node instanceof globals.window.SVGElement) {\n      element.removeNamespace();\n    }\n    if (i == null) {\n      this.node.appendChild(element.node);\n    } else if (element.node !== this.node.childNodes[i]) {\n      this.node.insertBefore(element.node, this.node.childNodes[i]);\n    }\n    return this;\n  }\n\n  // Add element to given container and return self\n  addTo(parent, i) {\n    return makeInstance(parent).put(this, i);\n  }\n\n  // Returns all child elements\n  children() {\n    return new List(map(this.node.children, function (node) {\n      return adopt(node);\n    }));\n  }\n\n  // Remove all elements in this container\n  clear() {\n    // remove children\n    while (this.node.hasChildNodes()) {\n      this.node.removeChild(this.node.lastChild);\n    }\n    return this;\n  }\n\n  // Clone element\n  clone(deep = true, assignNewIds = true) {\n    // write dom data to the dom so the clone can pickup the data\n    this.writeDataToDom();\n\n    // clone element\n    let nodeClone = this.node.cloneNode(deep);\n    if (assignNewIds) {\n      // assign new id\n      nodeClone = assignNewId(nodeClone);\n    }\n    return new this.constructor(nodeClone);\n  }\n\n  // Iterates over all children and invokes a given block\n  each(block, deep) {\n    const children = this.children();\n    let i, il;\n    for (i = 0, il = children.length; i < il; i++) {\n      block.apply(children[i], [i, children]);\n      if (deep) {\n        children[i].each(block, deep);\n      }\n    }\n    return this;\n  }\n  element(nodeName, attrs) {\n    return this.put(new Dom(create(nodeName), attrs));\n  }\n\n  // Get first child\n  first() {\n    return adopt(this.node.firstChild);\n  }\n\n  // Get a element at the given index\n  get(i) {\n    return adopt(this.node.childNodes[i]);\n  }\n  getEventHolder() {\n    return this.node;\n  }\n  getEventTarget() {\n    return this.node;\n  }\n\n  // Checks if the given element is a child\n  has(element) {\n    return this.index(element) >= 0;\n  }\n  html(htmlOrFn, outerHTML) {\n    return this.xml(htmlOrFn, outerHTML, html);\n  }\n\n  // Get / set id\n  id(id) {\n    // generate new id if no id set\n    if (typeof id === 'undefined' && !this.node.id) {\n      this.node.id = eid(this.type);\n    }\n\n    // don't set directly with this.node.id to make `null` work correctly\n    return this.attr('id', id);\n  }\n\n  // Gets index of given element\n  index(element) {\n    return [].slice.call(this.node.childNodes).indexOf(element.node);\n  }\n\n  // Get the last child\n  last() {\n    return adopt(this.node.lastChild);\n  }\n\n  // matches the element vs a css selector\n  matches(selector) {\n    const el = this.node;\n    const matcher = el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector || null;\n    return matcher && matcher.call(el, selector);\n  }\n\n  // Returns the parent element instance\n  parent(type) {\n    let parent = this;\n\n    // check for parent\n    if (!parent.node.parentNode) return null;\n\n    // get parent element\n    parent = adopt(parent.node.parentNode);\n    if (!type) return parent;\n\n    // loop through ancestors if type is given\n    do {\n      if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;\n    } while (parent = adopt(parent.node.parentNode));\n    return parent;\n  }\n\n  // Basically does the same as `add()` but returns the added element instead\n  put(element, i) {\n    element = makeInstance(element);\n    this.add(element, i);\n    return element;\n  }\n\n  // Add element to given container and return container\n  putIn(parent, i) {\n    return makeInstance(parent).add(this, i);\n  }\n\n  // Remove element\n  remove() {\n    if (this.parent()) {\n      this.parent().removeElement(this);\n    }\n    return this;\n  }\n\n  // Remove a given child\n  removeElement(element) {\n    this.node.removeChild(element.node);\n    return this;\n  }\n\n  // Replace this with element\n  replace(element) {\n    element = makeInstance(element);\n    if (this.node.parentNode) {\n      this.node.parentNode.replaceChild(element.node, this.node);\n    }\n    return element;\n  }\n  round(precision = 2, map = null) {\n    const factor = 10 ** precision;\n    const attrs = this.attr(map);\n    for (const i in attrs) {\n      if (typeof attrs[i] === 'number') {\n        attrs[i] = Math.round(attrs[i] * factor) / factor;\n      }\n    }\n    this.attr(attrs);\n    return this;\n  }\n\n  // Import / Export raw svg\n  svg(svgOrFn, outerSVG) {\n    return this.xml(svgOrFn, outerSVG, svg);\n  }\n\n  // Return id on string conversion\n  toString() {\n    return this.id();\n  }\n  words(text) {\n    // This is faster than removing all children and adding a new one\n    this.node.textContent = text;\n    return this;\n  }\n  wrap(node) {\n    const parent = this.parent();\n    if (!parent) {\n      return this.addTo(node);\n    }\n    const position = parent.index(this);\n    return parent.put(node, position).put(this);\n  }\n\n  // write svgjs data to the dom\n  writeDataToDom() {\n    // dump variables recursively\n    this.each(function () {\n      this.writeDataToDom();\n    });\n    return this;\n  }\n\n  // Import / Export raw svg\n  xml(xmlOrFn, outerXML, ns) {\n    if (typeof xmlOrFn === 'boolean') {\n      ns = outerXML;\n      outerXML = xmlOrFn;\n      xmlOrFn = null;\n    }\n\n    // act as getter if no svg string is given\n    if (xmlOrFn == null || typeof xmlOrFn === 'function') {\n      // The default for exports is, that the outerNode is included\n      outerXML = outerXML == null ? true : outerXML;\n\n      // write svgjs data to the dom\n      this.writeDataToDom();\n      let current = this;\n\n      // An export modifier was passed\n      if (xmlOrFn != null) {\n        current = adopt(current.node.cloneNode(true));\n\n        // If the user wants outerHTML we need to process this node, too\n        if (outerXML) {\n          const result = xmlOrFn(current);\n          current = result || current;\n\n          // The user does not want this node? Well, then he gets nothing\n          if (result === false) return '';\n        }\n\n        // Deep loop through all children and apply modifier\n        current.each(function () {\n          const result = xmlOrFn(this);\n          const _this = result || this;\n\n          // If modifier returns false, discard node\n          if (result === false) {\n            this.remove();\n\n            // If modifier returns new node, use it\n          } else if (result && this !== _this) {\n            this.replace(_this);\n          }\n        }, true);\n      }\n\n      // Return outer or inner content\n      return outerXML ? current.node.outerHTML : current.node.innerHTML;\n    }\n\n    // Act as setter if we got a string\n\n    // The default for import is, that the current node is not replaced\n    outerXML = outerXML == null ? false : outerXML;\n\n    // Create temporary holder\n    const well = create('wrapper', ns);\n    const fragment = globals.document.createDocumentFragment();\n\n    // Dump raw svg\n    well.innerHTML = xmlOrFn;\n\n    // Transplant nodes into the fragment\n    for (let len = well.children.length; len--;) {\n      fragment.appendChild(well.firstElementChild);\n    }\n    const parent = this.parent();\n\n    // Add the whole fragment at once\n    return outerXML ? this.replace(fragment) && parent : this.add(fragment);\n  }\n}\nextend(Dom, {\n  attr,\n  find,\n  findOne\n});\nregister(Dom, 'Dom');\n\nclass Element extends Dom {\n  constructor(node, attrs) {\n    super(node, attrs);\n\n    // initialize data object\n    this.dom = {};\n\n    // create circular reference\n    this.node.instance = this;\n    if (node.hasAttribute('data-svgjs') || node.hasAttribute('svgjs:data')) {\n      // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\n      this.setData(JSON.parse(node.getAttribute('data-svgjs')) ?? JSON.parse(node.getAttribute('svgjs:data')) ?? {});\n    }\n  }\n\n  // Move element by its center\n  center(x, y) {\n    return this.cx(x).cy(y);\n  }\n\n  // Move by center over x-axis\n  cx(x) {\n    return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);\n  }\n\n  // Move by center over y-axis\n  cy(y) {\n    return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);\n  }\n\n  // Get defs\n  defs() {\n    const root = this.root();\n    return root && root.defs();\n  }\n\n  // Relative move over x and y axes\n  dmove(x, y) {\n    return this.dx(x).dy(y);\n  }\n\n  // Relative move over x axis\n  dx(x = 0) {\n    return this.x(new SVGNumber(x).plus(this.x()));\n  }\n\n  // Relative move over y axis\n  dy(y = 0) {\n    return this.y(new SVGNumber(y).plus(this.y()));\n  }\n  getEventHolder() {\n    return this;\n  }\n\n  // Set height of element\n  height(height) {\n    return this.attr('height', height);\n  }\n\n  // Move element to given x and y values\n  move(x, y) {\n    return this.x(x).y(y);\n  }\n\n  // return array of all ancestors of given type up to the root svg\n  parents(until = this.root()) {\n    const isSelector = typeof until === 'string';\n    if (!isSelector) {\n      until = makeInstance(until);\n    }\n    const parents = new List();\n    let parent = this;\n    while ((parent = parent.parent()) && parent.node !== globals.document && parent.nodeName !== '#document-fragment') {\n      parents.push(parent);\n      if (!isSelector && parent.node === until.node) {\n        break;\n      }\n      if (isSelector && parent.matches(until)) {\n        break;\n      }\n      if (parent.node === this.root().node) {\n        // We worked our way to the root and didn't match `until`\n        return null;\n      }\n    }\n    return parents;\n  }\n\n  // Get referenced element form attribute value\n  reference(attr) {\n    attr = this.attr(attr);\n    if (!attr) return null;\n    const m = (attr + '').match(reference);\n    return m ? makeInstance(m[1]) : null;\n  }\n\n  // Get parent document\n  root() {\n    const p = this.parent(getClass(root));\n    return p && p.root();\n  }\n\n  // set given data to the elements data property\n  setData(o) {\n    this.dom = o;\n    return this;\n  }\n\n  // Set element size to given width and height\n  size(width, height) {\n    const p = proportionalSize(this, width, height);\n    return this.width(new SVGNumber(p.width)).height(new SVGNumber(p.height));\n  }\n\n  // Set width of element\n  width(width) {\n    return this.attr('width', width);\n  }\n\n  // write svgjs data to the dom\n  writeDataToDom() {\n    writeDataToDom(this, this.dom);\n    return super.writeDataToDom();\n  }\n\n  // Move over x-axis\n  x(x) {\n    return this.attr('x', x);\n  }\n\n  // Move over y-axis\n  y(y) {\n    return this.attr('y', y);\n  }\n}\nextend(Element, {\n  bbox,\n  rbox,\n  inside,\n  point,\n  ctm,\n  screenCTM\n});\nregister(Element, 'Element');\n\n// Define list of available attributes for stroke and fill\nconst sugar = {\n  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'],\n  fill: ['color', 'opacity', 'rule'],\n  prefix: function (t, a) {\n    return a === 'color' ? t : t + '-' + a;\n  }\n}\n\n// Add sugar for fill and stroke\n;\n['fill', 'stroke'].forEach(function (m) {\n  const extension = {};\n  let i;\n  extension[m] = function (o) {\n    if (typeof o === 'undefined') {\n      return this.attr(m);\n    }\n    if (typeof o === 'string' || o instanceof Color || Color.isRgb(o) || o instanceof Element) {\n      this.attr(m, o);\n    } else {\n      // set all attributes from sugar.fill and sugar.stroke list\n      for (i = sugar[m].length - 1; i >= 0; i--) {\n        if (o[sugar[m][i]] != null) {\n          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);\n        }\n      }\n    }\n    return this;\n  };\n  registerMethods(['Element', 'Runner'], extension);\n});\nregisterMethods(['Element', 'Runner'], {\n  // Let the user set the matrix directly\n  matrix: function (mat, b, c, d, e, f) {\n    // Act as a getter\n    if (mat == null) {\n      return new Matrix(this);\n    }\n\n    // Act as a setter, the user can pass a matrix or a set of numbers\n    return this.attr('transform', new Matrix(mat, b, c, d, e, f));\n  },\n  // Map rotation to transform\n  rotate: function (angle, cx, cy) {\n    return this.transform({\n      rotate: angle,\n      ox: cx,\n      oy: cy\n    }, true);\n  },\n  // Map skew to transform\n  skew: function (x, y, cx, cy) {\n    return arguments.length === 1 || arguments.length === 3 ? this.transform({\n      skew: x,\n      ox: y,\n      oy: cx\n    }, true) : this.transform({\n      skew: [x, y],\n      ox: cx,\n      oy: cy\n    }, true);\n  },\n  shear: function (lam, cx, cy) {\n    return this.transform({\n      shear: lam,\n      ox: cx,\n      oy: cy\n    }, true);\n  },\n  // Map scale to transform\n  scale: function (x, y, cx, cy) {\n    return arguments.length === 1 || arguments.length === 3 ? this.transform({\n      scale: x,\n      ox: y,\n      oy: cx\n    }, true) : this.transform({\n      scale: [x, y],\n      ox: cx,\n      oy: cy\n    }, true);\n  },\n  // Map translate to transform\n  translate: function (x, y) {\n    return this.transform({\n      translate: [x, y]\n    }, true);\n  },\n  // Map relative translations to transform\n  relative: function (x, y) {\n    return this.transform({\n      relative: [x, y]\n    }, true);\n  },\n  // Map flip to transform\n  flip: function (direction = 'both', origin = 'center') {\n    if ('xybothtrue'.indexOf(direction) === -1) {\n      origin = direction;\n      direction = 'both';\n    }\n    return this.transform({\n      flip: direction,\n      origin: origin\n    }, true);\n  },\n  // Opacity\n  opacity: function (value) {\n    return this.attr('opacity', value);\n  }\n});\nregisterMethods('radius', {\n  // Add x and y radius\n  radius: function (x, y = x) {\n    const type = (this._element || this).type;\n    return type === 'radialGradient' ? this.attr('r', new SVGNumber(x)) : this.rx(x).ry(y);\n  }\n});\nregisterMethods('Path', {\n  // Get path length\n  length: function () {\n    return this.node.getTotalLength();\n  },\n  // Get point at length\n  pointAt: function (length) {\n    return new Point(this.node.getPointAtLength(length));\n  }\n});\nregisterMethods(['Element', 'Runner'], {\n  // Set font\n  font: function (a, v) {\n    if (typeof a === 'object') {\n      for (v in a) this.font(v, a[v]);\n      return this;\n    }\n    return a === 'leading' ? this.leading(v) : a === 'anchor' ? this.attr('text-anchor', v) : a === 'size' || a === 'family' || a === 'weight' || a === 'stretch' || a === 'variant' || a === 'style' ? this.attr('font-' + a, v) : this.attr(a, v);\n  }\n});\n\n// Add events to elements\nconst methods = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'mouseenter', 'mouseleave', 'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel', 'contextmenu', 'wheel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel'].reduce(function (last, event) {\n  // add event to Element\n  const fn = function (f) {\n    if (f === null) {\n      this.off(event);\n    } else {\n      this.on(event, f);\n    }\n    return this;\n  };\n  last[event] = fn;\n  return last;\n}, {});\nregisterMethods('Element', methods);\n\n// Reset all transformations\nfunction untransform() {\n  return this.attr('transform', null);\n}\n\n// merge the whole transformation chain into one matrix and returns it\nfunction matrixify() {\n  const matrix = (this.attr('transform') || ''\n  // split transformations\n  ).split(transforms).slice(0, -1).map(function (str) {\n    // generate key => value pairs\n    const kv = str.trim().split('(');\n    return [kv[0], kv[1].split(delimiter).map(function (str) {\n      return parseFloat(str);\n    })];\n  }).reverse()\n  // merge every transformation into one matrix\n  .reduce(function (matrix, transform) {\n    if (transform[0] === 'matrix') {\n      return matrix.lmultiply(Matrix.fromArray(transform[1]));\n    }\n    return matrix[transform[0]].apply(matrix, transform[1]);\n  }, new Matrix());\n  return matrix;\n}\n\n// add an element to another parent without changing the visual representation on the screen\nfunction toParent(parent, i) {\n  if (this === parent) return this;\n  if (isDescriptive(this.node)) return this.addTo(parent, i);\n  const ctm = this.screenCTM();\n  const pCtm = parent.screenCTM().inverse();\n  this.addTo(parent, i).untransform().transform(pCtm.multiply(ctm));\n  return this;\n}\n\n// same as above with parent equals root-svg\nfunction toRoot(i) {\n  return this.toParent(this.root(), i);\n}\n\n// Add transformations\nfunction transform(o, relative) {\n  // Act as a getter if no object was passed\n  if (o == null || typeof o === 'string') {\n    const decomposed = new Matrix(this).decompose();\n    return o == null ? decomposed : decomposed[o];\n  }\n  if (!Matrix.isMatrixLike(o)) {\n    // Set the origin according to the defined transform\n    o = {\n      ...o,\n      origin: getOrigin(o, this)\n    };\n  }\n\n  // The user can pass a boolean, an Element or an Matrix or nothing\n  const cleanRelative = relative === true ? this : relative || false;\n  const result = new Matrix(cleanRelative).transform(o);\n  return this.attr('transform', result);\n}\nregisterMethods('Element', {\n  untransform,\n  matrixify,\n  toParent,\n  toRoot,\n  transform\n});\n\nclass Container extends Element {\n  flatten() {\n    this.each(function () {\n      if (this instanceof Container) {\n        return this.flatten().ungroup();\n      }\n    });\n    return this;\n  }\n  ungroup(parent = this.parent(), index = parent.index(this)) {\n    // when parent != this, we want append all elements to the end\n    index = index === -1 ? parent.children().length : index;\n    this.each(function (i, children) {\n      // reverse each\n      return children[children.length - i - 1].toParent(parent, index);\n    });\n    return this.remove();\n  }\n}\nregister(Container, 'Container');\n\nclass Defs extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('defs', node), attrs);\n  }\n  flatten() {\n    return this;\n  }\n  ungroup() {\n    return this;\n  }\n}\nregister(Defs, 'Defs');\n\nclass Shape extends Element {}\nregister(Shape, 'Shape');\n\n// Radius x value\nfunction rx(rx) {\n  return this.attr('rx', rx);\n}\n\n// Radius y value\nfunction ry(ry) {\n  return this.attr('ry', ry);\n}\n\n// Move over x-axis\nfunction x$3(x) {\n  return x == null ? this.cx() - this.rx() : this.cx(x + this.rx());\n}\n\n// Move over y-axis\nfunction y$3(y) {\n  return y == null ? this.cy() - this.ry() : this.cy(y + this.ry());\n}\n\n// Move by center over x-axis\nfunction cx$1(x) {\n  return this.attr('cx', x);\n}\n\n// Move by center over y-axis\nfunction cy$1(y) {\n  return this.attr('cy', y);\n}\n\n// Set width of element\nfunction width$2(width) {\n  return width == null ? this.rx() * 2 : this.rx(new SVGNumber(width).divide(2));\n}\n\n// Set height of element\nfunction height$2(height) {\n  return height == null ? this.ry() * 2 : this.ry(new SVGNumber(height).divide(2));\n}\n\nvar circled = {\n  __proto__: null,\n  cx: cx$1,\n  cy: cy$1,\n  height: height$2,\n  rx: rx,\n  ry: ry,\n  width: width$2,\n  x: x$3,\n  y: y$3\n};\n\nclass Ellipse extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('ellipse', node), attrs);\n  }\n  size(width, height) {\n    const p = proportionalSize(this, width, height);\n    return this.rx(new SVGNumber(p.width).divide(2)).ry(new SVGNumber(p.height).divide(2));\n  }\n}\nextend(Ellipse, circled);\nregisterMethods('Container', {\n  // Create an ellipse\n  ellipse: wrapWithAttrCheck(function (width = 0, height = width) {\n    return this.put(new Ellipse()).size(width, height).move(0, 0);\n  })\n});\nregister(Ellipse, 'Ellipse');\n\nclass Fragment extends Dom {\n  constructor(node = globals.document.createDocumentFragment()) {\n    super(node);\n  }\n\n  // Import / Export raw xml\n  xml(xmlOrFn, outerXML, ns) {\n    if (typeof xmlOrFn === 'boolean') {\n      ns = outerXML;\n      outerXML = xmlOrFn;\n      xmlOrFn = null;\n    }\n\n    // because this is a fragment we have to put all elements into a wrapper first\n    // before we can get the innerXML from it\n    if (xmlOrFn == null || typeof xmlOrFn === 'function') {\n      const wrapper = new Dom(create('wrapper', ns));\n      wrapper.add(this.node.cloneNode(true));\n      return wrapper.xml(false, ns);\n    }\n\n    // Act as setter if we got a string\n    return super.xml(xmlOrFn, false, ns);\n  }\n}\nregister(Fragment, 'Fragment');\n\nfunction from(x, y) {\n  return (this._element || this).type === 'radialGradient' ? this.attr({\n    fx: new SVGNumber(x),\n    fy: new SVGNumber(y)\n  }) : this.attr({\n    x1: new SVGNumber(x),\n    y1: new SVGNumber(y)\n  });\n}\nfunction to(x, y) {\n  return (this._element || this).type === 'radialGradient' ? this.attr({\n    cx: new SVGNumber(x),\n    cy: new SVGNumber(y)\n  }) : this.attr({\n    x2: new SVGNumber(x),\n    y2: new SVGNumber(y)\n  });\n}\n\nvar gradiented = {\n  __proto__: null,\n  from: from,\n  to: to\n};\n\nclass Gradient extends Container {\n  constructor(type, attrs) {\n    super(nodeOrNew(type + 'Gradient', typeof type === 'string' ? null : type), attrs);\n  }\n\n  // custom attr to handle transform\n  attr(a, b, c) {\n    if (a === 'transform') a = 'gradientTransform';\n    return super.attr(a, b, c);\n  }\n  bbox() {\n    return new Box();\n  }\n  targets() {\n    return baseFind('svg [fill*=' + this.id() + ']');\n  }\n\n  // Alias string conversion to fill\n  toString() {\n    return this.url();\n  }\n\n  // Update gradient\n  update(block) {\n    // remove all stops\n    this.clear();\n\n    // invoke passed block\n    if (typeof block === 'function') {\n      block.call(this, this);\n    }\n    return this;\n  }\n\n  // Return the fill id\n  url() {\n    return 'url(#' + this.id() + ')';\n  }\n}\nextend(Gradient, gradiented);\nregisterMethods({\n  Container: {\n    // Create gradient element in defs\n    gradient(...args) {\n      return this.defs().gradient(...args);\n    }\n  },\n  // define gradient\n  Defs: {\n    gradient: wrapWithAttrCheck(function (type, block) {\n      return this.put(new Gradient(type)).update(block);\n    })\n  }\n});\nregister(Gradient, 'Gradient');\n\nclass Pattern extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('pattern', node), attrs);\n  }\n\n  // custom attr to handle transform\n  attr(a, b, c) {\n    if (a === 'transform') a = 'patternTransform';\n    return super.attr(a, b, c);\n  }\n  bbox() {\n    return new Box();\n  }\n  targets() {\n    return baseFind('svg [fill*=' + this.id() + ']');\n  }\n\n  // Alias string conversion to fill\n  toString() {\n    return this.url();\n  }\n\n  // Update pattern by rebuilding\n  update(block) {\n    // remove content\n    this.clear();\n\n    // invoke passed block\n    if (typeof block === 'function') {\n      block.call(this, this);\n    }\n    return this;\n  }\n\n  // Return the fill id\n  url() {\n    return 'url(#' + this.id() + ')';\n  }\n}\nregisterMethods({\n  Container: {\n    // Create pattern element in defs\n    pattern(...args) {\n      return this.defs().pattern(...args);\n    }\n  },\n  Defs: {\n    pattern: wrapWithAttrCheck(function (width, height, block) {\n      return this.put(new Pattern()).update(block).attr({\n        x: 0,\n        y: 0,\n        width: width,\n        height: height,\n        patternUnits: 'userSpaceOnUse'\n      });\n    })\n  }\n});\nregister(Pattern, 'Pattern');\n\nclass Image extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('image', node), attrs);\n  }\n\n  // (re)load image\n  load(url, callback) {\n    if (!url) return this;\n    const img = new globals.window.Image();\n    on(img, 'load', function (e) {\n      const p = this.parent(Pattern);\n\n      // ensure image size\n      if (this.width() === 0 && this.height() === 0) {\n        this.size(img.width, img.height);\n      }\n      if (p instanceof Pattern) {\n        // ensure pattern size if not set\n        if (p.width() === 0 && p.height() === 0) {\n          p.size(this.width(), this.height());\n        }\n      }\n      if (typeof callback === 'function') {\n        callback.call(this, e);\n      }\n    }, this);\n    on(img, 'load error', function () {\n      // dont forget to unbind memory leaking events\n      off(img);\n    });\n    return this.attr('href', img.src = url, xlink);\n  }\n}\nregisterAttrHook(function (attr, val, _this) {\n  // convert image fill and stroke to patterns\n  if (attr === 'fill' || attr === 'stroke') {\n    if (isImage.test(val)) {\n      val = _this.root().defs().image(val);\n    }\n  }\n  if (val instanceof Image) {\n    val = _this.root().defs().pattern(0, 0, pattern => {\n      pattern.add(val);\n    });\n  }\n  return val;\n});\nregisterMethods({\n  Container: {\n    // create image element, load image and set its size\n    image: wrapWithAttrCheck(function (source, callback) {\n      return this.put(new Image()).size(0, 0).load(source, callback);\n    })\n  }\n});\nregister(Image, 'Image');\n\nclass PointArray extends SVGArray {\n  // Get bounding box of points\n  bbox() {\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let minX = Infinity;\n    let minY = Infinity;\n    this.forEach(function (el) {\n      maxX = Math.max(el[0], maxX);\n      maxY = Math.max(el[1], maxY);\n      minX = Math.min(el[0], minX);\n      minY = Math.min(el[1], minY);\n    });\n    return new Box(minX, minY, maxX - minX, maxY - minY);\n  }\n\n  // Move point string\n  move(x, y) {\n    const box = this.bbox();\n\n    // get relative offset\n    x -= box.x;\n    y -= box.y;\n\n    // move every point\n    if (!isNaN(x) && !isNaN(y)) {\n      for (let i = this.length - 1; i >= 0; i--) {\n        this[i] = [this[i][0] + x, this[i][1] + y];\n      }\n    }\n    return this;\n  }\n\n  // Parse point string and flat array\n  parse(array = [0, 0]) {\n    const points = [];\n\n    // if it is an array, we flatten it and therefore clone it to 1 depths\n    if (array instanceof Array) {\n      array = Array.prototype.concat.apply([], array);\n    } else {\n      // Else, it is considered as a string\n      // parse points\n      array = array.trim().split(delimiter).map(parseFloat);\n    }\n\n    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\n    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\n    if (array.length % 2 !== 0) array.pop();\n\n    // wrap points in two-tuples\n    for (let i = 0, len = array.length; i < len; i = i + 2) {\n      points.push([array[i], array[i + 1]]);\n    }\n    return points;\n  }\n\n  // Resize poly string\n  size(width, height) {\n    let i;\n    const box = this.bbox();\n\n    // recalculate position of all points according to new size\n    for (i = this.length - 1; i >= 0; i--) {\n      if (box.width) this[i][0] = (this[i][0] - box.x) * width / box.width + box.x;\n      if (box.height) this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;\n    }\n    return this;\n  }\n\n  // Convert array to line object\n  toLine() {\n    return {\n      x1: this[0][0],\n      y1: this[0][1],\n      x2: this[1][0],\n      y2: this[1][1]\n    };\n  }\n\n  // Convert array to string\n  toString() {\n    const array = [];\n    // convert to a poly point string\n    for (let i = 0, il = this.length; i < il; i++) {\n      array.push(this[i].join(','));\n    }\n    return array.join(' ');\n  }\n  transform(m) {\n    return this.clone().transformO(m);\n  }\n\n  // transform points with matrix (similar to Point.transform)\n  transformO(m) {\n    if (!Matrix.isMatrixLike(m)) {\n      m = new Matrix(m);\n    }\n    for (let i = this.length; i--;) {\n      // Perform the matrix multiplication\n      const [x, y] = this[i];\n      this[i][0] = m.a * x + m.c * y + m.e;\n      this[i][1] = m.b * x + m.d * y + m.f;\n    }\n    return this;\n  }\n}\n\nconst MorphArray = PointArray;\n\n// Move by left top corner over x-axis\nfunction x$2(x) {\n  return x == null ? this.bbox().x : this.move(x, this.bbox().y);\n}\n\n// Move by left top corner over y-axis\nfunction y$2(y) {\n  return y == null ? this.bbox().y : this.move(this.bbox().x, y);\n}\n\n// Set width of element\nfunction width$1(width) {\n  const b = this.bbox();\n  return width == null ? b.width : this.size(width, b.height);\n}\n\n// Set height of element\nfunction height$1(height) {\n  const b = this.bbox();\n  return height == null ? b.height : this.size(b.width, height);\n}\n\nvar pointed = {\n  __proto__: null,\n  MorphArray: MorphArray,\n  height: height$1,\n  width: width$1,\n  x: x$2,\n  y: y$2\n};\n\nclass Line extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('line', node), attrs);\n  }\n\n  // Get array\n  array() {\n    return new PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]);\n  }\n\n  // Move by left top corner\n  move(x, y) {\n    return this.attr(this.array().move(x, y).toLine());\n  }\n\n  // Overwrite native plot() method\n  plot(x1, y1, x2, y2) {\n    if (x1 == null) {\n      return this.array();\n    } else if (typeof y1 !== 'undefined') {\n      x1 = {\n        x1,\n        y1,\n        x2,\n        y2\n      };\n    } else {\n      x1 = new PointArray(x1).toLine();\n    }\n    return this.attr(x1);\n  }\n\n  // Set element size to given width and height\n  size(width, height) {\n    const p = proportionalSize(this, width, height);\n    return this.attr(this.array().size(p.width, p.height).toLine());\n  }\n}\nextend(Line, pointed);\nregisterMethods({\n  Container: {\n    // Create a line element\n    line: wrapWithAttrCheck(function (...args) {\n      // make sure plot is called as a setter\n      // x1 is not necessarily a number, it can also be an array, a string and a PointArray\n      return Line.prototype.plot.apply(this.put(new Line()), args[0] != null ? args : [0, 0, 0, 0]);\n    })\n  }\n});\nregister(Line, 'Line');\n\nclass Marker extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('marker', node), attrs);\n  }\n\n  // Set height of element\n  height(height) {\n    return this.attr('markerHeight', height);\n  }\n  orient(orient) {\n    return this.attr('orient', orient);\n  }\n\n  // Set marker refX and refY\n  ref(x, y) {\n    return this.attr('refX', x).attr('refY', y);\n  }\n\n  // Return the fill id\n  toString() {\n    return 'url(#' + this.id() + ')';\n  }\n\n  // Update marker\n  update(block) {\n    // remove all content\n    this.clear();\n\n    // invoke passed block\n    if (typeof block === 'function') {\n      block.call(this, this);\n    }\n    return this;\n  }\n\n  // Set width of element\n  width(width) {\n    return this.attr('markerWidth', width);\n  }\n}\nregisterMethods({\n  Container: {\n    marker(...args) {\n      // Create marker element in defs\n      return this.defs().marker(...args);\n    }\n  },\n  Defs: {\n    // Create marker\n    marker: wrapWithAttrCheck(function (width, height, block) {\n      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\n      return this.put(new Marker()).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr('orient', 'auto').update(block);\n    })\n  },\n  marker: {\n    // Create and attach markers\n    marker(marker, width, height, block) {\n      let attr = ['marker'];\n\n      // Build attribute name\n      if (marker !== 'all') attr.push(marker);\n      attr = attr.join('-');\n\n      // Set marker attribute\n      marker = arguments[1] instanceof Marker ? arguments[1] : this.defs().marker(width, height, block);\n      return this.attr(attr, marker);\n    }\n  }\n});\nregister(Marker, 'Marker');\n\n/***\nBase Class\n==========\nThe base stepper class that will be\n***/\n\nfunction makeSetterGetter(k, f) {\n  return function (v) {\n    if (v == null) return this[k];\n    this[k] = v;\n    if (f) f.call(this);\n    return this;\n  };\n}\nconst easing = {\n  '-': function (pos) {\n    return pos;\n  },\n  '<>': function (pos) {\n    return -Math.cos(pos * Math.PI) / 2 + 0.5;\n  },\n  '>': function (pos) {\n    return Math.sin(pos * Math.PI / 2);\n  },\n  '<': function (pos) {\n    return -Math.cos(pos * Math.PI / 2) + 1;\n  },\n  bezier: function (x1, y1, x2, y2) {\n    // see https://www.w3.org/TR/css-easing-1/#cubic-bezier-algo\n    return function (t) {\n      if (t < 0) {\n        if (x1 > 0) {\n          return y1 / x1 * t;\n        } else if (x2 > 0) {\n          return y2 / x2 * t;\n        } else {\n          return 0;\n        }\n      } else if (t > 1) {\n        if (x2 < 1) {\n          return (1 - y2) / (1 - x2) * t + (y2 - x2) / (1 - x2);\n        } else if (x1 < 1) {\n          return (1 - y1) / (1 - x1) * t + (y1 - x1) / (1 - x1);\n        } else {\n          return 1;\n        }\n      } else {\n        return 3 * t * (1 - t) ** 2 * y1 + 3 * t ** 2 * (1 - t) * y2 + t ** 3;\n      }\n    };\n  },\n  // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo\n  steps: function (steps, stepPosition = 'end') {\n    // deal with \"jump-\" prefix\n    stepPosition = stepPosition.split('-').reverse()[0];\n    let jumps = steps;\n    if (stepPosition === 'none') {\n      --jumps;\n    } else if (stepPosition === 'both') {\n      ++jumps;\n    }\n\n    // The beforeFlag is essentially useless\n    return (t, beforeFlag = false) => {\n      // Step is called currentStep in referenced url\n      let step = Math.floor(t * steps);\n      const jumping = t * step % 1 === 0;\n      if (stepPosition === 'start' || stepPosition === 'both') {\n        ++step;\n      }\n      if (beforeFlag && jumping) {\n        --step;\n      }\n      if (t >= 0 && step < 0) {\n        step = 0;\n      }\n      if (t <= 1 && step > jumps) {\n        step = jumps;\n      }\n      return step / jumps;\n    };\n  }\n};\nclass Stepper {\n  done() {\n    return false;\n  }\n}\n\n/***\nEasing Functions\n================\n***/\n\nclass Ease extends Stepper {\n  constructor(fn = timeline.ease) {\n    super();\n    this.ease = easing[fn] || fn;\n  }\n  step(from, to, pos) {\n    if (typeof from !== 'number') {\n      return pos < 1 ? from : to;\n    }\n    return from + (to - from) * this.ease(pos);\n  }\n}\n\n/***\nController Types\n================\n***/\n\nclass Controller extends Stepper {\n  constructor(fn) {\n    super();\n    this.stepper = fn;\n  }\n  done(c) {\n    return c.done;\n  }\n  step(current, target, dt, c) {\n    return this.stepper(current, target, dt, c);\n  }\n}\nfunction recalculate() {\n  // Apply the default parameters\n  const duration = (this._duration || 500) / 1000;\n  const overshoot = this._overshoot || 0;\n\n  // Calculate the PID natural response\n  const eps = 1e-10;\n  const pi = Math.PI;\n  const os = Math.log(overshoot / 100 + eps);\n  const zeta = -os / Math.sqrt(pi * pi + os * os);\n  const wn = 3.9 / (zeta * duration);\n\n  // Calculate the Spring values\n  this.d = 2 * zeta * wn;\n  this.k = wn * wn;\n}\nclass Spring extends Controller {\n  constructor(duration = 500, overshoot = 0) {\n    super();\n    this.duration(duration).overshoot(overshoot);\n  }\n  step(current, target, dt, c) {\n    if (typeof current === 'string') return current;\n    c.done = dt === Infinity;\n    if (dt === Infinity) return target;\n    if (dt === 0) return current;\n    if (dt > 100) dt = 16;\n    dt /= 1000;\n\n    // Get the previous velocity\n    const velocity = c.velocity || 0;\n\n    // Apply the control to get the new position and store it\n    const acceleration = -this.d * velocity - this.k * (current - target);\n    const newPosition = current + velocity * dt + acceleration * dt * dt / 2;\n\n    // Store the velocity\n    c.velocity = velocity + acceleration * dt;\n\n    // Figure out if we have converged, and if so, pass the value\n    c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 0.002;\n    return c.done ? target : newPosition;\n  }\n}\nextend(Spring, {\n  duration: makeSetterGetter('_duration', recalculate),\n  overshoot: makeSetterGetter('_overshoot', recalculate)\n});\nclass PID extends Controller {\n  constructor(p = 0.1, i = 0.01, d = 0, windup = 1000) {\n    super();\n    this.p(p).i(i).d(d).windup(windup);\n  }\n  step(current, target, dt, c) {\n    if (typeof current === 'string') return current;\n    c.done = dt === Infinity;\n    if (dt === Infinity) return target;\n    if (dt === 0) return current;\n    const p = target - current;\n    let i = (c.integral || 0) + p * dt;\n    const d = (p - (c.error || 0)) / dt;\n    const windup = this._windup;\n\n    // antiwindup\n    if (windup !== false) {\n      i = Math.max(-windup, Math.min(i, windup));\n    }\n    c.error = p;\n    c.integral = i;\n    c.done = Math.abs(p) < 0.001;\n    return c.done ? target : current + (this.P * p + this.I * i + this.D * d);\n  }\n}\nextend(PID, {\n  windup: makeSetterGetter('_windup'),\n  p: makeSetterGetter('P'),\n  i: makeSetterGetter('I'),\n  d: makeSetterGetter('D')\n});\n\nconst segmentParameters = {\n  M: 2,\n  L: 2,\n  H: 1,\n  V: 1,\n  C: 6,\n  S: 4,\n  Q: 4,\n  T: 2,\n  A: 7,\n  Z: 0\n};\nconst pathHandlers = {\n  M: function (c, p, p0) {\n    p.x = p0.x = c[0];\n    p.y = p0.y = c[1];\n    return ['M', p.x, p.y];\n  },\n  L: function (c, p) {\n    p.x = c[0];\n    p.y = c[1];\n    return ['L', c[0], c[1]];\n  },\n  H: function (c, p) {\n    p.x = c[0];\n    return ['H', c[0]];\n  },\n  V: function (c, p) {\n    p.y = c[0];\n    return ['V', c[0]];\n  },\n  C: function (c, p) {\n    p.x = c[4];\n    p.y = c[5];\n    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];\n  },\n  S: function (c, p) {\n    p.x = c[2];\n    p.y = c[3];\n    return ['S', c[0], c[1], c[2], c[3]];\n  },\n  Q: function (c, p) {\n    p.x = c[2];\n    p.y = c[3];\n    return ['Q', c[0], c[1], c[2], c[3]];\n  },\n  T: function (c, p) {\n    p.x = c[0];\n    p.y = c[1];\n    return ['T', c[0], c[1]];\n  },\n  Z: function (c, p, p0) {\n    p.x = p0.x;\n    p.y = p0.y;\n    return ['Z'];\n  },\n  A: function (c, p) {\n    p.x = c[5];\n    p.y = c[6];\n    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]];\n  }\n};\nconst mlhvqtcsaz = 'mlhvqtcsaz'.split('');\nfor (let i = 0, il = mlhvqtcsaz.length; i < il; ++i) {\n  pathHandlers[mlhvqtcsaz[i]] = function (i) {\n    return function (c, p, p0) {\n      if (i === 'H') c[0] = c[0] + p.x;else if (i === 'V') c[0] = c[0] + p.y;else if (i === 'A') {\n        c[5] = c[5] + p.x;\n        c[6] = c[6] + p.y;\n      } else {\n        for (let j = 0, jl = c.length; j < jl; ++j) {\n          c[j] = c[j] + (j % 2 ? p.y : p.x);\n        }\n      }\n      return pathHandlers[i](c, p, p0);\n    };\n  }(mlhvqtcsaz[i].toUpperCase());\n}\nfunction makeAbsolut(parser) {\n  const command = parser.segment[0];\n  return pathHandlers[command](parser.segment.slice(1), parser.p, parser.p0);\n}\nfunction segmentComplete(parser) {\n  return parser.segment.length && parser.segment.length - 1 === segmentParameters[parser.segment[0].toUpperCase()];\n}\nfunction startNewSegment(parser, token) {\n  parser.inNumber && finalizeNumber(parser, false);\n  const pathLetter = isPathLetter.test(token);\n  if (pathLetter) {\n    parser.segment = [token];\n  } else {\n    const lastCommand = parser.lastCommand;\n    const small = lastCommand.toLowerCase();\n    const isSmall = lastCommand === small;\n    parser.segment = [small === 'm' ? isSmall ? 'l' : 'L' : lastCommand];\n  }\n  parser.inSegment = true;\n  parser.lastCommand = parser.segment[0];\n  return pathLetter;\n}\nfunction finalizeNumber(parser, inNumber) {\n  if (!parser.inNumber) throw new Error('Parser Error');\n  parser.number && parser.segment.push(parseFloat(parser.number));\n  parser.inNumber = inNumber;\n  parser.number = '';\n  parser.pointSeen = false;\n  parser.hasExponent = false;\n  if (segmentComplete(parser)) {\n    finalizeSegment(parser);\n  }\n}\nfunction finalizeSegment(parser) {\n  parser.inSegment = false;\n  if (parser.absolute) {\n    parser.segment = makeAbsolut(parser);\n  }\n  parser.segments.push(parser.segment);\n}\nfunction isArcFlag(parser) {\n  if (!parser.segment.length) return false;\n  const isArc = parser.segment[0].toUpperCase() === 'A';\n  const length = parser.segment.length;\n  return isArc && (length === 4 || length === 5);\n}\nfunction isExponential(parser) {\n  return parser.lastToken.toUpperCase() === 'E';\n}\nconst pathDelimiters = new Set([' ', ',', '\\t', '\\n', '\\r', '\\f']);\nfunction pathParser(d, toAbsolute = true) {\n  let index = 0;\n  let token = '';\n  const parser = {\n    segment: [],\n    inNumber: false,\n    number: '',\n    lastToken: '',\n    inSegment: false,\n    segments: [],\n    pointSeen: false,\n    hasExponent: false,\n    absolute: toAbsolute,\n    p0: new Point(),\n    p: new Point()\n  };\n  while (parser.lastToken = token, token = d.charAt(index++)) {\n    if (!parser.inSegment) {\n      if (startNewSegment(parser, token)) {\n        continue;\n      }\n    }\n    if (token === '.') {\n      if (parser.pointSeen || parser.hasExponent) {\n        finalizeNumber(parser, false);\n        --index;\n        continue;\n      }\n      parser.inNumber = true;\n      parser.pointSeen = true;\n      parser.number += token;\n      continue;\n    }\n    if (!isNaN(parseInt(token))) {\n      if (parser.number === '0' || isArcFlag(parser)) {\n        parser.inNumber = true;\n        parser.number = token;\n        finalizeNumber(parser, true);\n        continue;\n      }\n      parser.inNumber = true;\n      parser.number += token;\n      continue;\n    }\n    if (pathDelimiters.has(token)) {\n      if (parser.inNumber) {\n        finalizeNumber(parser, false);\n      }\n      continue;\n    }\n    if (token === '-' || token === '+') {\n      if (parser.inNumber && !isExponential(parser)) {\n        finalizeNumber(parser, false);\n        --index;\n        continue;\n      }\n      parser.number += token;\n      parser.inNumber = true;\n      continue;\n    }\n    if (token.toUpperCase() === 'E') {\n      parser.number += token;\n      parser.hasExponent = true;\n      continue;\n    }\n    if (isPathLetter.test(token)) {\n      if (parser.inNumber) {\n        finalizeNumber(parser, false);\n      } else if (!segmentComplete(parser)) {\n        throw new Error('parser Error');\n      } else {\n        finalizeSegment(parser);\n      }\n      --index;\n    }\n  }\n  if (parser.inNumber) {\n    finalizeNumber(parser, false);\n  }\n  if (parser.inSegment && segmentComplete(parser)) {\n    finalizeSegment(parser);\n  }\n  return parser.segments;\n}\n\nfunction arrayToString(a) {\n  let s = '';\n  for (let i = 0, il = a.length; i < il; i++) {\n    s += a[i][0];\n    if (a[i][1] != null) {\n      s += a[i][1];\n      if (a[i][2] != null) {\n        s += ' ';\n        s += a[i][2];\n        if (a[i][3] != null) {\n          s += ' ';\n          s += a[i][3];\n          s += ' ';\n          s += a[i][4];\n          if (a[i][5] != null) {\n            s += ' ';\n            s += a[i][5];\n            s += ' ';\n            s += a[i][6];\n            if (a[i][7] != null) {\n              s += ' ';\n              s += a[i][7];\n            }\n          }\n        }\n      }\n    }\n  }\n  return s + ' ';\n}\nclass PathArray extends SVGArray {\n  // Get bounding box of path\n  bbox() {\n    parser().path.setAttribute('d', this.toString());\n    return new Box(parser.nodes.path.getBBox());\n  }\n\n  // Move path string\n  move(x, y) {\n    // get bounding box of current situation\n    const box = this.bbox();\n\n    // get relative offset\n    x -= box.x;\n    y -= box.y;\n    if (!isNaN(x) && !isNaN(y)) {\n      // move every point\n      for (let l, i = this.length - 1; i >= 0; i--) {\n        l = this[i][0];\n        if (l === 'M' || l === 'L' || l === 'T') {\n          this[i][1] += x;\n          this[i][2] += y;\n        } else if (l === 'H') {\n          this[i][1] += x;\n        } else if (l === 'V') {\n          this[i][1] += y;\n        } else if (l === 'C' || l === 'S' || l === 'Q') {\n          this[i][1] += x;\n          this[i][2] += y;\n          this[i][3] += x;\n          this[i][4] += y;\n          if (l === 'C') {\n            this[i][5] += x;\n            this[i][6] += y;\n          }\n        } else if (l === 'A') {\n          this[i][6] += x;\n          this[i][7] += y;\n        }\n      }\n    }\n    return this;\n  }\n\n  // Absolutize and parse path to array\n  parse(d = 'M0 0') {\n    if (Array.isArray(d)) {\n      d = Array.prototype.concat.apply([], d).toString();\n    }\n    return pathParser(d);\n  }\n\n  // Resize path string\n  size(width, height) {\n    // get bounding box of current situation\n    const box = this.bbox();\n    let i, l;\n\n    // If the box width or height is 0 then we ignore\n    // transformations on the respective axis\n    box.width = box.width === 0 ? 1 : box.width;\n    box.height = box.height === 0 ? 1 : box.height;\n\n    // recalculate position of all points according to new size\n    for (i = this.length - 1; i >= 0; i--) {\n      l = this[i][0];\n      if (l === 'M' || l === 'L' || l === 'T') {\n        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;\n        this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;\n      } else if (l === 'H') {\n        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;\n      } else if (l === 'V') {\n        this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;\n      } else if (l === 'C' || l === 'S' || l === 'Q') {\n        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;\n        this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;\n        this[i][3] = (this[i][3] - box.x) * width / box.width + box.x;\n        this[i][4] = (this[i][4] - box.y) * height / box.height + box.y;\n        if (l === 'C') {\n          this[i][5] = (this[i][5] - box.x) * width / box.width + box.x;\n          this[i][6] = (this[i][6] - box.y) * height / box.height + box.y;\n        }\n      } else if (l === 'A') {\n        // resize radii\n        this[i][1] = this[i][1] * width / box.width;\n        this[i][2] = this[i][2] * height / box.height;\n\n        // move position values\n        this[i][6] = (this[i][6] - box.x) * width / box.width + box.x;\n        this[i][7] = (this[i][7] - box.y) * height / box.height + box.y;\n      }\n    }\n    return this;\n  }\n\n  // Convert array to string\n  toString() {\n    return arrayToString(this);\n  }\n}\n\nconst getClassForType = value => {\n  const type = typeof value;\n  if (type === 'number') {\n    return SVGNumber;\n  } else if (type === 'string') {\n    if (Color.isColor(value)) {\n      return Color;\n    } else if (delimiter.test(value)) {\n      return isPathLetter.test(value) ? PathArray : SVGArray;\n    } else if (numberAndUnit.test(value)) {\n      return SVGNumber;\n    } else {\n      return NonMorphable;\n    }\n  } else if (morphableTypes.indexOf(value.constructor) > -1) {\n    return value.constructor;\n  } else if (Array.isArray(value)) {\n    return SVGArray;\n  } else if (type === 'object') {\n    return ObjectBag;\n  } else {\n    return NonMorphable;\n  }\n};\nclass Morphable {\n  constructor(stepper) {\n    this._stepper = stepper || new Ease('-');\n    this._from = null;\n    this._to = null;\n    this._type = null;\n    this._context = null;\n    this._morphObj = null;\n  }\n  at(pos) {\n    return this._morphObj.morph(this._from, this._to, pos, this._stepper, this._context);\n  }\n  done() {\n    const complete = this._context.map(this._stepper.done).reduce(function (last, curr) {\n      return last && curr;\n    }, true);\n    return complete;\n  }\n  from(val) {\n    if (val == null) {\n      return this._from;\n    }\n    this._from = this._set(val);\n    return this;\n  }\n  stepper(stepper) {\n    if (stepper == null) return this._stepper;\n    this._stepper = stepper;\n    return this;\n  }\n  to(val) {\n    if (val == null) {\n      return this._to;\n    }\n    this._to = this._set(val);\n    return this;\n  }\n  type(type) {\n    // getter\n    if (type == null) {\n      return this._type;\n    }\n\n    // setter\n    this._type = type;\n    return this;\n  }\n  _set(value) {\n    if (!this._type) {\n      this.type(getClassForType(value));\n    }\n    let result = new this._type(value);\n    if (this._type === Color) {\n      result = this._to ? result[this._to[4]]() : this._from ? result[this._from[4]]() : result;\n    }\n    if (this._type === ObjectBag) {\n      result = this._to ? result.align(this._to) : this._from ? result.align(this._from) : result;\n    }\n    result = result.toConsumable();\n    this._morphObj = this._morphObj || new this._type();\n    this._context = this._context || Array.apply(null, Array(result.length)).map(Object).map(function (o) {\n      o.done = true;\n      return o;\n    });\n    return result;\n  }\n}\nclass NonMorphable {\n  constructor(...args) {\n    this.init(...args);\n  }\n  init(val) {\n    val = Array.isArray(val) ? val[0] : val;\n    this.value = val;\n    return this;\n  }\n  toArray() {\n    return [this.value];\n  }\n  valueOf() {\n    return this.value;\n  }\n}\nclass TransformBag {\n  constructor(...args) {\n    this.init(...args);\n  }\n  init(obj) {\n    if (Array.isArray(obj)) {\n      obj = {\n        scaleX: obj[0],\n        scaleY: obj[1],\n        shear: obj[2],\n        rotate: obj[3],\n        translateX: obj[4],\n        translateY: obj[5],\n        originX: obj[6],\n        originY: obj[7]\n      };\n    }\n    Object.assign(this, TransformBag.defaults, obj);\n    return this;\n  }\n  toArray() {\n    const v = this;\n    return [v.scaleX, v.scaleY, v.shear, v.rotate, v.translateX, v.translateY, v.originX, v.originY];\n  }\n}\nTransformBag.defaults = {\n  scaleX: 1,\n  scaleY: 1,\n  shear: 0,\n  rotate: 0,\n  translateX: 0,\n  translateY: 0,\n  originX: 0,\n  originY: 0\n};\nconst sortByKey = (a, b) => {\n  return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0;\n};\nclass ObjectBag {\n  constructor(...args) {\n    this.init(...args);\n  }\n  align(other) {\n    const values = this.values;\n    for (let i = 0, il = values.length; i < il; ++i) {\n      // If the type is the same we only need to check if the color is in the correct format\n      if (values[i + 1] === other[i + 1]) {\n        if (values[i + 1] === Color && other[i + 7] !== values[i + 7]) {\n          const space = other[i + 7];\n          const color = new Color(this.values.splice(i + 3, 5))[space]().toArray();\n          this.values.splice(i + 3, 0, ...color);\n        }\n        i += values[i + 2] + 2;\n        continue;\n      }\n      if (!other[i + 1]) {\n        return this;\n      }\n\n      // The types differ, so we overwrite the new type with the old one\n      // And initialize it with the types default (e.g. black for color or 0 for number)\n      const defaultObject = new other[i + 1]().toArray();\n\n      // Than we fix the values array\n      const toDelete = values[i + 2] + 3;\n      values.splice(i, toDelete, other[i], other[i + 1], other[i + 2], ...defaultObject);\n      i += values[i + 2] + 2;\n    }\n    return this;\n  }\n  init(objOrArr) {\n    this.values = [];\n    if (Array.isArray(objOrArr)) {\n      this.values = objOrArr.slice();\n      return;\n    }\n    objOrArr = objOrArr || {};\n    const entries = [];\n    for (const i in objOrArr) {\n      const Type = getClassForType(objOrArr[i]);\n      const val = new Type(objOrArr[i]).toArray();\n      entries.push([i, Type, val.length, ...val]);\n    }\n    entries.sort(sortByKey);\n    this.values = entries.reduce((last, curr) => last.concat(curr), []);\n    return this;\n  }\n  toArray() {\n    return this.values;\n  }\n  valueOf() {\n    const obj = {};\n    const arr = this.values;\n\n    // for (var i = 0, len = arr.length; i < len; i += 2) {\n    while (arr.length) {\n      const key = arr.shift();\n      const Type = arr.shift();\n      const num = arr.shift();\n      const values = arr.splice(0, num);\n      obj[key] = new Type(values); // .valueOf()\n    }\n    return obj;\n  }\n}\nconst morphableTypes = [NonMorphable, TransformBag, ObjectBag];\nfunction registerMorphableType(type = []) {\n  morphableTypes.push(...[].concat(type));\n}\nfunction makeMorphable() {\n  extend(morphableTypes, {\n    to(val) {\n      return new Morphable().type(this.constructor).from(this.toArray()) // this.valueOf())\n      .to(val);\n    },\n    fromArray(arr) {\n      this.init(arr);\n      return this;\n    },\n    toConsumable() {\n      return this.toArray();\n    },\n    morph(from, to, pos, stepper, context) {\n      const mapper = function (i, index) {\n        return stepper.step(i, to[index], pos, context[index], context);\n      };\n      return this.fromArray(from.map(mapper));\n    }\n  });\n}\n\nclass Path extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('path', node), attrs);\n  }\n\n  // Get array\n  array() {\n    return this._array || (this._array = new PathArray(this.attr('d')));\n  }\n\n  // Clear array cache\n  clear() {\n    delete this._array;\n    return this;\n  }\n\n  // Set height of element\n  height(height) {\n    return height == null ? this.bbox().height : this.size(this.bbox().width, height);\n  }\n\n  // Move by left top corner\n  move(x, y) {\n    return this.attr('d', this.array().move(x, y));\n  }\n\n  // Plot new path\n  plot(d) {\n    return d == null ? this.array() : this.clear().attr('d', typeof d === 'string' ? d : this._array = new PathArray(d));\n  }\n\n  // Set element size to given width and height\n  size(width, height) {\n    const p = proportionalSize(this, width, height);\n    return this.attr('d', this.array().size(p.width, p.height));\n  }\n\n  // Set width of element\n  width(width) {\n    return width == null ? this.bbox().width : this.size(width, this.bbox().height);\n  }\n\n  // Move by left top corner over x-axis\n  x(x) {\n    return x == null ? this.bbox().x : this.move(x, this.bbox().y);\n  }\n\n  // Move by left top corner over y-axis\n  y(y) {\n    return y == null ? this.bbox().y : this.move(this.bbox().x, y);\n  }\n}\n\n// Define morphable array\nPath.prototype.MorphArray = PathArray;\n\n// Add parent method\nregisterMethods({\n  Container: {\n    // Create a wrapped path element\n    path: wrapWithAttrCheck(function (d) {\n      // make sure plot is called as a setter\n      return this.put(new Path()).plot(d || new PathArray());\n    })\n  }\n});\nregister(Path, 'Path');\n\n// Get array\nfunction array() {\n  return this._array || (this._array = new PointArray(this.attr('points')));\n}\n\n// Clear array cache\nfunction clear() {\n  delete this._array;\n  return this;\n}\n\n// Move by left top corner\nfunction move$2(x, y) {\n  return this.attr('points', this.array().move(x, y));\n}\n\n// Plot new path\nfunction plot(p) {\n  return p == null ? this.array() : this.clear().attr('points', typeof p === 'string' ? p : this._array = new PointArray(p));\n}\n\n// Set element size to given width and height\nfunction size$1(width, height) {\n  const p = proportionalSize(this, width, height);\n  return this.attr('points', this.array().size(p.width, p.height));\n}\n\nvar poly = {\n  __proto__: null,\n  array: array,\n  clear: clear,\n  move: move$2,\n  plot: plot,\n  size: size$1\n};\n\nclass Polygon extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('polygon', node), attrs);\n  }\n}\nregisterMethods({\n  Container: {\n    // Create a wrapped polygon element\n    polygon: wrapWithAttrCheck(function (p) {\n      // make sure plot is called as a setter\n      return this.put(new Polygon()).plot(p || new PointArray());\n    })\n  }\n});\nextend(Polygon, pointed);\nextend(Polygon, poly);\nregister(Polygon, 'Polygon');\n\nclass Polyline extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('polyline', node), attrs);\n  }\n}\nregisterMethods({\n  Container: {\n    // Create a wrapped polygon element\n    polyline: wrapWithAttrCheck(function (p) {\n      // make sure plot is called as a setter\n      return this.put(new Polyline()).plot(p || new PointArray());\n    })\n  }\n});\nextend(Polyline, pointed);\nextend(Polyline, poly);\nregister(Polyline, 'Polyline');\n\nclass Rect extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('rect', node), attrs);\n  }\n}\nextend(Rect, {\n  rx,\n  ry\n});\nregisterMethods({\n  Container: {\n    // Create a rect element\n    rect: wrapWithAttrCheck(function (width, height) {\n      return this.put(new Rect()).size(width, height);\n    })\n  }\n});\nregister(Rect, 'Rect');\n\nclass Queue {\n  constructor() {\n    this._first = null;\n    this._last = null;\n  }\n\n  // Shows us the first item in the list\n  first() {\n    return this._first && this._first.value;\n  }\n\n  // Shows us the last item in the list\n  last() {\n    return this._last && this._last.value;\n  }\n  push(value) {\n    // An item stores an id and the provided value\n    const item = typeof value.next !== 'undefined' ? value : {\n      value: value,\n      next: null,\n      prev: null\n    };\n\n    // Deal with the queue being empty or populated\n    if (this._last) {\n      item.prev = this._last;\n      this._last.next = item;\n      this._last = item;\n    } else {\n      this._last = item;\n      this._first = item;\n    }\n\n    // Return the current item\n    return item;\n  }\n\n  // Removes the item that was returned from the push\n  remove(item) {\n    // Relink the previous item\n    if (item.prev) item.prev.next = item.next;\n    if (item.next) item.next.prev = item.prev;\n    if (item === this._last) this._last = item.prev;\n    if (item === this._first) this._first = item.next;\n\n    // Invalidate item\n    item.prev = null;\n    item.next = null;\n  }\n  shift() {\n    // Check if we have a value\n    const remove = this._first;\n    if (!remove) return null;\n\n    // If we do, remove it and relink things\n    this._first = remove.next;\n    if (this._first) this._first.prev = null;\n    this._last = this._first ? this._last : null;\n    return remove.value;\n  }\n}\n\nconst Animator = {\n  nextDraw: null,\n  frames: new Queue(),\n  timeouts: new Queue(),\n  immediates: new Queue(),\n  timer: () => globals.window.performance || globals.window.Date,\n  transforms: [],\n  frame(fn) {\n    // Store the node\n    const node = Animator.frames.push({\n      run: fn\n    });\n\n    // Request an animation frame if we don't have one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n    }\n\n    // Return the node so we can remove it easily\n    return node;\n  },\n  timeout(fn, delay) {\n    delay = delay || 0;\n\n    // Work out when the event should fire\n    const time = Animator.timer().now() + delay;\n\n    // Add the timeout to the end of the queue\n    const node = Animator.timeouts.push({\n      run: fn,\n      time: time\n    });\n\n    // Request another animation frame if we need one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n    }\n    return node;\n  },\n  immediate(fn) {\n    // Add the immediate fn to the end of the queue\n    const node = Animator.immediates.push(fn);\n    // Request another animation frame if we need one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n    }\n    return node;\n  },\n  cancelFrame(node) {\n    node != null && Animator.frames.remove(node);\n  },\n  clearTimeout(node) {\n    node != null && Animator.timeouts.remove(node);\n  },\n  cancelImmediate(node) {\n    node != null && Animator.immediates.remove(node);\n  },\n  _draw(now) {\n    // Run all the timeouts we can run, if they are not ready yet, add them\n    // to the end of the queue immediately! (bad timeouts!!! [sarcasm])\n    let nextTimeout = null;\n    const lastTimeout = Animator.timeouts.last();\n    while (nextTimeout = Animator.timeouts.shift()) {\n      // Run the timeout if its time, or push it to the end\n      if (now >= nextTimeout.time) {\n        nextTimeout.run();\n      } else {\n        Animator.timeouts.push(nextTimeout);\n      }\n\n      // If we hit the last item, we should stop shifting out more items\n      if (nextTimeout === lastTimeout) break;\n    }\n\n    // Run all of the animation frames\n    let nextFrame = null;\n    const lastFrame = Animator.frames.last();\n    while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {\n      nextFrame.run(now);\n    }\n    let nextImmediate = null;\n    while (nextImmediate = Animator.immediates.shift()) {\n      nextImmediate();\n    }\n\n    // If we have remaining timeouts or frames, draw until we don't anymore\n    Animator.nextDraw = Animator.timeouts.first() || Animator.frames.first() ? globals.window.requestAnimationFrame(Animator._draw) : null;\n  }\n};\n\nconst makeSchedule = function (runnerInfo) {\n  const start = runnerInfo.start;\n  const duration = runnerInfo.runner.duration();\n  const end = start + duration;\n  return {\n    start: start,\n    duration: duration,\n    end: end,\n    runner: runnerInfo.runner\n  };\n};\nconst defaultSource = function () {\n  const w = globals.window;\n  return (w.performance || w.Date).now();\n};\nclass Timeline extends EventTarget {\n  // Construct a new timeline on the given element\n  constructor(timeSource = defaultSource) {\n    super();\n    this._timeSource = timeSource;\n\n    // terminate resets all variables to their initial state\n    this.terminate();\n  }\n  active() {\n    return !!this._nextFrame;\n  }\n  finish() {\n    // Go to end and pause\n    this.time(this.getEndTimeOfTimeline() + 1);\n    return this.pause();\n  }\n\n  // Calculates the end of the timeline\n  getEndTime() {\n    const lastRunnerInfo = this.getLastRunnerInfo();\n    const lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;\n    const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;\n    return lastStartTime + lastDuration;\n  }\n  getEndTimeOfTimeline() {\n    const endTimes = this._runners.map(i => i.start + i.runner.duration());\n    return Math.max(0, ...endTimes);\n  }\n  getLastRunnerInfo() {\n    return this.getRunnerInfoById(this._lastRunnerId);\n  }\n  getRunnerInfoById(id) {\n    return this._runners[this._runnerIds.indexOf(id)] || null;\n  }\n  pause() {\n    this._paused = true;\n    return this._continue();\n  }\n  persist(dtOrForever) {\n    if (dtOrForever == null) return this._persist;\n    this._persist = dtOrForever;\n    return this;\n  }\n  play() {\n    // Now make sure we are not paused and continue the animation\n    this._paused = false;\n    return this.updateTime()._continue();\n  }\n  reverse(yes) {\n    const currentSpeed = this.speed();\n    if (yes == null) return this.speed(-currentSpeed);\n    const positive = Math.abs(currentSpeed);\n    return this.speed(yes ? -positive : positive);\n  }\n\n  // schedules a runner on the timeline\n  schedule(runner, delay, when) {\n    if (runner == null) {\n      return this._runners.map(makeSchedule);\n    }\n\n    // The start time for the next animation can either be given explicitly,\n    // derived from the current timeline time or it can be relative to the\n    // last start time to chain animations directly\n\n    let absoluteStartTime = 0;\n    const endTime = this.getEndTime();\n    delay = delay || 0;\n\n    // Work out when to start the animation\n    if (when == null || when === 'last' || when === 'after') {\n      // Take the last time and increment\n      absoluteStartTime = endTime;\n    } else if (when === 'absolute' || when === 'start') {\n      absoluteStartTime = delay;\n      delay = 0;\n    } else if (when === 'now') {\n      absoluteStartTime = this._time;\n    } else if (when === 'relative') {\n      const runnerInfo = this.getRunnerInfoById(runner.id);\n      if (runnerInfo) {\n        absoluteStartTime = runnerInfo.start + delay;\n        delay = 0;\n      }\n    } else if (when === 'with-last') {\n      const lastRunnerInfo = this.getLastRunnerInfo();\n      const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;\n      absoluteStartTime = lastStartTime;\n    } else {\n      throw new Error('Invalid value for the \"when\" parameter');\n    }\n\n    // Manage runner\n    runner.unschedule();\n    runner.timeline(this);\n    const persist = runner.persist();\n    const runnerInfo = {\n      persist: persist === null ? this._persist : persist,\n      start: absoluteStartTime + delay,\n      runner\n    };\n    this._lastRunnerId = runner.id;\n    this._runners.push(runnerInfo);\n    this._runners.sort((a, b) => a.start - b.start);\n    this._runnerIds = this._runners.map(info => info.runner.id);\n    this.updateTime()._continue();\n    return this;\n  }\n  seek(dt) {\n    return this.time(this._time + dt);\n  }\n  source(fn) {\n    if (fn == null) return this._timeSource;\n    this._timeSource = fn;\n    return this;\n  }\n  speed(speed) {\n    if (speed == null) return this._speed;\n    this._speed = speed;\n    return this;\n  }\n  stop() {\n    // Go to start and pause\n    this.time(0);\n    return this.pause();\n  }\n  time(time) {\n    if (time == null) return this._time;\n    this._time = time;\n    return this._continue(true);\n  }\n\n  // Remove the runner from this timeline\n  unschedule(runner) {\n    const index = this._runnerIds.indexOf(runner.id);\n    if (index < 0) return this;\n    this._runners.splice(index, 1);\n    this._runnerIds.splice(index, 1);\n    runner.timeline(null);\n    return this;\n  }\n\n  // Makes sure, that after pausing the time doesn't jump\n  updateTime() {\n    if (!this.active()) {\n      this._lastSourceTime = this._timeSource();\n    }\n    return this;\n  }\n\n  // Checks if we are running and continues the animation\n  _continue(immediateStep = false) {\n    Animator.cancelFrame(this._nextFrame);\n    this._nextFrame = null;\n    if (immediateStep) return this._stepImmediate();\n    if (this._paused) return this;\n    this._nextFrame = Animator.frame(this._step);\n    return this;\n  }\n  _stepFn(immediateStep = false) {\n    // Get the time delta from the last time and update the time\n    const time = this._timeSource();\n    let dtSource = time - this._lastSourceTime;\n    if (immediateStep) dtSource = 0;\n    const dtTime = this._speed * dtSource + (this._time - this._lastStepTime);\n    this._lastSourceTime = time;\n\n    // Only update the time if we use the timeSource.\n    // Otherwise use the current time\n    if (!immediateStep) {\n      // Update the time\n      this._time += dtTime;\n      this._time = this._time < 0 ? 0 : this._time;\n    }\n    this._lastStepTime = this._time;\n    this.fire('time', this._time);\n\n    // This is for the case that the timeline was seeked so that the time\n    // is now before the startTime of the runner. That is why we need to set\n    // the runner to position 0\n\n    // FIXME:\n    // However, resetting in insertion order leads to bugs. Considering the case,\n    // where 2 runners change the same attribute but in different times,\n    // resetting both of them will lead to the case where the later defined\n    // runner always wins the reset even if the other runner started earlier\n    // and therefore should win the attribute battle\n    // this can be solved by resetting them backwards\n    for (let k = this._runners.length; k--;) {\n      // Get and run the current runner and ignore it if its inactive\n      const runnerInfo = this._runners[k];\n      const runner = runnerInfo.runner;\n\n      // Make sure that we give the actual difference\n      // between runner start time and now\n      const dtToStart = this._time - runnerInfo.start;\n\n      // Dont run runner if not started yet\n      // and try to reset it\n      if (dtToStart <= 0) {\n        runner.reset();\n      }\n    }\n\n    // Run all of the runners directly\n    let runnersLeft = false;\n    for (let i = 0, len = this._runners.length; i < len; i++) {\n      // Get and run the current runner and ignore it if its inactive\n      const runnerInfo = this._runners[i];\n      const runner = runnerInfo.runner;\n      let dt = dtTime;\n\n      // Make sure that we give the actual difference\n      // between runner start time and now\n      const dtToStart = this._time - runnerInfo.start;\n\n      // Dont run runner if not started yet\n      if (dtToStart <= 0) {\n        runnersLeft = true;\n        continue;\n      } else if (dtToStart < dt) {\n        // Adjust dt to make sure that animation is on point\n        dt = dtToStart;\n      }\n      if (!runner.active()) continue;\n\n      // If this runner is still going, signal that we need another animation\n      // frame, otherwise, remove the completed runner\n      const finished = runner.step(dt).done;\n      if (!finished) {\n        runnersLeft = true;\n        // continue\n      } else if (runnerInfo.persist !== true) {\n        // runner is finished. And runner might get removed\n        const endTime = runner.duration() - runner.time() + this._time;\n        if (endTime + runnerInfo.persist < this._time) {\n          // Delete runner and correct index\n          runner.unschedule();\n          --i;\n          --len;\n        }\n      }\n    }\n\n    // Basically: we continue when there are runners right from us in time\n    // when -->, and when runners are left from us when <--\n    if (runnersLeft && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0) {\n      this._continue();\n    } else {\n      this.pause();\n      this.fire('finished');\n    }\n    return this;\n  }\n  terminate() {\n    // cleanup memory\n\n    // Store the timing variables\n    this._startTime = 0;\n    this._speed = 1.0;\n\n    // Determines how long a runner is hold in memory. Can be a dt or true/false\n    this._persist = 0;\n\n    // Keep track of the running animations and their starting parameters\n    this._nextFrame = null;\n    this._paused = true;\n    this._runners = [];\n    this._runnerIds = [];\n    this._lastRunnerId = -1;\n    this._time = 0;\n    this._lastSourceTime = 0;\n    this._lastStepTime = 0;\n\n    // Make sure that step is always called in class context\n    this._step = this._stepFn.bind(this, false);\n    this._stepImmediate = this._stepFn.bind(this, true);\n  }\n}\nregisterMethods({\n  Element: {\n    timeline: function (timeline) {\n      if (timeline == null) {\n        this._timeline = this._timeline || new Timeline();\n        return this._timeline;\n      } else {\n        this._timeline = timeline;\n        return this;\n      }\n    }\n  }\n});\n\nclass Runner extends EventTarget {\n  constructor(options) {\n    super();\n\n    // Store a unique id on the runner, so that we can identify it later\n    this.id = Runner.id++;\n\n    // Ensure a default value\n    options = options == null ? timeline.duration : options;\n\n    // Ensure that we get a controller\n    options = typeof options === 'function' ? new Controller(options) : options;\n\n    // Declare all of the variables\n    this._element = null;\n    this._timeline = null;\n    this.done = false;\n    this._queue = [];\n\n    // Work out the stepper and the duration\n    this._duration = typeof options === 'number' && options;\n    this._isDeclarative = options instanceof Controller;\n    this._stepper = this._isDeclarative ? options : new Ease();\n\n    // We copy the current values from the timeline because they can change\n    this._history = {};\n\n    // Store the state of the runner\n    this.enabled = true;\n    this._time = 0;\n    this._lastTime = 0;\n\n    // At creation, the runner is in reset state\n    this._reseted = true;\n\n    // Save transforms applied to this runner\n    this.transforms = new Matrix();\n    this.transformId = 1;\n\n    // Looping variables\n    this._haveReversed = false;\n    this._reverse = false;\n    this._loopsDone = 0;\n    this._swing = false;\n    this._wait = 0;\n    this._times = 1;\n    this._frameId = null;\n\n    // Stores how long a runner is stored after being done\n    this._persist = this._isDeclarative ? true : null;\n  }\n  static sanitise(duration, delay, when) {\n    // Initialise the default parameters\n    let times = 1;\n    let swing = false;\n    let wait = 0;\n    duration = duration ?? timeline.duration;\n    delay = delay ?? timeline.delay;\n    when = when || 'last';\n\n    // If we have an object, unpack the values\n    if (typeof duration === 'object' && !(duration instanceof Stepper)) {\n      delay = duration.delay ?? delay;\n      when = duration.when ?? when;\n      swing = duration.swing || swing;\n      times = duration.times ?? times;\n      wait = duration.wait ?? wait;\n      duration = duration.duration ?? timeline.duration;\n    }\n    return {\n      duration: duration,\n      delay: delay,\n      swing: swing,\n      times: times,\n      wait: wait,\n      when: when\n    };\n  }\n  active(enabled) {\n    if (enabled == null) return this.enabled;\n    this.enabled = enabled;\n    return this;\n  }\n\n  /*\n  Private Methods\n  ===============\n  Methods that shouldn't be used externally\n  */\n  addTransform(transform) {\n    this.transforms.lmultiplyO(transform);\n    return this;\n  }\n  after(fn) {\n    return this.on('finished', fn);\n  }\n  animate(duration, delay, when) {\n    const o = Runner.sanitise(duration, delay, when);\n    const runner = new Runner(o.duration);\n    if (this._timeline) runner.timeline(this._timeline);\n    if (this._element) runner.element(this._element);\n    return runner.loop(o).schedule(o.delay, o.when);\n  }\n  clearTransform() {\n    this.transforms = new Matrix();\n    return this;\n  }\n\n  // TODO: Keep track of all transformations so that deletion is faster\n  clearTransformsFromQueue() {\n    if (!this.done || !this._timeline || !this._timeline._runnerIds.includes(this.id)) {\n      this._queue = this._queue.filter(item => {\n        return !item.isTransform;\n      });\n    }\n  }\n  delay(delay) {\n    return this.animate(0, delay);\n  }\n  duration() {\n    return this._times * (this._wait + this._duration) - this._wait;\n  }\n  during(fn) {\n    return this.queue(null, fn);\n  }\n  ease(fn) {\n    this._stepper = new Ease(fn);\n    return this;\n  }\n  /*\n  Runner Definitions\n  ==================\n  These methods help us define the runtime behaviour of the Runner or they\n  help us make new runners from the current runner\n  */\n\n  element(element) {\n    if (element == null) return this._element;\n    this._element = element;\n    element._prepareRunner();\n    return this;\n  }\n  finish() {\n    return this.step(Infinity);\n  }\n  loop(times, swing, wait) {\n    // Deal with the user passing in an object\n    if (typeof times === 'object') {\n      swing = times.swing;\n      wait = times.wait;\n      times = times.times;\n    }\n\n    // Sanitise the values and store them\n    this._times = times || Infinity;\n    this._swing = swing || false;\n    this._wait = wait || 0;\n\n    // Allow true to be passed\n    if (this._times === true) {\n      this._times = Infinity;\n    }\n    return this;\n  }\n  loops(p) {\n    const loopDuration = this._duration + this._wait;\n    if (p == null) {\n      const loopsDone = Math.floor(this._time / loopDuration);\n      const relativeTime = this._time - loopsDone * loopDuration;\n      const position = relativeTime / this._duration;\n      return Math.min(loopsDone + position, this._times);\n    }\n    const whole = Math.floor(p);\n    const partial = p % 1;\n    const time = loopDuration * whole + this._duration * partial;\n    return this.time(time);\n  }\n  persist(dtOrForever) {\n    if (dtOrForever == null) return this._persist;\n    this._persist = dtOrForever;\n    return this;\n  }\n  position(p) {\n    // Get all of the variables we need\n    const x = this._time;\n    const d = this._duration;\n    const w = this._wait;\n    const t = this._times;\n    const s = this._swing;\n    const r = this._reverse;\n    let position;\n    if (p == null) {\n      /*\n      This function converts a time to a position in the range [0, 1]\n      The full explanation can be found in this desmos demonstration\n        https://www.desmos.com/calculator/u4fbavgche\n      The logic is slightly simplified here because we can use booleans\n      */\n\n      // Figure out the value without thinking about the start or end time\n      const f = function (x) {\n        const swinging = s * Math.floor(x % (2 * (w + d)) / (w + d));\n        const backwards = swinging && !r || !swinging && r;\n        const uncliped = Math.pow(-1, backwards) * (x % (w + d)) / d + backwards;\n        const clipped = Math.max(Math.min(uncliped, 1), 0);\n        return clipped;\n      };\n\n      // Figure out the value by incorporating the start time\n      const endTime = t * (w + d) - w;\n      position = x <= 0 ? Math.round(f(1e-5)) : x < endTime ? f(x) : Math.round(f(endTime - 1e-5));\n      return position;\n    }\n\n    // Work out the loops done and add the position to the loops done\n    const loopsDone = Math.floor(this.loops());\n    const swingForward = s && loopsDone % 2 === 0;\n    const forwards = swingForward && !r || r && swingForward;\n    position = loopsDone + (forwards ? p : 1 - p);\n    return this.loops(position);\n  }\n  progress(p) {\n    if (p == null) {\n      return Math.min(1, this._time / this.duration());\n    }\n    return this.time(p * this.duration());\n  }\n\n  /*\n  Basic Functionality\n  ===================\n  These methods allow us to attach basic functions to the runner directly\n  */\n  queue(initFn, runFn, retargetFn, isTransform) {\n    this._queue.push({\n      initialiser: initFn || noop,\n      runner: runFn || noop,\n      retarget: retargetFn,\n      isTransform: isTransform,\n      initialised: false,\n      finished: false\n    });\n    const timeline = this.timeline();\n    timeline && this.timeline()._continue();\n    return this;\n  }\n  reset() {\n    if (this._reseted) return this;\n    this.time(0);\n    this._reseted = true;\n    return this;\n  }\n  reverse(reverse) {\n    this._reverse = reverse == null ? !this._reverse : reverse;\n    return this;\n  }\n  schedule(timeline, delay, when) {\n    // The user doesn't need to pass a timeline if we already have one\n    if (!(timeline instanceof Timeline)) {\n      when = delay;\n      delay = timeline;\n      timeline = this.timeline();\n    }\n\n    // If there is no timeline, yell at the user...\n    if (!timeline) {\n      throw Error('Runner cannot be scheduled without timeline');\n    }\n\n    // Schedule the runner on the timeline provided\n    timeline.schedule(this, delay, when);\n    return this;\n  }\n  step(dt) {\n    // If we are inactive, this stepper just gets skipped\n    if (!this.enabled) return this;\n\n    // Update the time and get the new position\n    dt = dt == null ? 16 : dt;\n    this._time += dt;\n    const position = this.position();\n\n    // Figure out if we need to run the stepper in this frame\n    const running = this._lastPosition !== position && this._time >= 0;\n    this._lastPosition = position;\n\n    // Figure out if we just started\n    const duration = this.duration();\n    const justStarted = this._lastTime <= 0 && this._time > 0;\n    const justFinished = this._lastTime < duration && this._time >= duration;\n    this._lastTime = this._time;\n    if (justStarted) {\n      this.fire('start', this);\n    }\n\n    // Work out if the runner is finished set the done flag here so animations\n    // know, that they are running in the last step (this is good for\n    // transformations which can be merged)\n    const declarative = this._isDeclarative;\n    this.done = !declarative && !justFinished && this._time >= duration;\n\n    // Runner is running. So its not in reset state anymore\n    this._reseted = false;\n    let converged = false;\n    // Call initialise and the run function\n    if (running || declarative) {\n      this._initialise(running);\n\n      // clear the transforms on this runner so they dont get added again and again\n      this.transforms = new Matrix();\n      converged = this._run(declarative ? dt : position);\n      this.fire('step', this);\n    }\n    // correct the done flag here\n    // declarative animations itself know when they converged\n    this.done = this.done || converged && declarative;\n    if (justFinished) {\n      this.fire('finished', this);\n    }\n    return this;\n  }\n\n  /*\n  Runner animation methods\n  ========================\n  Control how the animation plays\n  */\n  time(time) {\n    if (time == null) {\n      return this._time;\n    }\n    const dt = time - this._time;\n    this.step(dt);\n    return this;\n  }\n  timeline(timeline) {\n    // check explicitly for undefined so we can set the timeline to null\n    if (typeof timeline === 'undefined') return this._timeline;\n    this._timeline = timeline;\n    return this;\n  }\n  unschedule() {\n    const timeline = this.timeline();\n    timeline && timeline.unschedule(this);\n    return this;\n  }\n\n  // Run each initialise function in the runner if required\n  _initialise(running) {\n    // If we aren't running, we shouldn't initialise when not declarative\n    if (!running && !this._isDeclarative) return;\n\n    // Loop through all of the initialisers\n    for (let i = 0, len = this._queue.length; i < len; ++i) {\n      // Get the current initialiser\n      const current = this._queue[i];\n\n      // Determine whether we need to initialise\n      const needsIt = this._isDeclarative || !current.initialised && running;\n      running = !current.finished;\n\n      // Call the initialiser if we need to\n      if (needsIt && running) {\n        current.initialiser.call(this);\n        current.initialised = true;\n      }\n    }\n  }\n\n  // Save a morpher to the morpher list so that we can retarget it later\n  _rememberMorpher(method, morpher) {\n    this._history[method] = {\n      morpher: morpher,\n      caller: this._queue[this._queue.length - 1]\n    };\n\n    // We have to resume the timeline in case a controller\n    // is already done without being ever run\n    // This can happen when e.g. this is done:\n    //    anim = el.animate(new SVG.Spring)\n    // and later\n    //    anim.move(...)\n    if (this._isDeclarative) {\n      const timeline = this.timeline();\n      timeline && timeline.play();\n    }\n  }\n\n  // Try to set the target for a morpher if the morpher exists, otherwise\n  // Run each run function for the position or dt given\n  _run(positionOrDt) {\n    // Run all of the _queue directly\n    let allfinished = true;\n    for (let i = 0, len = this._queue.length; i < len; ++i) {\n      // Get the current function to run\n      const current = this._queue[i];\n\n      // Run the function if its not finished, we keep track of the finished\n      // flag for the sake of declarative _queue\n      const converged = current.runner.call(this, positionOrDt);\n      current.finished = current.finished || converged === true;\n      allfinished = allfinished && current.finished;\n    }\n\n    // We report when all of the constructors are finished\n    return allfinished;\n  }\n\n  // do nothing and return false\n  _tryRetarget(method, target, extra) {\n    if (this._history[method]) {\n      // if the last method wasn't even initialised, throw it away\n      if (!this._history[method].caller.initialised) {\n        const index = this._queue.indexOf(this._history[method].caller);\n        this._queue.splice(index, 1);\n        return false;\n      }\n\n      // for the case of transformations, we use the special retarget function\n      // which has access to the outer scope\n      if (this._history[method].caller.retarget) {\n        this._history[method].caller.retarget.call(this, target, extra);\n        // for everything else a simple morpher change is sufficient\n      } else {\n        this._history[method].morpher.to(target);\n      }\n      this._history[method].caller.finished = false;\n      const timeline = this.timeline();\n      timeline && timeline.play();\n      return true;\n    }\n    return false;\n  }\n}\nRunner.id = 0;\nclass FakeRunner {\n  constructor(transforms = new Matrix(), id = -1, done = true) {\n    this.transforms = transforms;\n    this.id = id;\n    this.done = done;\n  }\n  clearTransformsFromQueue() {}\n}\nextend([Runner, FakeRunner], {\n  mergeWith(runner) {\n    return new FakeRunner(runner.transforms.lmultiply(this.transforms), runner.id);\n  }\n});\n\n// FakeRunner.emptyRunner = new FakeRunner()\n\nconst lmultiply = (last, curr) => last.lmultiplyO(curr);\nconst getRunnerTransform = runner => runner.transforms;\nfunction mergeTransforms() {\n  // Find the matrix to apply to the element and apply it\n  const runners = this._transformationRunners.runners;\n  const netTransform = runners.map(getRunnerTransform).reduce(lmultiply, new Matrix());\n  this.transform(netTransform);\n  this._transformationRunners.merge();\n  if (this._transformationRunners.length() === 1) {\n    this._frameId = null;\n  }\n}\nclass RunnerArray {\n  constructor() {\n    this.runners = [];\n    this.ids = [];\n  }\n  add(runner) {\n    if (this.runners.includes(runner)) return;\n    const id = runner.id + 1;\n    this.runners.push(runner);\n    this.ids.push(id);\n    return this;\n  }\n  clearBefore(id) {\n    const deleteCnt = this.ids.indexOf(id + 1) || 1;\n    this.ids.splice(0, deleteCnt, 0);\n    this.runners.splice(0, deleteCnt, new FakeRunner()).forEach(r => r.clearTransformsFromQueue());\n    return this;\n  }\n  edit(id, newRunner) {\n    const index = this.ids.indexOf(id + 1);\n    this.ids.splice(index, 1, id + 1);\n    this.runners.splice(index, 1, newRunner);\n    return this;\n  }\n  getByID(id) {\n    return this.runners[this.ids.indexOf(id + 1)];\n  }\n  length() {\n    return this.ids.length;\n  }\n  merge() {\n    let lastRunner = null;\n    for (let i = 0; i < this.runners.length; ++i) {\n      const runner = this.runners[i];\n      const condition = lastRunner && runner.done && lastRunner.done && (\n      // don't merge runner when persisted on timeline\n      !runner._timeline || !runner._timeline._runnerIds.includes(runner.id)) && (!lastRunner._timeline || !lastRunner._timeline._runnerIds.includes(lastRunner.id));\n      if (condition) {\n        // the +1 happens in the function\n        this.remove(runner.id);\n        const newRunner = runner.mergeWith(lastRunner);\n        this.edit(lastRunner.id, newRunner);\n        lastRunner = newRunner;\n        --i;\n      } else {\n        lastRunner = runner;\n      }\n    }\n    return this;\n  }\n  remove(id) {\n    const index = this.ids.indexOf(id + 1);\n    this.ids.splice(index, 1);\n    this.runners.splice(index, 1);\n    return this;\n  }\n}\nregisterMethods({\n  Element: {\n    animate(duration, delay, when) {\n      const o = Runner.sanitise(duration, delay, when);\n      const timeline = this.timeline();\n      return new Runner(o.duration).loop(o).element(this).timeline(timeline.play()).schedule(o.delay, o.when);\n    },\n    delay(by, when) {\n      return this.animate(0, by, when);\n    },\n    // this function searches for all runners on the element and deletes the ones\n    // which run before the current one. This is because absolute transformations\n    // overwrite anything anyway so there is no need to waste time computing\n    // other runners\n    _clearTransformRunnersBefore(currentRunner) {\n      this._transformationRunners.clearBefore(currentRunner.id);\n    },\n    _currentTransform(current) {\n      return this._transformationRunners.runners\n      // we need the equal sign here to make sure, that also transformations\n      // on the same runner which execute before the current transformation are\n      // taken into account\n      .filter(runner => runner.id <= current.id).map(getRunnerTransform).reduce(lmultiply, new Matrix());\n    },\n    _addRunner(runner) {\n      this._transformationRunners.add(runner);\n\n      // Make sure that the runner merge is executed at the very end of\n      // all Animator functions. That is why we use immediate here to execute\n      // the merge right after all frames are run\n      Animator.cancelImmediate(this._frameId);\n      this._frameId = Animator.immediate(mergeTransforms.bind(this));\n    },\n    _prepareRunner() {\n      if (this._frameId == null) {\n        this._transformationRunners = new RunnerArray().add(new FakeRunner(new Matrix(this)));\n      }\n    }\n  }\n});\n\n// Will output the elements from array A that are not in the array B\nconst difference = (a, b) => a.filter(x => !b.includes(x));\nextend(Runner, {\n  attr(a, v) {\n    return this.styleAttr('attr', a, v);\n  },\n  // Add animatable styles\n  css(s, v) {\n    return this.styleAttr('css', s, v);\n  },\n  styleAttr(type, nameOrAttrs, val) {\n    if (typeof nameOrAttrs === 'string') {\n      return this.styleAttr(type, {\n        [nameOrAttrs]: val\n      });\n    }\n    let attrs = nameOrAttrs;\n    if (this._tryRetarget(type, attrs)) return this;\n    let morpher = new Morphable(this._stepper).to(attrs);\n    let keys = Object.keys(attrs);\n    this.queue(function () {\n      morpher = morpher.from(this.element()[type](keys));\n    }, function (pos) {\n      this.element()[type](morpher.at(pos).valueOf());\n      return morpher.done();\n    }, function (newToAttrs) {\n      // Check if any new keys were added\n      const newKeys = Object.keys(newToAttrs);\n      const differences = difference(newKeys, keys);\n\n      // If their are new keys, initialize them and add them to morpher\n      if (differences.length) {\n        // Get the values\n        const addedFromAttrs = this.element()[type](differences);\n\n        // Get the already initialized values\n        const oldFromAttrs = new ObjectBag(morpher.from()).valueOf();\n\n        // Merge old and new\n        Object.assign(oldFromAttrs, addedFromAttrs);\n        morpher.from(oldFromAttrs);\n      }\n\n      // Get the object from the morpher\n      const oldToAttrs = new ObjectBag(morpher.to()).valueOf();\n\n      // Merge in new attributes\n      Object.assign(oldToAttrs, newToAttrs);\n\n      // Change morpher target\n      morpher.to(oldToAttrs);\n\n      // Make sure that we save the work we did so we don't need it to do again\n      keys = newKeys;\n      attrs = newToAttrs;\n    });\n    this._rememberMorpher(type, morpher);\n    return this;\n  },\n  zoom(level, point) {\n    if (this._tryRetarget('zoom', level, point)) return this;\n    let morpher = new Morphable(this._stepper).to(new SVGNumber(level));\n    this.queue(function () {\n      morpher = morpher.from(this.element().zoom());\n    }, function (pos) {\n      this.element().zoom(morpher.at(pos), point);\n      return morpher.done();\n    }, function (newLevel, newPoint) {\n      point = newPoint;\n      morpher.to(newLevel);\n    });\n    this._rememberMorpher('zoom', morpher);\n    return this;\n  },\n  /**\n   ** absolute transformations\n   **/\n\n  //\n  // M v -----|-----(D M v = F v)------|----->  T v\n  //\n  // 1. define the final state (T) and decompose it (once)\n  //    t = [tx, ty, the, lam, sy, sx]\n  // 2. on every frame: pull the current state of all previous transforms\n  //    (M - m can change)\n  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]\n  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)\n  //   - Note F(0) = M\n  //   - Note F(1) = T\n  // 4. Now you get the delta matrix as a result: D = F * inv(M)\n\n  transform(transforms, relative, affine) {\n    // If we have a declarative function, we should retarget it if possible\n    relative = transforms.relative || relative;\n    if (this._isDeclarative && !relative && this._tryRetarget('transform', transforms)) {\n      return this;\n    }\n\n    // Parse the parameters\n    const isMatrix = Matrix.isMatrixLike(transforms);\n    affine = transforms.affine != null ? transforms.affine : affine != null ? affine : !isMatrix;\n\n    // Create a morpher and set its type\n    const morpher = new Morphable(this._stepper).type(affine ? TransformBag : Matrix);\n    let origin;\n    let element;\n    let current;\n    let currentAngle;\n    let startTransform;\n    function setup() {\n      // make sure element and origin is defined\n      element = element || this.element();\n      origin = origin || getOrigin(transforms, element);\n      startTransform = new Matrix(relative ? undefined : element);\n\n      // add the runner to the element so it can merge transformations\n      element._addRunner(this);\n\n      // Deactivate all transforms that have run so far if we are absolute\n      if (!relative) {\n        element._clearTransformRunnersBefore(this);\n      }\n    }\n    function run(pos) {\n      // clear all other transforms before this in case something is saved\n      // on this runner. We are absolute. We dont need these!\n      if (!relative) this.clearTransform();\n      const {\n        x,\n        y\n      } = new Point(origin).transform(element._currentTransform(this));\n      let target = new Matrix({\n        ...transforms,\n        origin: [x, y]\n      });\n      let start = this._isDeclarative && current ? current : startTransform;\n      if (affine) {\n        target = target.decompose(x, y);\n        start = start.decompose(x, y);\n\n        // Get the current and target angle as it was set\n        const rTarget = target.rotate;\n        const rCurrent = start.rotate;\n\n        // Figure out the shortest path to rotate directly\n        const possibilities = [rTarget - 360, rTarget, rTarget + 360];\n        const distances = possibilities.map(a => Math.abs(a - rCurrent));\n        const shortest = Math.min(...distances);\n        const index = distances.indexOf(shortest);\n        target.rotate = possibilities[index];\n      }\n      if (relative) {\n        // we have to be careful here not to overwrite the rotation\n        // with the rotate method of Matrix\n        if (!isMatrix) {\n          target.rotate = transforms.rotate || 0;\n        }\n        if (this._isDeclarative && currentAngle) {\n          start.rotate = currentAngle;\n        }\n      }\n      morpher.from(start);\n      morpher.to(target);\n      const affineParameters = morpher.at(pos);\n      currentAngle = affineParameters.rotate;\n      current = new Matrix(affineParameters);\n      this.addTransform(current);\n      element._addRunner(this);\n      return morpher.done();\n    }\n    function retarget(newTransforms) {\n      // only get a new origin if it changed since the last call\n      if ((newTransforms.origin || 'center').toString() !== (transforms.origin || 'center').toString()) {\n        origin = getOrigin(newTransforms, element);\n      }\n\n      // overwrite the old transformations with the new ones\n      transforms = {\n        ...newTransforms,\n        origin\n      };\n    }\n    this.queue(setup, run, retarget, true);\n    this._isDeclarative && this._rememberMorpher('transform', morpher);\n    return this;\n  },\n  // Animatable x-axis\n  x(x) {\n    return this._queueNumber('x', x);\n  },\n  // Animatable y-axis\n  y(y) {\n    return this._queueNumber('y', y);\n  },\n  ax(x) {\n    return this._queueNumber('ax', x);\n  },\n  ay(y) {\n    return this._queueNumber('ay', y);\n  },\n  dx(x = 0) {\n    return this._queueNumberDelta('x', x);\n  },\n  dy(y = 0) {\n    return this._queueNumberDelta('y', y);\n  },\n  dmove(x, y) {\n    return this.dx(x).dy(y);\n  },\n  _queueNumberDelta(method, to) {\n    to = new SVGNumber(to);\n\n    // Try to change the target if we have this method already registered\n    if (this._tryRetarget(method, to)) return this;\n\n    // Make a morpher and queue the animation\n    const morpher = new Morphable(this._stepper).to(to);\n    let from = null;\n    this.queue(function () {\n      from = this.element()[method]();\n      morpher.from(from);\n      morpher.to(from + to);\n    }, function (pos) {\n      this.element()[method](morpher.at(pos));\n      return morpher.done();\n    }, function (newTo) {\n      morpher.to(from + new SVGNumber(newTo));\n    });\n\n    // Register the morpher so that if it is changed again, we can retarget it\n    this._rememberMorpher(method, morpher);\n    return this;\n  },\n  _queueObject(method, to) {\n    // Try to change the target if we have this method already registered\n    if (this._tryRetarget(method, to)) return this;\n\n    // Make a morpher and queue the animation\n    const morpher = new Morphable(this._stepper).to(to);\n    this.queue(function () {\n      morpher.from(this.element()[method]());\n    }, function (pos) {\n      this.element()[method](morpher.at(pos));\n      return morpher.done();\n    });\n\n    // Register the morpher so that if it is changed again, we can retarget it\n    this._rememberMorpher(method, morpher);\n    return this;\n  },\n  _queueNumber(method, value) {\n    return this._queueObject(method, new SVGNumber(value));\n  },\n  // Animatable center x-axis\n  cx(x) {\n    return this._queueNumber('cx', x);\n  },\n  // Animatable center y-axis\n  cy(y) {\n    return this._queueNumber('cy', y);\n  },\n  // Add animatable move\n  move(x, y) {\n    return this.x(x).y(y);\n  },\n  amove(x, y) {\n    return this.ax(x).ay(y);\n  },\n  // Add animatable center\n  center(x, y) {\n    return this.cx(x).cy(y);\n  },\n  // Add animatable size\n  size(width, height) {\n    // animate bbox based size for all other elements\n    let box;\n    if (!width || !height) {\n      box = this._element.bbox();\n    }\n    if (!width) {\n      width = box.width / box.height * height;\n    }\n    if (!height) {\n      height = box.height / box.width * width;\n    }\n    return this.width(width).height(height);\n  },\n  // Add animatable width\n  width(width) {\n    return this._queueNumber('width', width);\n  },\n  // Add animatable height\n  height(height) {\n    return this._queueNumber('height', height);\n  },\n  // Add animatable plot\n  plot(a, b, c, d) {\n    // Lines can be plotted with 4 arguments\n    if (arguments.length === 4) {\n      return this.plot([a, b, c, d]);\n    }\n    if (this._tryRetarget('plot', a)) return this;\n    const morpher = new Morphable(this._stepper).type(this._element.MorphArray).to(a);\n    this.queue(function () {\n      morpher.from(this._element.array());\n    }, function (pos) {\n      this._element.plot(morpher.at(pos));\n      return morpher.done();\n    });\n    this._rememberMorpher('plot', morpher);\n    return this;\n  },\n  // Add leading method\n  leading(value) {\n    return this._queueNumber('leading', value);\n  },\n  // Add animatable viewbox\n  viewbox(x, y, width, height) {\n    return this._queueObject('viewbox', new Box(x, y, width, height));\n  },\n  update(o) {\n    if (typeof o !== 'object') {\n      return this.update({\n        offset: arguments[0],\n        color: arguments[1],\n        opacity: arguments[2]\n      });\n    }\n    if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n    if (o.color != null) this.attr('stop-color', o.color);\n    if (o.offset != null) this.attr('offset', o.offset);\n    return this;\n  }\n});\nextend(Runner, {\n  rx,\n  ry,\n  from,\n  to\n});\nregister(Runner, 'Runner');\n\nclass Svg extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('svg', node), attrs);\n    this.namespace();\n  }\n\n  // Creates and returns defs element\n  defs() {\n    if (!this.isRoot()) return this.root().defs();\n    return adopt(this.node.querySelector('defs')) || this.put(new Defs());\n  }\n  isRoot() {\n    return !this.node.parentNode || !(this.node.parentNode instanceof globals.window.SVGElement) && this.node.parentNode.nodeName !== '#document-fragment';\n  }\n\n  // Add namespaces\n  namespace() {\n    if (!this.isRoot()) return this.root().namespace();\n    return this.attr({\n      xmlns: svg,\n      version: '1.1'\n    }).attr('xmlns:xlink', xlink, xmlns);\n  }\n  removeNamespace() {\n    return this.attr({\n      xmlns: null,\n      version: null\n    }).attr('xmlns:xlink', null, xmlns).attr('xmlns:svgjs', null, xmlns);\n  }\n\n  // Check if this is a root svg\n  // If not, call root() from this element\n  root() {\n    if (this.isRoot()) return this;\n    return super.root();\n  }\n}\nregisterMethods({\n  Container: {\n    // Create nested svg document\n    nested: wrapWithAttrCheck(function () {\n      return this.put(new Svg());\n    })\n  }\n});\nregister(Svg, 'Svg', true);\n\nclass Symbol extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('symbol', node), attrs);\n  }\n}\nregisterMethods({\n  Container: {\n    symbol: wrapWithAttrCheck(function () {\n      return this.put(new Symbol());\n    })\n  }\n});\nregister(Symbol, 'Symbol');\n\n// Create plain text node\nfunction plain(text) {\n  // clear if build mode is disabled\n  if (this._build === false) {\n    this.clear();\n  }\n\n  // create text node\n  this.node.appendChild(globals.document.createTextNode(text));\n  return this;\n}\n\n// Get length of text element\nfunction length() {\n  return this.node.getComputedTextLength();\n}\n\n// Move over x-axis\n// Text is moved by its bounding box\n// text-anchor does NOT matter\nfunction x$1(x, box = this.bbox()) {\n  if (x == null) {\n    return box.x;\n  }\n  return this.attr('x', this.attr('x') + x - box.x);\n}\n\n// Move over y-axis\nfunction y$1(y, box = this.bbox()) {\n  if (y == null) {\n    return box.y;\n  }\n  return this.attr('y', this.attr('y') + y - box.y);\n}\nfunction move$1(x, y, box = this.bbox()) {\n  return this.x(x, box).y(y, box);\n}\n\n// Move center over x-axis\nfunction cx(x, box = this.bbox()) {\n  if (x == null) {\n    return box.cx;\n  }\n  return this.attr('x', this.attr('x') + x - box.cx);\n}\n\n// Move center over y-axis\nfunction cy(y, box = this.bbox()) {\n  if (y == null) {\n    return box.cy;\n  }\n  return this.attr('y', this.attr('y') + y - box.cy);\n}\nfunction center(x, y, box = this.bbox()) {\n  return this.cx(x, box).cy(y, box);\n}\nfunction ax(x) {\n  return this.attr('x', x);\n}\nfunction ay(y) {\n  return this.attr('y', y);\n}\nfunction amove(x, y) {\n  return this.ax(x).ay(y);\n}\n\n// Enable / disable build mode\nfunction build(build) {\n  this._build = !!build;\n  return this;\n}\n\nvar textable = {\n  __proto__: null,\n  amove: amove,\n  ax: ax,\n  ay: ay,\n  build: build,\n  center: center,\n  cx: cx,\n  cy: cy,\n  length: length,\n  move: move$1,\n  plain: plain,\n  x: x$1,\n  y: y$1\n};\n\nclass Text extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('text', node), attrs);\n    this.dom.leading = this.dom.leading ?? new SVGNumber(1.3); // store leading value for rebuilding\n    this._rebuild = true; // enable automatic updating of dy values\n    this._build = false; // disable build mode for adding multiple lines\n  }\n\n  // Set / get leading\n  leading(value) {\n    // act as getter\n    if (value == null) {\n      return this.dom.leading;\n    }\n\n    // act as setter\n    this.dom.leading = new SVGNumber(value);\n    return this.rebuild();\n  }\n\n  // Rebuild appearance type\n  rebuild(rebuild) {\n    // store new rebuild flag if given\n    if (typeof rebuild === 'boolean') {\n      this._rebuild = rebuild;\n    }\n\n    // define position of all lines\n    if (this._rebuild) {\n      const self = this;\n      let blankLineOffset = 0;\n      const leading = this.dom.leading;\n      this.each(function (i) {\n        if (isDescriptive(this.node)) return;\n        const fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');\n        const dy = leading * new SVGNumber(fontSize);\n        if (this.dom.newLined) {\n          this.attr('x', self.attr('x'));\n          if (this.text() === '\\n') {\n            blankLineOffset += dy;\n          } else {\n            this.attr('dy', i ? dy + blankLineOffset : 0);\n            blankLineOffset = 0;\n          }\n        }\n      });\n      this.fire('rebuild');\n    }\n    return this;\n  }\n\n  // overwrite method from parent to set data properly\n  setData(o) {\n    this.dom = o;\n    this.dom.leading = new SVGNumber(o.leading || 1.3);\n    return this;\n  }\n  writeDataToDom() {\n    writeDataToDom(this, this.dom, {\n      leading: 1.3\n    });\n    return this;\n  }\n\n  // Set the text content\n  text(text) {\n    // act as getter\n    if (text === undefined) {\n      const children = this.node.childNodes;\n      let firstLine = 0;\n      text = '';\n      for (let i = 0, len = children.length; i < len; ++i) {\n        // skip textPaths - they are no lines\n        if (children[i].nodeName === 'textPath' || isDescriptive(children[i])) {\n          if (i === 0) firstLine = i + 1;\n          continue;\n        }\n\n        // add newline if its not the first child and newLined is set to true\n        if (i !== firstLine && children[i].nodeType !== 3 && adopt(children[i]).dom.newLined === true) {\n          text += '\\n';\n        }\n\n        // add content of this node\n        text += children[i].textContent;\n      }\n      return text;\n    }\n\n    // remove existing content\n    this.clear().build(true);\n    if (typeof text === 'function') {\n      // call block\n      text.call(this, this);\n    } else {\n      // store text and make sure text is not blank\n      text = (text + '').split('\\n');\n\n      // build new lines\n      for (let j = 0, jl = text.length; j < jl; j++) {\n        this.newLine(text[j]);\n      }\n    }\n\n    // disable build mode and rebuild lines\n    return this.build(false).rebuild();\n  }\n}\nextend(Text, textable);\nregisterMethods({\n  Container: {\n    // Create text element\n    text: wrapWithAttrCheck(function (text = '') {\n      return this.put(new Text()).text(text);\n    }),\n    // Create plain text element\n    plain: wrapWithAttrCheck(function (text = '') {\n      return this.put(new Text()).plain(text);\n    })\n  }\n});\nregister(Text, 'Text');\n\nclass Tspan extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('tspan', node), attrs);\n    this._build = false; // disable build mode for adding multiple lines\n  }\n\n  // Shortcut dx\n  dx(dx) {\n    return this.attr('dx', dx);\n  }\n\n  // Shortcut dy\n  dy(dy) {\n    return this.attr('dy', dy);\n  }\n\n  // Create new line\n  newLine() {\n    // mark new line\n    this.dom.newLined = true;\n\n    // fetch parent\n    const text = this.parent();\n\n    // early return in case we are not in a text element\n    if (!(text instanceof Text)) {\n      return this;\n    }\n    const i = text.index(this);\n    const fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');\n    const dy = text.dom.leading * new SVGNumber(fontSize);\n\n    // apply new position\n    return this.dy(i ? dy : 0).attr('x', text.x());\n  }\n\n  // Set text content\n  text(text) {\n    if (text == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '');\n    if (typeof text === 'function') {\n      this.clear().build(true);\n      text.call(this, this);\n      this.build(false);\n    } else {\n      this.plain(text);\n    }\n    return this;\n  }\n}\nextend(Tspan, textable);\nregisterMethods({\n  Tspan: {\n    tspan: wrapWithAttrCheck(function (text = '') {\n      const tspan = new Tspan();\n\n      // clear if build mode is disabled\n      if (!this._build) {\n        this.clear();\n      }\n\n      // add new tspan\n      return this.put(tspan).text(text);\n    })\n  },\n  Text: {\n    newLine: function (text = '') {\n      return this.tspan(text).newLine();\n    }\n  }\n});\nregister(Tspan, 'Tspan');\n\nclass Circle extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('circle', node), attrs);\n  }\n  radius(r) {\n    return this.attr('r', r);\n  }\n\n  // Radius x value\n  rx(rx) {\n    return this.attr('r', rx);\n  }\n\n  // Alias radius x value\n  ry(ry) {\n    return this.rx(ry);\n  }\n  size(size) {\n    return this.radius(new SVGNumber(size).divide(2));\n  }\n}\nextend(Circle, {\n  x: x$3,\n  y: y$3,\n  cx: cx$1,\n  cy: cy$1,\n  width: width$2,\n  height: height$2\n});\nregisterMethods({\n  Container: {\n    // Create circle element\n    circle: wrapWithAttrCheck(function (size = 0) {\n      return this.put(new Circle()).size(size).move(0, 0);\n    })\n  }\n});\nregister(Circle, 'Circle');\n\nclass ClipPath extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('clipPath', node), attrs);\n  }\n\n  // Unclip all clipped elements and remove itself\n  remove() {\n    // unclip all targets\n    this.targets().forEach(function (el) {\n      el.unclip();\n    });\n\n    // remove clipPath from parent\n    return super.remove();\n  }\n  targets() {\n    return baseFind('svg [clip-path*=' + this.id() + ']');\n  }\n}\nregisterMethods({\n  Container: {\n    // Create clipping element\n    clip: wrapWithAttrCheck(function () {\n      return this.defs().put(new ClipPath());\n    })\n  },\n  Element: {\n    // Distribute clipPath to svg element\n    clipper() {\n      return this.reference('clip-path');\n    },\n    clipWith(element) {\n      // use given clip or create a new one\n      const clipper = element instanceof ClipPath ? element : this.parent().clip().add(element);\n\n      // apply mask\n      return this.attr('clip-path', 'url(#' + clipper.id() + ')');\n    },\n    // Unclip element\n    unclip() {\n      return this.attr('clip-path', null);\n    }\n  }\n});\nregister(ClipPath, 'ClipPath');\n\nclass ForeignObject extends Element {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('foreignObject', node), attrs);\n  }\n}\nregisterMethods({\n  Container: {\n    foreignObject: wrapWithAttrCheck(function (width, height) {\n      return this.put(new ForeignObject()).size(width, height);\n    })\n  }\n});\nregister(ForeignObject, 'ForeignObject');\n\nfunction dmove(dx, dy) {\n  this.children().forEach(child => {\n    let bbox;\n\n    // We have to wrap this for elements that dont have a bbox\n    // e.g. title and other descriptive elements\n    try {\n      // Get the childs bbox\n      // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1905039\n      // Because bbox for nested svgs returns the contents bbox in the coordinate space of the svg itself (weird!), we cant use bbox for svgs\n      // Therefore we have to use getBoundingClientRect. But THAT is broken (as explained in the bug).\n      // Funnily enough the broken behavior would work for us but that breaks it in chrome\n      // So we have to replicate the broken behavior of FF by just reading the attributes of the svg itself\n      bbox = child.node instanceof getWindow().SVGSVGElement ? new Box(child.attr(['x', 'y', 'width', 'height'])) : child.bbox();\n    } catch (e) {\n      return;\n    }\n\n    // Get childs matrix\n    const m = new Matrix(child);\n    // Translate childs matrix by amount and\n    // transform it back into parents space\n    const matrix = m.translate(dx, dy).transform(m.inverse());\n    // Calculate new x and y from old box\n    const p = new Point(bbox.x, bbox.y).transform(matrix);\n    // Move element\n    child.move(p.x, p.y);\n  });\n  return this;\n}\nfunction dx(dx) {\n  return this.dmove(dx, 0);\n}\nfunction dy(dy) {\n  return this.dmove(0, dy);\n}\nfunction height(height, box = this.bbox()) {\n  if (height == null) return box.height;\n  return this.size(box.width, height, box);\n}\nfunction move(x = 0, y = 0, box = this.bbox()) {\n  const dx = x - box.x;\n  const dy = y - box.y;\n  return this.dmove(dx, dy);\n}\nfunction size(width, height, box = this.bbox()) {\n  const p = proportionalSize(this, width, height, box);\n  const scaleX = p.width / box.width;\n  const scaleY = p.height / box.height;\n  this.children().forEach(child => {\n    const o = new Point(box).transform(new Matrix(child).inverse());\n    child.scale(scaleX, scaleY, o.x, o.y);\n  });\n  return this;\n}\nfunction width(width, box = this.bbox()) {\n  if (width == null) return box.width;\n  return this.size(width, box.height, box);\n}\nfunction x(x, box = this.bbox()) {\n  if (x == null) return box.x;\n  return this.move(x, box.y, box);\n}\nfunction y(y, box = this.bbox()) {\n  if (y == null) return box.y;\n  return this.move(box.x, y, box);\n}\n\nvar containerGeometry = {\n  __proto__: null,\n  dmove: dmove,\n  dx: dx,\n  dy: dy,\n  height: height,\n  move: move,\n  size: size,\n  width: width,\n  x: x,\n  y: y\n};\n\nclass G extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('g', node), attrs);\n  }\n}\nextend(G, containerGeometry);\nregisterMethods({\n  Container: {\n    // Create a group element\n    group: wrapWithAttrCheck(function () {\n      return this.put(new G());\n    })\n  }\n});\nregister(G, 'G');\n\nclass A extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('a', node), attrs);\n  }\n\n  // Link target attribute\n  target(target) {\n    return this.attr('target', target);\n  }\n\n  // Link url\n  to(url) {\n    return this.attr('href', url, xlink);\n  }\n}\nextend(A, containerGeometry);\nregisterMethods({\n  Container: {\n    // Create a hyperlink element\n    link: wrapWithAttrCheck(function (url) {\n      return this.put(new A()).to(url);\n    })\n  },\n  Element: {\n    unlink() {\n      const link = this.linker();\n      if (!link) return this;\n      const parent = link.parent();\n      if (!parent) {\n        return this.remove();\n      }\n      const index = parent.index(link);\n      parent.add(this, index);\n      link.remove();\n      return this;\n    },\n    linkTo(url) {\n      // reuse old link if possible\n      let link = this.linker();\n      if (!link) {\n        link = new A();\n        this.wrap(link);\n      }\n      if (typeof url === 'function') {\n        url.call(link, link);\n      } else {\n        link.to(url);\n      }\n      return this;\n    },\n    linker() {\n      const link = this.parent();\n      if (link && link.node.nodeName.toLowerCase() === 'a') {\n        return link;\n      }\n      return null;\n    }\n  }\n});\nregister(A, 'A');\n\nclass Mask extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('mask', node), attrs);\n  }\n\n  // Unmask all masked elements and remove itself\n  remove() {\n    // unmask all targets\n    this.targets().forEach(function (el) {\n      el.unmask();\n    });\n\n    // remove mask from parent\n    return super.remove();\n  }\n  targets() {\n    return baseFind('svg [mask*=' + this.id() + ']');\n  }\n}\nregisterMethods({\n  Container: {\n    mask: wrapWithAttrCheck(function () {\n      return this.defs().put(new Mask());\n    })\n  },\n  Element: {\n    // Distribute mask to svg element\n    masker() {\n      return this.reference('mask');\n    },\n    maskWith(element) {\n      // use given mask or create a new one\n      const masker = element instanceof Mask ? element : this.parent().mask().add(element);\n\n      // apply mask\n      return this.attr('mask', 'url(#' + masker.id() + ')');\n    },\n    // Unmask element\n    unmask() {\n      return this.attr('mask', null);\n    }\n  }\n});\nregister(Mask, 'Mask');\n\nclass Stop extends Element {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('stop', node), attrs);\n  }\n\n  // add color stops\n  update(o) {\n    if (typeof o === 'number' || o instanceof SVGNumber) {\n      o = {\n        offset: arguments[0],\n        color: arguments[1],\n        opacity: arguments[2]\n      };\n    }\n\n    // set attributes\n    if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n    if (o.color != null) this.attr('stop-color', o.color);\n    if (o.offset != null) this.attr('offset', new SVGNumber(o.offset));\n    return this;\n  }\n}\nregisterMethods({\n  Gradient: {\n    // Add a color stop\n    stop: function (offset, color, opacity) {\n      return this.put(new Stop()).update(offset, color, opacity);\n    }\n  }\n});\nregister(Stop, 'Stop');\n\nfunction cssRule(selector, rule) {\n  if (!selector) return '';\n  if (!rule) return selector;\n  let ret = selector + '{';\n  for (const i in rule) {\n    ret += unCamelCase(i) + ':' + rule[i] + ';';\n  }\n  ret += '}';\n  return ret;\n}\nclass Style extends Element {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('style', node), attrs);\n  }\n  addText(w = '') {\n    this.node.textContent += w;\n    return this;\n  }\n  font(name, src, params = {}) {\n    return this.rule('@font-face', {\n      fontFamily: name,\n      src: src,\n      ...params\n    });\n  }\n  rule(selector, obj) {\n    return this.addText(cssRule(selector, obj));\n  }\n}\nregisterMethods('Dom', {\n  style(selector, obj) {\n    return this.put(new Style()).rule(selector, obj);\n  },\n  fontface(name, src, params) {\n    return this.put(new Style()).font(name, src, params);\n  }\n});\nregister(Style, 'Style');\n\nclass TextPath extends Text {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('textPath', node), attrs);\n  }\n\n  // return the array of the path track element\n  array() {\n    const track = this.track();\n    return track ? track.array() : null;\n  }\n\n  // Plot path if any\n  plot(d) {\n    const track = this.track();\n    let pathArray = null;\n    if (track) {\n      pathArray = track.plot(d);\n    }\n    return d == null ? pathArray : this;\n  }\n\n  // Get the path element\n  track() {\n    return this.reference('href');\n  }\n}\nregisterMethods({\n  Container: {\n    textPath: wrapWithAttrCheck(function (text, path) {\n      // Convert text to instance if needed\n      if (!(text instanceof Text)) {\n        text = this.text(text);\n      }\n      return text.path(path);\n    })\n  },\n  Text: {\n    // Create path for text to run on\n    path: wrapWithAttrCheck(function (track, importNodes = true) {\n      const textPath = new TextPath();\n\n      // if track is a path, reuse it\n      if (!(track instanceof Path)) {\n        // create path element\n        track = this.defs().path(track);\n      }\n\n      // link textPath to path and add content\n      textPath.attr('href', '#' + track, xlink);\n\n      // Transplant all nodes from text to textPath\n      let node;\n      if (importNodes) {\n        while (node = this.node.firstChild) {\n          textPath.node.appendChild(node);\n        }\n      }\n\n      // add textPath element as child node and return textPath\n      return this.put(textPath);\n    }),\n    // Get the textPath children\n    textPath() {\n      return this.findOne('textPath');\n    }\n  },\n  Path: {\n    // creates a textPath from this path\n    text: wrapWithAttrCheck(function (text) {\n      // Convert text to instance if needed\n      if (!(text instanceof Text)) {\n        text = new Text().addTo(this.parent()).text(text);\n      }\n\n      // Create textPath from text and path and return\n      return text.path(this);\n    }),\n    targets() {\n      return baseFind('svg textPath').filter(node => {\n        return (node.attr('href') || '').includes(this.id());\n      });\n\n      // Does not work in IE11. Use when IE support is dropped\n      // return baseFind('svg textPath[*|href*=' + this.id() + ']')\n    }\n  }\n});\nTextPath.prototype.MorphArray = PathArray;\nregister(TextPath, 'TextPath');\n\nclass Use extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('use', node), attrs);\n  }\n\n  // Use element as a reference\n  use(element, file) {\n    // Set lined element\n    return this.attr('href', (file || '') + '#' + element, xlink);\n  }\n}\nregisterMethods({\n  Container: {\n    // Create a use element\n    use: wrapWithAttrCheck(function (element, file) {\n      return this.put(new Use()).use(element, file);\n    })\n  }\n});\nregister(Use, 'Use');\n\n/* Optional Modules */\nconst SVG = makeInstance;\nextend([Svg, Symbol, Image, Pattern, Marker], getMethodsFor('viewbox'));\nextend([Line, Polyline, Polygon, Path], getMethodsFor('marker'));\nextend(Text, getMethodsFor('Text'));\nextend(Path, getMethodsFor('Path'));\nextend(Defs, getMethodsFor('Defs'));\nextend([Text, Tspan], getMethodsFor('Tspan'));\nextend([Rect, Ellipse, Gradient, Runner], getMethodsFor('radius'));\nextend(EventTarget, getMethodsFor('EventTarget'));\nextend(Dom, getMethodsFor('Dom'));\nextend(Element, getMethodsFor('Element'));\nextend(Shape, getMethodsFor('Shape'));\nextend([Container, Fragment], getMethodsFor('Container'));\nextend(Gradient, getMethodsFor('Gradient'));\nextend(Runner, getMethodsFor('Runner'));\nList.extend(getMethodNames());\nregisterMorphableType([SVGNumber, Color, Box, Matrix, SVGArray, PointArray, PathArray, Point]);\nmakeMorphable();\n\nexports.A = A;\nexports.Animator = Animator;\nexports.Array = SVGArray;\nexports.Box = Box;\nexports.Circle = Circle;\nexports.ClipPath = ClipPath;\nexports.Color = Color;\nexports.Container = Container;\nexports.Controller = Controller;\nexports.Defs = Defs;\nexports.Dom = Dom;\nexports.Ease = Ease;\nexports.Element = Element;\nexports.Ellipse = Ellipse;\nexports.EventTarget = EventTarget;\nexports.ForeignObject = ForeignObject;\nexports.Fragment = Fragment;\nexports.G = G;\nexports.Gradient = Gradient;\nexports.Image = Image;\nexports.Line = Line;\nexports.List = List;\nexports.Marker = Marker;\nexports.Mask = Mask;\nexports.Matrix = Matrix;\nexports.Morphable = Morphable;\nexports.NonMorphable = NonMorphable;\nexports.Number = SVGNumber;\nexports.ObjectBag = ObjectBag;\nexports.PID = PID;\nexports.Path = Path;\nexports.PathArray = PathArray;\nexports.Pattern = Pattern;\nexports.Point = Point;\nexports.PointArray = PointArray;\nexports.Polygon = Polygon;\nexports.Polyline = Polyline;\nexports.Queue = Queue;\nexports.Rect = Rect;\nexports.Runner = Runner;\nexports.SVG = SVG;\nexports.Shape = Shape;\nexports.Spring = Spring;\nexports.Stop = Stop;\nexports.Style = Style;\nexports.Svg = Svg;\nexports.Symbol = Symbol;\nexports.Text = Text;\nexports.TextPath = TextPath;\nexports.Timeline = Timeline;\nexports.TransformBag = TransformBag;\nexports.Tspan = Tspan;\nexports.Use = Use;\nexports.adopt = adopt;\nexports.assignNewId = assignNewId;\nexports.clearEvents = clearEvents;\nexports.create = create;\nexports.defaults = defaults;\nexports.dispatch = dispatch;\nexports.easing = easing;\nexports.eid = eid;\nexports.extend = extend;\nexports.find = baseFind;\nexports.getClass = getClass;\nexports.getEventTarget = getEventTarget;\nexports.getEvents = getEvents;\nexports.getWindow = getWindow;\nexports.makeInstance = makeInstance;\nexports.makeMorphable = makeMorphable;\nexports.mockAdopt = mockAdopt;\nexports.namespaces = namespaces;\nexports.nodeOrNew = nodeOrNew;\nexports.off = off;\nexports.on = on;\nexports.parser = parser;\nexports.regex = regex;\nexports.register = register;\nexports.registerMorphableType = registerMorphableType;\nexports.registerWindow = registerWindow;\nexports.restoreWindow = restoreWindow;\nexports.root = root;\nexports.saveWindow = saveWindow;\nexports.utils = utils;\nexports.windowEvents = windowEvents;\nexports.withWindow = withWindow;\nexports.wrapWithAttrCheck = wrapWithAttrCheck;\n//# sourceMappingURL=svg.node.cjs.map\n","'use strict';\n\nmodule.exports = require('./lib/svgpath');\n","// Convert an arc to a sequence of cubic bzier curves\n//\n'use strict';\n\n\nvar TAU = Math.PI * 2;\n\n\n/* eslint-disable space-infix-ops */\n\n// Calculate an angle between two unit vectors\n//\n// Since we measure angle between radii of circular arcs,\n// we can use simplified math (without length normalization)\n//\nfunction unit_vector_angle(ux, uy, vx, vy) {\n  var sign = (ux * vy - uy * vx < 0) ? -1 : 1;\n  var dot  = ux * vx + uy * vy;\n\n  // Add this to work with arbitrary vectors:\n  // dot /= Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n\n  // rounding errors, e.g. -1.0000000000000002 can screw up this\n  if (dot >  1.0) { dot =  1.0; }\n  if (dot < -1.0) { dot = -1.0; }\n\n  return sign * Math.acos(dot);\n}\n\n\n// Convert from endpoint to center parameterization,\n// see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n//\n// Return [cx, cy, theta1, delta_theta]\n//\nfunction get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {\n  // Step 1.\n  //\n  // Moving an ellipse so origin will be the middlepoint between our two\n  // points. After that, rotate it to line up ellipse axes with coordinate\n  // axes.\n  //\n  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;\n  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;\n\n  var rx_sq  =  rx * rx;\n  var ry_sq  =  ry * ry;\n  var x1p_sq = x1p * x1p;\n  var y1p_sq = y1p * y1p;\n\n  // Step 2.\n  //\n  // Compute coordinates of the centre of this ellipse (cx', cy')\n  // in the new coordinate system.\n  //\n  var radicant = (rx_sq * ry_sq) - (rx_sq * y1p_sq) - (ry_sq * x1p_sq);\n\n  if (radicant < 0) {\n    // due to rounding errors it might be e.g. -1.3877787807814457e-17\n    radicant = 0;\n  }\n\n  radicant /=   (rx_sq * y1p_sq) + (ry_sq * x1p_sq);\n  radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);\n\n  var cxp = radicant *  rx/ry * y1p;\n  var cyp = radicant * -ry/rx * x1p;\n\n  // Step 3.\n  //\n  // Transform back to get centre coordinates (cx, cy) in the original\n  // coordinate system.\n  //\n  var cx = cos_phi*cxp - sin_phi*cyp + (x1+x2)/2;\n  var cy = sin_phi*cxp + cos_phi*cyp + (y1+y2)/2;\n\n  // Step 4.\n  //\n  // Compute angles (theta1, delta_theta).\n  //\n  var v1x =  (x1p - cxp) / rx;\n  var v1y =  (y1p - cyp) / ry;\n  var v2x = (-x1p - cxp) / rx;\n  var v2y = (-y1p - cyp) / ry;\n\n  var theta1 = unit_vector_angle(1, 0, v1x, v1y);\n  var delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);\n\n  if (fs === 0 && delta_theta > 0) {\n    delta_theta -= TAU;\n  }\n  if (fs === 1 && delta_theta < 0) {\n    delta_theta += TAU;\n  }\n\n  return [ cx, cy, theta1, delta_theta ];\n}\n\n//\n// Approximate one unit arc segment with bzier curves,\n// see http://math.stackexchange.com/questions/873224\n//\nfunction approximate_unit_arc(theta1, delta_theta) {\n  var alpha = 4/3 * Math.tan(delta_theta/4);\n\n  var x1 = Math.cos(theta1);\n  var y1 = Math.sin(theta1);\n  var x2 = Math.cos(theta1 + delta_theta);\n  var y2 = Math.sin(theta1 + delta_theta);\n\n  return [ x1, y1, x1 - y1*alpha, y1 + x1*alpha, x2 + y2*alpha, y2 - x2*alpha, x2, y2 ];\n}\n\nmodule.exports = function a2c(x1, y1, x2, y2, fa, fs, rx, ry, phi) {\n  var sin_phi = Math.sin(phi * TAU / 360);\n  var cos_phi = Math.cos(phi * TAU / 360);\n\n  // Make sure radii are valid\n  //\n  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;\n  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;\n\n  if (x1p === 0 && y1p === 0) {\n    // we're asked to draw line to itself\n    return [];\n  }\n\n  if (rx === 0 || ry === 0) {\n    // one of the radii is zero\n    return [];\n  }\n\n\n  // Compensate out-of-range radii\n  //\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = (x1p * x1p) / (rx * rx) + (y1p * y1p) / (ry * ry);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n\n  // Get center parameters (cx, cy, theta1, delta_theta)\n  //\n  var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);\n\n  var result = [];\n  var theta1 = cc[2];\n  var delta_theta = cc[3];\n\n  // Split an arc to multiple segments, so each segment\n  // will be less than /4 (= 90)\n  //\n  var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);\n  delta_theta /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    result.push(approximate_unit_arc(theta1, delta_theta));\n    theta1 += delta_theta;\n  }\n\n  // We have a bezier approximation of a unit circle,\n  // now need to transform back to the original ellipse\n  //\n  return result.map(function (curve) {\n    for (var i = 0; i < curve.length; i += 2) {\n      var x = curve[i + 0];\n      var y = curve[i + 1];\n\n      // scale\n      x *= rx;\n      y *= ry;\n\n      // rotate\n      var xp = cos_phi*x - sin_phi*y;\n      var yp = sin_phi*x + cos_phi*y;\n\n      // translate\n      curve[i + 0] = xp + cc[0];\n      curve[i + 1] = yp + cc[1];\n    }\n\n    return curve;\n  });\n};\n","'use strict';\n\n/* eslint-disable space-infix-ops */\n\n// The precision used to consider an ellipse as a circle\n//\nvar epsilon = 0.0000000001;\n\n// To convert degree in radians\n//\nvar torad = Math.PI / 180;\n\n// Class constructor :\n//  an ellipse centred at 0 with radii rx,ry and x - axis - angle ax.\n//\nfunction Ellipse(rx, ry, ax) {\n  if (!(this instanceof Ellipse)) { return new Ellipse(rx, ry, ax); }\n  this.rx = rx;\n  this.ry = ry;\n  this.ax = ax;\n}\n\n// Apply a linear transform m to the ellipse\n// m is an array representing a matrix :\n//    -         -\n//   | m[0] m[2] |\n//   | m[1] m[3] |\n//    -         -\n//\nEllipse.prototype.transform = function (m) {\n  // We consider the current ellipse as image of the unit circle\n  // by first scale(rx,ry) and then rotate(ax) ...\n  // So we apply ma =  m x rotate(ax) x scale(rx,ry) to the unit circle.\n  var c = Math.cos(this.ax * torad), s = Math.sin(this.ax * torad);\n  var ma = [\n    this.rx * (m[0]*c + m[2]*s),\n    this.rx * (m[1]*c + m[3]*s),\n    this.ry * (-m[0]*s + m[2]*c),\n    this.ry * (-m[1]*s + m[3]*c)\n  ];\n\n  // ma * transpose(ma) = [ J L ]\n  //                      [ L K ]\n  // L is calculated later (if the image is not a circle)\n  var J = ma[0]*ma[0] + ma[2]*ma[2],\n      K = ma[1]*ma[1] + ma[3]*ma[3];\n\n  // the discriminant of the characteristic polynomial of ma * transpose(ma)\n  var D = ((ma[0]-ma[3])*(ma[0]-ma[3]) + (ma[2]+ma[1])*(ma[2]+ma[1])) *\n          ((ma[0]+ma[3])*(ma[0]+ma[3]) + (ma[2]-ma[1])*(ma[2]-ma[1]));\n\n  // the \"mean eigenvalue\"\n  var JK = (J + K) / 2;\n\n  // check if the image is (almost) a circle\n  if (D < epsilon * JK) {\n    // if it is\n    this.rx = this.ry = Math.sqrt(JK);\n    this.ax = 0;\n    return this;\n  }\n\n  // if it is not a circle\n  var L = ma[0]*ma[1] + ma[2]*ma[3];\n\n  D = Math.sqrt(D);\n\n  // {l1,l2} = the two eigen values of ma * transpose(ma)\n  var l1 = JK + D/2,\n      l2 = JK - D/2;\n  // the x - axis - rotation angle is the argument of the l1 - eigenvector\n  /*eslint-disable indent*/\n  this.ax = (Math.abs(L) < epsilon && Math.abs(l1 - K) < epsilon) ?\n    90\n  :\n    Math.atan(Math.abs(L) > Math.abs(l1 - K) ?\n      (l1 - J) / L\n    :\n      L / (l1 - K)\n    ) * 180 / Math.PI;\n  /*eslint-enable indent*/\n\n  // if ax > 0 => rx = sqrt(l1), ry = sqrt(l2), else exchange axes and ax += 90\n  if (this.ax >= 0) {\n    // if ax in [0,90]\n    this.rx = Math.sqrt(l1);\n    this.ry = Math.sqrt(l2);\n  } else {\n    // if ax in ]-90,0[ => exchange axes\n    this.ax += 90;\n    this.rx = Math.sqrt(l2);\n    this.ry = Math.sqrt(l1);\n  }\n\n  return this;\n};\n\n// Check if the ellipse is (almost) degenerate, i.e. rx = 0 or ry = 0\n//\nEllipse.prototype.isDegenerate = function () {\n  return (this.rx < epsilon * this.ry || this.ry < epsilon * this.rx);\n};\n\nmodule.exports = Ellipse;\n","'use strict';\n\n// combine 2 matrixes\n// m1, m2 - [a, b, c, d, e, g]\n//\nfunction combine(m1, m2) {\n  return [\n    m1[0] * m2[0] + m1[2] * m2[1],\n    m1[1] * m2[0] + m1[3] * m2[1],\n    m1[0] * m2[2] + m1[2] * m2[3],\n    m1[1] * m2[2] + m1[3] * m2[3],\n    m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n    m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n  ];\n}\n\n\nfunction Matrix() {\n  if (!(this instanceof Matrix)) { return new Matrix(); }\n  this.queue = [];   // list of matrixes to apply\n  this.cache = null; // combined matrix cache\n}\n\n\nMatrix.prototype.matrix = function (m) {\n  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {\n    return this;\n  }\n  this.cache = null;\n  this.queue.push(m);\n  return this;\n};\n\n\nMatrix.prototype.translate = function (tx, ty) {\n  if (tx !== 0 || ty !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, 0, 0, 1, tx, ty ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.scale = function (sx, sy) {\n  if (sx !== 1 || sy !== 1) {\n    this.cache = null;\n    this.queue.push([ sx, 0, 0, sy, 0, 0 ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.rotate = function (angle, rx, ry) {\n  var rad, cos, sin;\n\n  if (angle !== 0) {\n    this.translate(rx, ry);\n\n    rad = angle * Math.PI / 180;\n    cos = Math.cos(rad);\n    sin = Math.sin(rad);\n\n    this.queue.push([ cos, sin, -sin, cos, 0, 0 ]);\n    this.cache = null;\n\n    this.translate(-rx, -ry);\n  }\n  return this;\n};\n\n\nMatrix.prototype.skewX = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0 ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.skewY = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0 ]);\n  }\n  return this;\n};\n\n\n// Flatten queue\n//\nMatrix.prototype.toArray = function () {\n  if (this.cache) {\n    return this.cache;\n  }\n\n  if (!this.queue.length) {\n    this.cache = [ 1, 0, 0, 1, 0, 0 ];\n    return this.cache;\n  }\n\n  this.cache = this.queue[0];\n\n  if (this.queue.length === 1) {\n    return this.cache;\n  }\n\n  for (var i = 1; i < this.queue.length; i++) {\n    this.cache = combine(this.cache, this.queue[i]);\n  }\n\n  return this.cache;\n};\n\n\n// Apply list of matrixes to (x,y) point.\n// If `isRelative` set, `translate` component of matrix will be skipped\n//\nMatrix.prototype.calc = function (x, y, isRelative) {\n  var m;\n\n  // Don't change point on empty transforms queue\n  if (!this.queue.length) { return [ x, y ]; }\n\n  // Calculate final matrix, if not exists\n  //\n  // NB. if you deside to apply transforms to point one-by-one,\n  // they should be taken in reverse order\n\n  if (!this.cache) {\n    this.cache = this.toArray();\n  }\n\n  m = this.cache;\n\n  // Apply matrix to point\n  return [\n    x * m[0] + y * m[2] + (isRelative ? 0 : m[4]),\n    x * m[1] + y * m[3] + (isRelative ? 0 : m[5])\n  ];\n};\n\n\nmodule.exports = Matrix;\n","'use strict';\n\n\nvar paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 };\n\nvar SPECIAL_SPACES = [\n  0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006,\n  0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF\n];\n\nfunction isSpace(ch) {\n  return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029) || // Line terminators\n    // White spaces\n    (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n    (ch >= 0x1680 && SPECIAL_SPACES.indexOf(ch) >= 0);\n}\n\nfunction isCommand(code) {\n  /*eslint-disable no-bitwise*/\n  switch (code | 0x20) {\n    case 0x6D/* m */:\n    case 0x7A/* z */:\n    case 0x6C/* l */:\n    case 0x68/* h */:\n    case 0x76/* v */:\n    case 0x63/* c */:\n    case 0x73/* s */:\n    case 0x71/* q */:\n    case 0x74/* t */:\n    case 0x61/* a */:\n    case 0x72/* r */:\n      return true;\n  }\n  return false;\n}\n\nfunction isArc(code) {\n  return (code | 0x20) === 0x61;\n}\n\nfunction isDigit(code) {\n  return (code >= 48 && code <= 57);   // 0..9\n}\n\nfunction isDigitStart(code) {\n  return (code >= 48 && code <= 57) || /* 0..9 */\n          code === 0x2B || /* + */\n          code === 0x2D || /* - */\n          code === 0x2E;   /* . */\n}\n\n\nfunction State(path) {\n  this.index  = 0;\n  this.path   = path;\n  this.max    = path.length;\n  this.result = [];\n  this.param  = 0.0;\n  this.err    = '';\n  this.segmentStart = 0;\n  this.data   = [];\n}\n\nfunction skipSpaces(state) {\n  while (state.index < state.max && isSpace(state.path.charCodeAt(state.index))) {\n    state.index++;\n  }\n}\n\n\nfunction scanFlag(state) {\n  var ch = state.path.charCodeAt(state.index);\n\n  if (ch === 0x30/* 0 */) {\n    state.param = 0;\n    state.index++;\n    return;\n  }\n\n  if (ch === 0x31/* 1 */) {\n    state.param = 1;\n    state.index++;\n    return;\n  }\n\n  state.err = 'SvgPath: arc flag can be 0 or 1 only (at pos ' + state.index + ')';\n}\n\n\nfunction scanParam(state) {\n  var start = state.index,\n      index = start,\n      max = state.max,\n      zeroFirst = false,\n      hasCeiling = false,\n      hasDecimal = false,\n      hasDot = false,\n      ch;\n\n  if (index >= max) {\n    state.err = 'SvgPath: missed param (at pos ' + index + ')';\n    return;\n  }\n  ch = state.path.charCodeAt(index);\n\n  if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n    index++;\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  //\n  if (!isDigit(ch) && ch !== 0x2E/* . */) {\n    state.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    return;\n  }\n\n  if (ch !== 0x2E/* . */) {\n    zeroFirst = (ch === 0x30/* 0 */);\n    index++;\n\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        state.err = 'SvgPath: numbers started with `0` such as `09` are illegal (at pos ' + start + ')';\n        return;\n      }\n    }\n\n    while (index < max && isDigit(state.path.charCodeAt(index))) {\n      index++;\n      hasCeiling = true;\n    }\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  if (ch === 0x2E/* . */) {\n    hasDot = true;\n    index++;\n    while (isDigit(state.path.charCodeAt(index))) {\n      index++;\n      hasDecimal = true;\n    }\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  if (ch === 0x65/* e */ || ch === 0x45/* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';\n      return;\n    }\n\n    index++;\n\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      index++;\n    }\n    if (index < max && isDigit(state.path.charCodeAt(index))) {\n      while (index < max && isDigit(state.path.charCodeAt(index))) {\n        index++;\n      }\n    } else {\n      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';\n      return;\n    }\n  }\n\n  state.index = index;\n  state.param = parseFloat(state.path.slice(start, index)) + 0.0;\n}\n\n\nfunction finalizeSegment(state) {\n  var cmd, cmdLC;\n\n  // Process duplicated commands (without comand name)\n\n  // This logic is shamelessly borrowed from Raphael\n  // https://github.com/DmitryBaranovskiy/raphael/\n  //\n  cmd   = state.path[state.segmentStart];\n  cmdLC = cmd.toLowerCase();\n\n  var params = state.data;\n\n  if (cmdLC === 'm' && params.length > 2) {\n    state.result.push([ cmd, params[0], params[1] ]);\n    params = params.slice(2);\n    cmdLC = 'l';\n    cmd = (cmd === 'm') ? 'l' : 'L';\n  }\n\n  if (cmdLC === 'r') {\n    state.result.push([ cmd ].concat(params));\n  } else {\n\n    while (params.length >= paramCounts[cmdLC]) {\n      state.result.push([ cmd ].concat(params.splice(0, paramCounts[cmdLC])));\n      if (!paramCounts[cmdLC]) {\n        break;\n      }\n    }\n  }\n}\n\n\nfunction scanSegment(state) {\n  var max = state.max,\n      cmdCode, is_arc, comma_found, need_params, i;\n\n  state.segmentStart = state.index;\n  cmdCode = state.path.charCodeAt(state.index);\n  is_arc = isArc(cmdCode);\n\n  if (!isCommand(cmdCode)) {\n    state.err = 'SvgPath: bad command ' + state.path[state.index] + ' (at pos ' + state.index + ')';\n    return;\n  }\n\n  need_params = paramCounts[state.path[state.index].toLowerCase()];\n\n  state.index++;\n  skipSpaces(state);\n\n  state.data = [];\n\n  if (!need_params) {\n    // Z\n    finalizeSegment(state);\n    return;\n  }\n\n  comma_found = false;\n\n  for (;;) {\n    for (i = need_params; i > 0; i--) {\n      if (is_arc && (i === 3 || i === 4)) scanFlag(state);\n      else scanParam(state);\n\n      if (state.err.length) {\n        finalizeSegment(state);\n        return;\n      }\n      state.data.push(state.param);\n\n      skipSpaces(state);\n      comma_found = false;\n\n      if (state.index < max && state.path.charCodeAt(state.index) === 0x2C/* , */) {\n        state.index++;\n        skipSpaces(state);\n        comma_found = true;\n      }\n    }\n\n    // after ',' param is mandatory\n    if (comma_found) {\n      continue;\n    }\n\n    if (state.index >= state.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(state.path.charCodeAt(state.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(state);\n}\n\n\n/* Returns array of segments:\n *\n * [\n *   [ command, coord1, coord2, ... ]\n * ]\n */\nmodule.exports = function pathParse(svgPath) {\n  var state = new State(svgPath);\n  var max = state.max;\n\n  skipSpaces(state);\n\n  while (state.index < max && !state.err.length) {\n    scanSegment(state);\n  }\n\n  if (state.result.length) {\n    if ('mM'.indexOf(state.result[0][0]) < 0) {\n      state.err = 'SvgPath: string should start with `M` or `m`';\n      state.result = [];\n    } else {\n      state.result[0][0] = 'M';\n    }\n  }\n\n  return {\n    err: state.err,\n    segments: state.result\n  };\n};\n","// SVG Path transformations library\n//\n// Usage:\n//\n//    SvgPath('...')\n//      .translate(-150, -100)\n//      .scale(0.5)\n//      .translate(-150, -100)\n//      .toFixed(1)\n//      .toString()\n//\n\n'use strict';\n\n\nvar pathParse      = require('./path_parse');\nvar transformParse = require('./transform_parse');\nvar matrix         = require('./matrix');\nvar a2c            = require('./a2c');\nvar ellipse        = require('./ellipse');\n\n\n// Class constructor\n//\nfunction SvgPath(path) {\n  if (!(this instanceof SvgPath)) { return new SvgPath(path); }\n\n  var pstate = pathParse(path);\n\n  // Array of path segments.\n  // Each segment is array [command, param1, param2, ...]\n  this.segments = pstate.segments;\n\n  // Error message on parse error.\n  this.err      = pstate.err;\n\n  // Transforms stack for lazy evaluation\n  this.__stack    = [];\n}\n\nSvgPath.from = function (src) {\n  if (typeof src === 'string') return new SvgPath(src);\n\n  if (src instanceof SvgPath) {\n    // Create empty object\n    var s = new SvgPath('');\n\n    // Clone properies\n    s.err = src.err;\n    s.segments = src.segments.map(function (sgm) { return sgm.slice(); });\n    s.__stack = src.__stack.map(function (m) {\n      return matrix().matrix(m.toArray());\n    });\n\n    return s;\n  }\n\n  throw new Error('SvgPath.from: invalid param type ' + src);\n};\n\n\nSvgPath.prototype.__matrix = function (m) {\n  var self = this, i;\n\n  // Quick leave for empty matrix\n  if (!m.queue.length) { return; }\n\n  this.iterate(function (s, index, x, y) {\n    var p, result, name, isRelative;\n\n    switch (s[0]) {\n\n      // Process 'assymetric' commands separately\n      case 'v':\n        p      = m.calc(0, s[1], true);\n        result = (p[0] === 0) ? [ 'v', p[1] ] : [ 'l', p[0], p[1] ];\n        break;\n\n      case 'V':\n        p      = m.calc(x, s[1], false);\n        result = (p[0] === m.calc(x, y, false)[0]) ? [ 'V', p[1] ] : [ 'L', p[0], p[1] ];\n        break;\n\n      case 'h':\n        p      = m.calc(s[1], 0, true);\n        result = (p[1] === 0) ? [ 'h', p[0] ] : [ 'l', p[0], p[1] ];\n        break;\n\n      case 'H':\n        p      = m.calc(s[1], y, false);\n        result = (p[1] === m.calc(x, y, false)[1]) ? [ 'H', p[0] ] : [ 'L', p[0], p[1] ];\n        break;\n\n      case 'a':\n      case 'A':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n\n        // Drop segment if arc is empty (end point === start point)\n        /*if ((s[0] === 'A' && s[6] === x && s[7] === y) ||\n            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {\n          return [];\n        }*/\n\n        // Transform rx, ry and the x-axis-rotation\n        var ma = m.toArray();\n        var e = ellipse(s[1], s[2], s[3]).transform(ma);\n\n        // flip sweep-flag if matrix is not orientation-preserving\n        if (ma[0] * ma[3] - ma[1] * ma[2] < 0) {\n          s[5] = s[5] ? '0' : '1';\n        }\n\n        // Transform end point as usual (without translation for relative notation)\n        p = m.calc(s[6], s[7], s[0] === 'a');\n\n        // Empty arcs can be ignored by renderer, but should not be dropped\n        // to avoid collisions with `S A S` and so on. Replace with empty line.\n        if ((s[0] === 'A' && s[6] === x && s[7] === y) ||\n            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {\n          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];\n          break;\n        }\n\n        // if the resulting ellipse is (almost) a segment ...\n        if (e.isDegenerate()) {\n          // replace the arc by a line\n          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];\n        } else {\n          // if it is a real ellipse\n          // s[0], s[4] and s[5] are not modified\n          result = [ s[0], e.rx, e.ry, e.ax, s[4], s[5], p[0], p[1] ];\n        }\n\n        break;\n\n      case 'm':\n        // Edge case. The very first `m` should be processed as absolute, if happens.\n        // Make sense for coord shift transforms.\n        isRelative = index > 0;\n\n        p = m.calc(s[1], s[2], isRelative);\n        result = [ 'm', p[0], p[1] ];\n        break;\n\n      default:\n        name       = s[0];\n        result     = [ name ];\n        isRelative = (name.toLowerCase() === name);\n\n        // Apply transformations to the segment\n        for (i = 1; i < s.length; i += 2) {\n          p = m.calc(s[i], s[i + 1], isRelative);\n          result.push(p[0], p[1]);\n        }\n    }\n\n    self.segments[index] = result;\n  }, true);\n};\n\n\n// Apply stacked commands\n//\nSvgPath.prototype.__evaluateStack = function () {\n  var m, i;\n\n  if (!this.__stack.length) { return; }\n\n  if (this.__stack.length === 1) {\n    this.__matrix(this.__stack[0]);\n    this.__stack = [];\n    return;\n  }\n\n  m = matrix();\n  i = this.__stack.length;\n\n  while (--i >= 0) {\n    m.matrix(this.__stack[i].toArray());\n  }\n\n  this.__matrix(m);\n  this.__stack = [];\n};\n\n\n// Convert processed SVG Path back to string\n//\nSvgPath.prototype.toString = function () {\n  var result = '', prevCmd = '', cmdSkipped = false;\n\n  this.__evaluateStack();\n\n  for (var i = 0, len = this.segments.length; i < len; i++) {\n    var segment = this.segments[i];\n    var cmd = segment[0];\n\n    // Command not repeating => store\n    if (cmd !== prevCmd || cmd === 'm' || cmd === 'M') {\n      // workaround for FontForge SVG importing bug, keep space between \"z m\".\n      if (cmd === 'm' && prevCmd === 'z') result += ' ';\n      result += cmd;\n\n      cmdSkipped = false;\n    } else {\n      cmdSkipped = true;\n    }\n\n    // Store segment params\n    for (var pos = 1; pos < segment.length; pos++) {\n      var val = segment[pos];\n      // Space can be skipped\n      // 1. After command (always)\n      // 2. For negative value (with '-' at start)\n      if (pos === 1) {\n        if (cmdSkipped && val >= 0) result += ' ';\n      } else if (val >= 0) result += ' ';\n\n      result += val;\n    }\n\n    prevCmd = cmd;\n  }\n\n  return result;\n};\n\n\n// Translate path to (x [, y])\n//\nSvgPath.prototype.translate = function (x, y) {\n  this.__stack.push(matrix().translate(x, y || 0));\n  return this;\n};\n\n\n// Scale path to (sx [, sy])\n// sy = sx if not defined\n//\nSvgPath.prototype.scale = function (sx, sy) {\n  this.__stack.push(matrix().scale(sx, (!sy && (sy !== 0)) ? sx : sy));\n  return this;\n};\n\n\n// Rotate path around point (sx [, sy])\n// sy = sx if not defined\n//\nSvgPath.prototype.rotate = function (angle, rx, ry) {\n  this.__stack.push(matrix().rotate(angle, rx || 0, ry || 0));\n  return this;\n};\n\n\n// Skew path along the X axis by `degrees` angle\n//\nSvgPath.prototype.skewX = function (degrees) {\n  this.__stack.push(matrix().skewX(degrees));\n  return this;\n};\n\n\n// Skew path along the Y axis by `degrees` angle\n//\nSvgPath.prototype.skewY = function (degrees) {\n  this.__stack.push(matrix().skewY(degrees));\n  return this;\n};\n\n\n// Apply matrix transform (array of 6 elements)\n//\nSvgPath.prototype.matrix = function (m) {\n  this.__stack.push(matrix().matrix(m));\n  return this;\n};\n\n\n// Transform path according to \"transform\" attr of SVG spec\n//\nSvgPath.prototype.transform = function (transformString) {\n  if (!transformString.trim()) {\n    return this;\n  }\n  this.__stack.push(transformParse(transformString));\n  return this;\n};\n\n\n// Round coords with given decimal precition.\n// 0 by default (to integers)\n//\nSvgPath.prototype.round = function (d) {\n  var contourStartDeltaX = 0, contourStartDeltaY = 0, deltaX = 0, deltaY = 0, l;\n\n  d = d || 0;\n\n  this.__evaluateStack();\n\n  this.segments.forEach(function (s) {\n    var isRelative = (s[0].toLowerCase() === s[0]);\n\n    switch (s[0]) {\n      case 'H':\n      case 'h':\n        if (isRelative) { s[1] += deltaX; }\n        deltaX = s[1] - s[1].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        return;\n\n      case 'V':\n      case 'v':\n        if (isRelative) { s[1] += deltaY; }\n        deltaY = s[1] - s[1].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        return;\n\n      case 'Z':\n      case 'z':\n        deltaX = contourStartDeltaX;\n        deltaY = contourStartDeltaY;\n        return;\n\n      case 'M':\n      case 'm':\n        if (isRelative) {\n          s[1] += deltaX;\n          s[2] += deltaY;\n        }\n\n        deltaX = s[1] - s[1].toFixed(d);\n        deltaY = s[2] - s[2].toFixed(d);\n\n        contourStartDeltaX = deltaX;\n        contourStartDeltaY = deltaY;\n\n        s[1] = +s[1].toFixed(d);\n        s[2] = +s[2].toFixed(d);\n        return;\n\n      case 'A':\n      case 'a':\n        // [cmd, rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        if (isRelative) {\n          s[6] += deltaX;\n          s[7] += deltaY;\n        }\n\n        deltaX = s[6] - s[6].toFixed(d);\n        deltaY = s[7] - s[7].toFixed(d);\n\n        s[1] = +s[1].toFixed(d);\n        s[2] = +s[2].toFixed(d);\n        s[3] = +s[3].toFixed(d + 2); // better precision for rotation\n        s[6] = +s[6].toFixed(d);\n        s[7] = +s[7].toFixed(d);\n        return;\n\n      default:\n        // a c l q s t\n        l = s.length;\n\n        if (isRelative) {\n          s[l - 2] += deltaX;\n          s[l - 1] += deltaY;\n        }\n\n        deltaX = s[l - 2] - s[l - 2].toFixed(d);\n        deltaY = s[l - 1] - s[l - 1].toFixed(d);\n\n        s.forEach(function (val, i) {\n          if (!i) { return; }\n          s[i] = +s[i].toFixed(d);\n        });\n        return;\n    }\n  });\n\n  return this;\n};\n\n\n// Apply iterator function to all segments. If function returns result,\n// current segment will be replaced to array of returned segments.\n// If empty array is returned, current regment will be deleted.\n//\nSvgPath.prototype.iterate = function (iterator, keepLazyStack) {\n  var segments = this.segments,\n      replacements = {},\n      needReplace = false,\n      lastX = 0,\n      lastY = 0,\n      countourStartX = 0,\n      countourStartY = 0;\n  var i, j, newSegments;\n\n  if (!keepLazyStack) {\n    this.__evaluateStack();\n  }\n\n  segments.forEach(function (s, index) {\n\n    var res = iterator(s, index, lastX, lastY);\n\n    if (Array.isArray(res)) {\n      replacements[index] = res;\n      needReplace = true;\n    }\n\n    var isRelative = (s[0] === s[0].toLowerCase());\n\n    // calculate absolute X and Y\n    switch (s[0]) {\n      case 'm':\n      case 'M':\n        lastX = s[1] + (isRelative ? lastX : 0);\n        lastY = s[2] + (isRelative ? lastY : 0);\n        countourStartX = lastX;\n        countourStartY = lastY;\n        return;\n\n      case 'h':\n      case 'H':\n        lastX = s[1] + (isRelative ? lastX : 0);\n        return;\n\n      case 'v':\n      case 'V':\n        lastY = s[1] + (isRelative ? lastY : 0);\n        return;\n\n      case 'z':\n      case 'Z':\n        // That make sence for multiple contours\n        lastX = countourStartX;\n        lastY = countourStartY;\n        return;\n\n      default:\n        lastX = s[s.length - 2] + (isRelative ? lastX : 0);\n        lastY = s[s.length - 1] + (isRelative ? lastY : 0);\n    }\n  });\n\n  // Replace segments if iterator return results\n\n  if (!needReplace) { return this; }\n\n  newSegments = [];\n\n  for (i = 0; i < segments.length; i++) {\n    if (typeof replacements[i] !== 'undefined') {\n      for (j = 0; j < replacements[i].length; j++) {\n        newSegments.push(replacements[i][j]);\n      }\n    } else {\n      newSegments.push(segments[i]);\n    }\n  }\n\n  this.segments = newSegments;\n\n  return this;\n};\n\n\n// Converts segments from relative to absolute\n//\nSvgPath.prototype.abs = function () {\n\n  this.iterate(function (s, index, x, y) {\n    var name = s[0],\n        nameUC = name.toUpperCase(),\n        i;\n\n    // Skip absolute commands\n    if (name === nameUC) { return; }\n\n    s[0] = nameUC;\n\n    switch (name) {\n      case 'v':\n        // v has shifted coords parity\n        s[1] += y;\n        return;\n\n      case 'a':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // touch x, y only\n        s[6] += x;\n        s[7] += y;\n        return;\n\n      default:\n        for (i = 1; i < s.length; i++) {\n          s[i] += i % 2 ? x : y; // odd values are X, even - Y\n        }\n    }\n  }, true);\n\n  return this;\n};\n\n\n// Converts segments from absolute to relative\n//\nSvgPath.prototype.rel = function () {\n\n  this.iterate(function (s, index, x, y) {\n    var name = s[0],\n        nameLC = name.toLowerCase(),\n        i;\n\n    // Skip relative commands\n    if (name === nameLC) { return; }\n\n    // Don't touch the first M to avoid potential confusions.\n    if (index === 0 && name === 'M') { return; }\n\n    s[0] = nameLC;\n\n    switch (name) {\n      case 'V':\n        // V has shifted coords parity\n        s[1] -= y;\n        return;\n\n      case 'A':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // touch x, y only\n        s[6] -= x;\n        s[7] -= y;\n        return;\n\n      default:\n        for (i = 1; i < s.length; i++) {\n          s[i] -= i % 2 ? x : y; // odd values are X, even - Y\n        }\n    }\n  }, true);\n\n  return this;\n};\n\n\n// Converts arcs to cubic bzier curves\n//\nSvgPath.prototype.unarc = function () {\n  this.iterate(function (s, index, x, y) {\n    var new_segments, nextX, nextY, result = [], name = s[0];\n\n    // Skip anything except arcs\n    if (name !== 'A' && name !== 'a') { return null; }\n\n    if (name === 'a') {\n      // convert relative arc coordinates to absolute\n      nextX = x + s[6];\n      nextY = y + s[7];\n    } else {\n      nextX = s[6];\n      nextY = s[7];\n    }\n\n    new_segments = a2c(x, y, nextX, nextY, s[4], s[5], s[1], s[2], s[3]);\n\n    // Degenerated arcs can be ignored by renderer, but should not be dropped\n    // to avoid collisions with `S A S` and so on. Replace with empty line.\n    if (new_segments.length === 0) {\n      return [ [ s[0] === 'a' ? 'l' : 'L', s[6], s[7] ] ];\n    }\n\n    new_segments.forEach(function (s) {\n      result.push([ 'C', s[2], s[3], s[4], s[5], s[6], s[7] ]);\n    });\n\n    return result;\n  });\n\n  return this;\n};\n\n\n// Converts smooth curves (with missed control point) to generic curves\n//\nSvgPath.prototype.unshort = function () {\n  var segments = this.segments;\n  var prevControlX, prevControlY, prevSegment;\n  var curControlX, curControlY;\n\n  // TODO: add lazy evaluation flag when relative commands supported\n\n  this.iterate(function (s, idx, x, y) {\n    var name = s[0], nameUC = name.toUpperCase(), isRelative;\n\n    // First command MUST be M|m, it's safe to skip.\n    // Protect from access to [-1] for sure.\n    if (!idx) { return; }\n\n    if (nameUC === 'T') { // quadratic curve\n      isRelative = (name === 't');\n\n      prevSegment = segments[idx - 1];\n\n      if (prevSegment[0] === 'Q') {\n        prevControlX = prevSegment[1] - x;\n        prevControlY = prevSegment[2] - y;\n      } else if (prevSegment[0] === 'q') {\n        prevControlX = prevSegment[1] - prevSegment[3];\n        prevControlY = prevSegment[2] - prevSegment[4];\n      } else {\n        prevControlX = 0;\n        prevControlY = 0;\n      }\n\n      curControlX = -prevControlX;\n      curControlY = -prevControlY;\n\n      if (!isRelative) {\n        curControlX += x;\n        curControlY += y;\n      }\n\n      segments[idx] = [\n        isRelative ? 'q' : 'Q',\n        curControlX, curControlY,\n        s[1], s[2]\n      ];\n\n    } else if (nameUC === 'S') { // cubic curve\n      isRelative = (name === 's');\n\n      prevSegment = segments[idx - 1];\n\n      if (prevSegment[0] === 'C') {\n        prevControlX = prevSegment[3] - x;\n        prevControlY = prevSegment[4] - y;\n      } else if (prevSegment[0] === 'c') {\n        prevControlX = prevSegment[3] - prevSegment[5];\n        prevControlY = prevSegment[4] - prevSegment[6];\n      } else {\n        prevControlX = 0;\n        prevControlY = 0;\n      }\n\n      curControlX = -prevControlX;\n      curControlY = -prevControlY;\n\n      if (!isRelative) {\n        curControlX += x;\n        curControlY += y;\n      }\n\n      segments[idx] = [\n        isRelative ? 'c' : 'C',\n        curControlX, curControlY,\n        s[1], s[2], s[3], s[4]\n      ];\n    }\n  });\n\n  return this;\n};\n\n\nmodule.exports = SvgPath;\n","'use strict';\n\n\nvar Matrix = require('./matrix');\n\nvar operations = {\n  matrix: true,\n  scale: true,\n  rotate: true,\n  translate: true,\n  skewX: true,\n  skewY: true\n};\n\nvar CMD_SPLIT_RE    = /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/;\nvar PARAMS_SPLIT_RE = /[\\s,]+/;\n\n\nmodule.exports = function transformParse(transformString) {\n  var matrix = new Matrix();\n  var cmd, params;\n\n  // Split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate',  '-45', '']\n  transformString.split(CMD_SPLIT_RE).forEach(function (item) {\n\n    // Skip empty elements\n    if (!item.length) { return; }\n\n    // remember operation\n    if (typeof operations[item] !== 'undefined') {\n      cmd = item;\n      return;\n    }\n\n    // extract params & att operation to matrix\n    params = item.split(PARAMS_SPLIT_RE).map(function (i) {\n      return +i || 0;\n    });\n\n    // If params count is not correct - ignore command\n    switch (cmd) {\n      case 'matrix':\n        if (params.length === 6) {\n          matrix.matrix(params);\n        }\n        return;\n\n      case 'scale':\n        if (params.length === 1) {\n          matrix.scale(params[0], params[0]);\n        } else if (params.length === 2) {\n          matrix.scale(params[0], params[1]);\n        }\n        return;\n\n      case 'rotate':\n        if (params.length === 1) {\n          matrix.rotate(params[0], 0, 0);\n        } else if (params.length === 3) {\n          matrix.rotate(params[0], params[1], params[2]);\n        }\n        return;\n\n      case 'translate':\n        if (params.length === 1) {\n          matrix.translate(params[0], 0);\n        } else if (params.length === 2) {\n          matrix.translate(params[0], params[1]);\n        }\n        return;\n\n      case 'skewX':\n        if (params.length === 1) {\n          matrix.skewX(params[0]);\n        }\n        return;\n\n      case 'skewY':\n        if (params.length === 1) {\n          matrix.skewY(params[0]);\n        }\n        return;\n    }\n  });\n\n  return matrix;\n};\n","import { Color, Hex } from \"../src/visual-types\";\r\n\r\nclass RendererConstants {\r\n    CORNER_RADIUS!: number;\r\n    NODE_BASE_WIDTH!: number;\r\n    NODE_BASE_HEIGHT!: number;\r\n    TOPBAR_HEIGHT!: number;\r\n    FOOTER_HEIGHT!: number;\r\n    PADDING_BIG!: number;\r\n    PADDING_MEDIUM!: number;\r\n    PADDING_SMALL!: number;\r\n    FIELD_SPACEY!: number;\r\n    FIELD_RAW_BASE_WIDTH!: number;\r\n    FIELD_RAW_BASE_HEIGHT!: number;\r\n    INPUT_BOX_PADDING!: number;\r\n    INPUT_BOX_TEXT_ANCHOR!: 'start' | 'middle';\r\n    LABEL_SPACING!: number;\r\n\r\n    FIELD_RAW_COLOR: Color = '#2b2d36ff';         \r\n    FIELD_RAW_TEXT_COLOR: Color = '#e0e2e8ff';    \r\n    FIELD_RAW_OUTLINE_COLOR: Color = '#1f2027ff'; \r\n    FIELD_RAW_OUTLINE_STROKE!: number;\r\n    NODE_BG_COLOR: Color = '#2c2d3aff';           \r\n    NODE_OUTLINE_COLOR: Color = '#1d1e25ff';\r\n    CONNECTOR_TRIANGLE!: boolean; \r\n    CONNECTION_STROKE_WIDTH!: number;\r\n    CONNECTION_STROKE_COLOR_CHOICE!: number;\r\n    CONNECTOR_TRI_SIZE!: number;\r\n    CONNECTOR_RADIUS!: number;\r\n    FONT_FAMILY: string =\r\n        '\"Inter\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif';\r\n    FONT_SIZE!: number;\r\n    FONT_COLOR: Color = '#e0e2e8ff';              \r\n\r\n    FIELD_MARGIN_X!: number;\r\n    FIELD_MARGIN_Y!: number;\r\n    TOPBAR_LABEL_MARGIN_X!: number;\r\n    TOPBAR_LABEL_MARGIN_Y!: number;\r\n    TOPBAR_LABEL_BOLDED!: boolean;\r\n    CONNECTOR_LINE_WIDTH: number = 2;          \r\n    CONNECTOR_LINE_CURVED: boolean = true;     \r\n\r\n    constructor(overrides: Partial<RendererConstants> = {}) {\r\n        this.CONNECTOR_TRI_SIZE = 8;\r\n        this.CONNECTOR_RADIUS = 10;\r\n        this.CORNER_RADIUS = 6;\r\n        this.NODE_BASE_WIDTH = 200;\r\n        this.NODE_BASE_HEIGHT = 240;\r\n\r\n        this.TOPBAR_HEIGHT = 50;\r\n        this.FOOTER_HEIGHT = 25;\r\n        this.PADDING_BIG = 16;\r\n        this.PADDING_MEDIUM = 8;\r\n        this.PADDING_SMALL = 4;\r\n        this.FIELD_RAW_BASE_WIDTH = 80;\r\n        this.FIELD_RAW_BASE_HEIGHT = 42;\r\n        this.INPUT_BOX_PADDING = 6;\r\n        this.LABEL_SPACING = 5;\r\n        this.INPUT_BOX_TEXT_ANCHOR = 'middle';\r\n        this.CONNECTOR_TRIANGLE = false;\r\n        this.CONNECTION_STROKE_WIDTH = 2;\r\n        this.CONNECTION_STROKE_COLOR_CHOICE = 1;\r\n        this.FIELD_RAW_OUTLINE_STROKE = 2;\r\n        this.FIELD_SPACEY = 20;\r\n        this.FONT_SIZE = 20;\r\n        this.TOPBAR_LABEL_BOLDED = true;\r\n        this.FIELD_MARGIN_X = 16;\r\n        this.FIELD_MARGIN_Y = 4;\r\n        this.TOPBAR_LABEL_MARGIN_X = 12; \r\n        this.TOPBAR_LABEL_MARGIN_Y = 0;  \r\n\r\n        Object.assign(this, overrides);\r\n    }\r\n}\r\n\r\nexport default RendererConstants;\r\n","import RendererConstants from \"./constants\";\r\nimport WorkspaceSvg from '../src/workspace-svg';\r\nimport NodeSvg from '../src/nodesvg';\r\nimport * as Path from '../util/path';\r\nimport { parseColor } from \"../util/parse-color\";\r\nimport { G, Path as SvgPath, Svg, StrokeData, Element, List } from \"@svgdotjs/svg.js\";\r\nimport { Color, ColorStyle, Hex } from \"../src/visual-types\";\r\nimport Field, { AnyField, DummyField } from \"../src/field\";\r\nimport eventer from '../util/eventer';\r\nimport Connection, { Connectable } from \"../src/connection\";\r\nimport escapeAttr from '../util/escape-html';\r\nimport unescapeAttr from '../util/unescape-html';\r\nexport interface ConnectorToFrom {\r\n    to: Connection,\r\n    from: Connection,\r\n    fromCircle?: SvgPath,\r\n    toCircle?: SvgPath\r\n}\r\nexport interface DrawState {\r\n    id: string;\r\n    topbar?: SvgPath | null;\r\n    bg?: SvgPath | null;\r\n    group?: G | null;\r\n    fieldCol?: G | null;\r\n    fieldPosY?: number | null; // starts under topbar, goes down by field height each time one is drawn. This determines position\r\n    xButton?: G;\r\n    connectorsAwaitingConnection: ConnectorToFrom[]\r\n}\r\n\r\nfunction drawState(nodeGroup: G, id: string): DrawState {\r\n    return {\r\n        id,\r\n        group: nodeGroup,\r\n        fieldPosY: 0,\r\n        connectorsAwaitingConnection: []\r\n    }\r\n}\r\n\r\nclass Renderer {\r\n    _constants: RendererConstants;\r\n    _currentNode: NodeSvg | null;\r\n    _nodeGroup: G | null;\r\n    _nodeDraw: DrawState | null;\r\n    _ws: WorkspaceSvg;\r\n    _svgElements: Element[];\r\n    _drawStates: DrawState[];\r\n    static get NODE_G_TAG() {\r\n        return 'AtlasNodeSVG';\r\n    }\r\n    static get ELEMENT_TAG() {\r\n        return 'AtlasElement'\r\n    }\r\n    static get CONN_LINE_TAG() {\r\n        return 'AtlasConnectionLine';\r\n    }\r\n    static get CONNECTOR_TAG() {\r\n        return 'AtlasConnectionBubble';\r\n    }\r\n    static get NAME() {\r\n        return 'atlas'; // default is called atlas.\r\n    }\r\n\r\n    constructor(workspace: WorkspaceSvg, overrides: Partial<RendererConstants> = {}) {\r\n        this._ws = workspace;\r\n        this._currentNode = null;\r\n        this._constants = new RendererConstants(overrides);\r\n        this._nodeGroup = null;\r\n        this._nodeDraw = null;\r\n        this._svgElements = [];\r\n        this._drawStates = [];\r\n    }\r\n    setConstants(c: Partial<RendererConstants> = {}) {\r\n        return Object.assign(this._constants, c);\r\n    }\r\n    get constants(): RendererConstants {\r\n        if (!this.node) return this._constants;\r\n\r\n        const { primary, secondary, tertiary, ...restColors } = this.node.colors;\r\n\r\n        return {\r\n            ...this._constants,\r\n            ...restColors\r\n        };\r\n    }\r\n\r\n    set constants(c: Partial<RendererConstants>) {\r\n        this.setConstants(c);\r\n    }\r\n    get node() {\r\n        return this._currentNode;\r\n    }\r\n    get svg(): Svg {\r\n        return this.getWs().svg; // Svg.js instance\r\n    }\r\n    get state(): null | undefined | DrawState {\r\n        return this._nodeDraw;\r\n    }\r\n    getWs() {\r\n        return this._ws;\r\n    }\r\n    getNodeBaseMeasurements() {\r\n        const c = this.constants;\r\n        return {\r\n            width: c.NODE_BASE_WIDTH,\r\n            height: c.NODE_BASE_HEIGHT\r\n        }\r\n    }\r\n    measureTextWidth(text: string, fontSize?: number, fontFamily?: string): number {\r\n        const c = this.constants;\r\n\r\n        // fallback in case SVG is not ready\r\n        if (!this.svg) return text.length * (fontSize ?? c.FONT_SIZE) * 0.6;\r\n\r\n        const txt = this.svg.text(text)\r\n            .font({\r\n                family: fontFamily ?? c.FONT_FAMILY,\r\n                size: fontSize ?? c.FONT_SIZE,\r\n                anchor: 'start'\r\n            })\r\n            .opacity(0); // hide it\r\n\r\n        const width = txt.bbox().width;\r\n        txt.remove(); // clean up\r\n        return width;\r\n    }\r\n\r\n\r\n    measureRawField(text: string = \"\") {\r\n        const c = this.constants;\r\n        const textW = this.measureTextWidth(text);\r\n        const width = Math.max(c.FIELD_RAW_BASE_WIDTH, textW + c.INPUT_BOX_PADDING * 2);\r\n        const height = c.FIELD_RAW_BASE_HEIGHT;\r\n        return { width, height };\r\n    }\r\n    measureField(field: AnyField) {\r\n        let width = 0, height = 0;\r\n        const c = this.constants;\r\n        if (field.getLabel()) {\r\n            width += field.getLabel().length * c.FONT_SIZE * 0.6;\r\n            height = Math.max(height, c.FONT_SIZE + 4);\r\n            // Calculate label stuff.\r\n        }\r\n\r\n        if (field.hasRaw()) {\r\n            const labelWidth = field.getLabel()\r\n                ? this.measureTextWidth(field.getLabel())\r\n                : 0;\r\n\r\n            const raw = this.measureRawField(field.getValue?.() ?? \"\");\r\n\r\n            width = labelWidth + c.LABEL_SPACING + raw.width;\r\n            height = Math.max(height, raw.height, c.FONT_SIZE + 4);\r\n        }\r\n\r\n\r\n        if (field.isCustomEditor()) {\r\n            // Fields with a custom look handle their own measurings.\r\n            const measurements = field.measureMyself();\r\n            if (measurements) {\r\n                width = Math.max(width, measurements.width as number);\r\n                height = Math.max(height, measurements.height as number);\r\n                if (field.getLabel()) {\r\n                    width += field.getLabel().length * c.FONT_SIZE * 0.6;\r\n                    width += c.LABEL_SPACING;\r\n                    height = Math.max(height, c.FONT_SIZE + 4);\r\n                    // Calculate label stuff.\r\n                }\r\n            }\r\n        }\r\n        return { width, height };\r\n    }\r\n    measureNodeDimensions() {\r\n        if (!this.node) return;\r\n\r\n        const c = this.constants;\r\n        const node: NodeSvg = this.node;\r\n        const fieldMeasurements: { width: number; height: number }[] = [];\r\n\r\n        const BASE = this.getNodeBaseMeasurements();\r\n        let totalWidth = BASE.width;\r\n        let totalHeight = BASE.height; // start at base\r\n        if (node.labelText) {\r\n            const labelW = this.measureTextWidth(node.labelText, c.FONT_SIZE, c.FONT_FAMILY);\r\n            totalWidth = Math.max(\r\n                totalWidth,\r\n                labelW + c.TOPBAR_LABEL_MARGIN_X * 2  // add left/right margin\r\n            );\r\n        }\r\n\r\n        let y = c.TOPBAR_HEIGHT + c.FIELD_SPACEY; // current y position for fields\r\n\r\n        for (let field of node.allFields()) {\r\n            let width = 0, height = 0;\r\n\r\n            const fldM = this.measureField(field);\r\n            width = fldM.width;\r\n            height = fldM.height;\r\n            // This adds to a list of all the like widths and heights for a field\r\n            fieldMeasurements.push(fldM);\r\n            totalWidth = Math.max(totalWidth, width + c.FIELD_MARGIN_X * 2);\r\n\r\n            // Check if this field goes beyond current totalHeight\r\n            const bottomOfField = y + height;\r\n            if (bottomOfField + c.FIELD_MARGIN_Y > totalHeight) {\r\n                totalHeight = bottomOfField + c.FIELD_MARGIN_Y; // grow node only if needed\r\n            }\r\n\r\n            y += height + c.FIELD_MARGIN_Y;\r\n        }\r\n        totalHeight += c.FOOTER_HEIGHT\r\n        return {\r\n            width: totalWidth,\r\n            height: totalHeight,\r\n            fields: fieldMeasurements\r\n        };\r\n    }\r\n    renderNode(nodeIdOrNode: NodeSvg | string) {\r\n        this.startNode(nodeIdOrNode);\r\n        this.drawNode();\r\n        this.storeState();\r\n    }\r\n    startNode(nodeIdOrNode: NodeSvg | string) {\r\n        const ws = this.getWs();\r\n        if (nodeIdOrNode instanceof NodeSvg) {\r\n            this._currentNode = nodeIdOrNode;\r\n        } else {\r\n            const node = ws.getNode(nodeIdOrNode);\r\n            if (node instanceof NodeSvg) {\r\n                this._currentNode = node;\r\n            } else {\r\n                this._currentNode = null;\r\n            }\r\n        }\r\n    }\r\n    storeState() {\r\n        this._drawStates.push(this.state as DrawState);\r\n    }\r\n    drawFieldRaw(fieldGroup: G, field: AnyField, startX: number = 0) {\r\n        const c = this.constants;\r\n        const value = field.getValue?.() ?? \"\";\r\n\r\n        const { width, height } = this.measureRawField(value);\r\n\r\n        const rect = fieldGroup.rect(width, height)\r\n            .fill(parseColor(c.FIELD_RAW_COLOR))\r\n            .stroke({ color: parseColor(c.FIELD_RAW_OUTLINE_COLOR), width: c.FIELD_RAW_OUTLINE_STROKE })\r\n            .radius(3);\r\n\r\n        const txt = fieldGroup.text(value)\r\n            .font({\r\n                family: c.FONT_FAMILY,\r\n                size: c.FONT_SIZE,\r\n                anchor: c.INPUT_BOX_TEXT_ANCHOR\r\n            })\r\n            .fill(parseColor(c.FIELD_RAW_TEXT_COLOR));\r\n        txt.node.style.userSelect = 'none';\r\n        const textBBox = txt.bbox();\r\n        const offsetY = (height - textBBox.height) / 2;\r\n\r\n        // move relative to startX (after label)\r\n        rect.move(startX, 0);\r\n        txt.move(startX + c.INPUT_BOX_PADDING, offsetY);\r\n        eventer.addElement(rect, \"k_inputbox\", {\r\n            field,      // the field object that has .getValue() and .setValue(v)\r\n            text: txt,       // the svg.js Text element you drew\r\n            renderer: this,   // the renderer instance, must have .measureRawField and .constants\r\n            startX   // x-offset where the box should start (after label)\r\n        }).tagElement(rect, [(this.constructor as typeof Renderer).ELEMENT_TAG])\r\n\r\n        return { rect, txt };\r\n    }\r\n\r\n\r\n\r\n    drawFieldLabel(fieldGroup: G, field: AnyField, startX: number = 0): number {\r\n        const c = this.constants;\r\n        const label = field.getLabel?.();\r\n        if (!label) return 0;\r\n\r\n        const txt = fieldGroup.text(label)\r\n            .font({\r\n                family: c.FONT_FAMILY,\r\n                size: c.FONT_SIZE,\r\n                anchor: 'start'\r\n            })\r\n            .fill(parseColor(c.FONT_COLOR));\r\n        txt.node.style.userSelect = 'none';\r\n        const bbox = txt.bbox();\r\n        const offsetY = (Math.max(c.FIELD_RAW_BASE_HEIGHT, bbox.height) - bbox.height) / 2;\r\n\r\n        // move label relative to startX\r\n        txt.move(startX, offsetY);\r\n\r\n        // return width used for next element\r\n        return bbox.width + c.LABEL_SPACING;\r\n    }\r\n\r\n    drawNodeXButton() {\r\n        const node = this.node;\r\n        const state = this._nodeDraw;\r\n        if (!node || !state || !state.topbar || !state.group) return;\r\n\r\n        const c = this.constants;\r\n\r\n        const measurements = this.measureNodeDimensions();\r\n        const width = measurements?.width ?? c.NODE_BASE_WIDTH;\r\n\r\n        const btnSize = c.TOPBAR_HEIGHT * 0.6;\r\n        const padding = (c.TOPBAR_HEIGHT - btnSize) / 2;\r\n\r\n        // Button group\r\n        const xGroup = state.group.group().attr({ class: 'node-x-clse' });\r\n        eventer.addElement(xGroup, 'k_closenode', {\r\n            workspace: this.getWs(),\r\n            node\r\n        })\r\n        // Background\r\n        xGroup.rect(btnSize, btnSize)\r\n            .fill('#ffffff00')\r\n            .radius(2)\r\n            .move(width - btnSize - padding, padding);\r\n\r\n        // X mark\r\n        const txt = xGroup.text('')\r\n            .font({\r\n                family: c.FONT_FAMILY,\r\n                size: btnSize * 0.8,\r\n                weight: 'bold',\r\n                anchor: 'middle'\r\n            })\r\n            .fill('#fff')\r\n            .attr({\r\n                'text-anchor': 'middle',        // horizontal centering\r\n                'dominant-baseline': 'middle'   // vertical centering\r\n            });\r\n        txt.node.style.userSelect = 'none';\r\n        // Apply transform to center it inside the button\r\n        txt.transform({\r\n            translateX: width - btnSize / 2 - padding,\r\n            translateY: padding + btnSize / 2\r\n        });\r\n\r\n        state.xButton = xGroup;\r\n    }\r\n\r\n    drawConnector(nodeGroup: G, nodeBg: SvgPath, y: number, side: 'left' | 'right', color: string): SvgPath | void | undefined | null {\r\n        const c = this.constants;\r\n        if (!nodeGroup || !nodeBg) return null;\r\n\r\n        const bbox = nodeBg.bbox(); // get dimensions of the background\r\n        const group = nodeGroup;     // attach connector to top-level node group\r\n        const x = side === 'left' ? 0 : bbox.width;\r\n\r\n        if (c.CONNECTOR_TRIANGLE) {\r\n            // small triangle connector\r\n            const triSize = c.CONNECTOR_TRI_SIZE;\r\n            let path = Path.roundedTri(triSize, triSize, 1);\r\n\r\n            // flip triangle horizontally for left side\r\n            if (side === 'left') path = Path.rotatePath(path, 180, triSize / 2, triSize / 2);\r\n\r\n            const tri = group.path(path)\r\n                .fill(parseColor(color as Hex))\r\n                .stroke({ color: parseColor('#00000000'), width: 0 });\r\n            tri.attr({\r\n                class: (this.constructor as typeof Renderer).CONNECTOR_TAG\r\n            })\r\n            const offsetX = side === 'left' ? -triSize : 0;\r\n            tri.transform({ translateX: x + offsetX, translateY: y - triSize / 2 });\r\n\r\n            return tri;\r\n        } else {\r\n            // circle connector\r\n            const radius = c.CONNECTOR_RADIUS;\r\n            const circlePath = Path.circle(radius);\r\n\r\n            const circ = group.path(circlePath)\r\n                .fill(parseColor(color as Hex))\r\n                .stroke({ color: parseColor('#00000000'), width: 0 })\r\n                .move(x - radius, y - radius); // center circle at (x, y)\r\n            circ.attr({\r\n                class: (this.constructor as typeof Renderer).CONNECTOR_TAG\r\n            })\r\n            return circ;\r\n        }\r\n    }\r\n\r\n\r\n    drawNodeLabel(nodeGroup: G) {\r\n        const node = this.node;\r\n        const c = this.constants;\r\n        if (!node) return;\r\n\r\n        if (node.labelText) {\r\n            const txt = nodeGroup.text(node.labelText)\r\n                .font({\r\n                    family: c.FONT_FAMILY,\r\n                    size: c.FONT_SIZE,\r\n                    anchor: 'start',\r\n                    weight: c.TOPBAR_LABEL_BOLDED ? '600' : 'normal'\r\n                })\r\n                .fill(parseColor(c.FONT_COLOR));\r\n\r\n            txt.node.style.userSelect = 'none';\r\n\r\n            const bbox = txt.bbox();\r\n            const offsetY = (c.TOPBAR_HEIGHT - bbox.height) / 2;\r\n\r\n            txt.move(c.TOPBAR_LABEL_MARGIN_X, offsetY + c.TOPBAR_LABEL_MARGIN_Y);\r\n        }\r\n    }\r\n    resolveConnectable(connectable: Connectable, fromConn: Connection): Connection | null | undefined {\r\n        if (!connectable || !fromConn) return undefined;\r\n\r\n        // If the connection is an input (previous), return the connectable's output (next) connection\r\n        if (fromConn.isPrevious) {\r\n\r\n            if (connectable instanceof NodeSvg) return connectable.nextConnection;\r\n            // @ts-ignore\r\n            if (connectable instanceof Field) return connectable.connection;\r\n        }\r\n\r\n        // If the connection is an output (next), return the connectable's input (previous) connection\r\n        if (!fromConn.isPrevious) {\r\n            if (connectable instanceof NodeSvg) return connectable.previousConnection;\r\n            // @ts-ignore\r\n            if (connectable instanceof Field) return connectable.connection;\r\n        }\r\n    }\r\n    private _fillOtherNodeConnectorCircle(conn: Connection, circle: SvgPath, isPrevious: boolean) {\r\n        for (const state of this._drawStates) {\r\n            for (const connPair of state.connectorsAwaitingConnection) {\r\n                // Check if this connector is referenced in another node's connector\r\n                if (isPrevious && connPair.to === conn && !connPair.toCircle) {\r\n                    connPair.toCircle = circle;\r\n                }\r\n                if (!isPrevious && connPair.from === conn && !connPair.fromCircle) {\r\n                    connPair.fromCircle = circle;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    refreshNodeTransforms() {\r\n        const nodeGroups: List<G> = this.svg.find(`.${(this.constructor as typeof Renderer).NODE_G_TAG}`) as List<G>;\r\n        for (let nodeG of nodeGroups) {\r\n            const node: NodeSvg | undefined = this.getWs().getNode(unescapeAttr(nodeG.attr('data-node-id')));\r\n            console.log(node);\r\n            if (!node) continue;\r\n            const screenPos = this._ws.workspaceToScreen(\r\n                node.relativeCoords.x,\r\n                node.relativeCoords.y\r\n            );\r\n            nodeG.attr({ transform: `translate(${screenPos.x}, ${screenPos.y})` });\r\n        }\r\n        this.refreshConnectionLines();\r\n    }\r\n    refreshConnectionLines() {\r\n        this.clearLines();\r\n        this.drawLinesForAllNodes();\r\n    }\r\n    drawNode() {\r\n        if (!this.node) return;\r\n\r\n        const node: NodeSvg = this.node;\r\n        const c = this.constants;\r\n        const colors: ColorStyle = node.colors ?? {\r\n            primary: '#000',\r\n            secondary: '#000',\r\n            tertirary: '#000',\r\n            category: ''\r\n        };\r\n\r\n        // Main node group\r\n        const nodeGroup = this.svg.group().attr({ 'data-node-id': escapeAttr(node.id), 'class': (this.constructor as typeof Renderer).NODE_G_TAG });\r\n        // compute screen position from workspace-space relativeCoords\r\n        const screenPos = this._ws.workspaceToScreen(\r\n            node.relativeCoords.x,\r\n            node.relativeCoords.y\r\n        );\r\n\r\n        // apply it to the top-level node group\r\n        nodeGroup.attr({ transform: `translate(${screenPos.x}, ${screenPos.y})` });\r\n\r\n        const state = drawState(nodeGroup, node.id);\r\n        this._nodeDraw = state;\r\n\r\n        // Measure node\r\n        const measurements = this.measureNodeDimensions();\r\n        const width = measurements?.width ?? c.NODE_BASE_WIDTH;\r\n        const height = measurements?.height ?? c.NODE_BASE_HEIGHT;\r\n\r\n        // Base rectangle\r\n        const radius = c.CORNER_RADIUS;\r\n        state.bg = nodeGroup.path(Path.roundedRect(width, height, radius))\r\n            .fill(parseColor(c.NODE_BG_COLOR))\r\n            .stroke({ color: parseColor(c.NODE_OUTLINE_COLOR), width: 2 } as StrokeData);\r\n\r\n        // Topbar\r\n        state.topbar = nodeGroup.path(Path.roundedRect(width, c.TOPBAR_HEIGHT, radius))\r\n            .fill(parseColor(colors.primary))\r\n            .stroke({ color: parseColor(colors.tertiary), width: 2 } as StrokeData);\r\n\r\n        // add the X button\r\n        this.drawNodeXButton();\r\n        this.drawNodeLabel(nodeGroup);\r\n        eventer.addElement(nodeGroup, 'k_draggable', {\r\n            dragel: state.topbar, // the handle\r\n            node: node,     // NodeSvg instance\r\n            type: 2\r\n        }).tagElement(nodeGroup, [(this.constructor as typeof Renderer).ELEMENT_TAG]);\r\n        // Outer fields group positioned under topbar using transform\r\n        const fieldsGroup = nodeGroup.group();\r\n        fieldsGroup.attr({ transform: `translate(0, ${c.TOPBAR_HEIGHT + c.FIELD_SPACEY})` });\r\n        state.fieldCol = fieldsGroup;\r\n\r\n\r\n        let y = 0;\r\n        node.allFields().forEach((field, idx) => {\r\n            const fm = measurements?.fields[idx];\r\n            if (!fm) return;\r\n\r\n            // default left alignment\r\n            let alignX = c.FIELD_MARGIN_X;\r\n\r\n            const fieldGroup = fieldsGroup.group();\r\n            fieldGroup.attr({ transform: `translate(${alignX}, ${y})` });\r\n\r\n            state.fieldPosY = y;\r\n\r\n            // draw label first, get its used width\r\n            const xUsed = this.drawFieldLabel(fieldGroup, field);\r\n\r\n            // if raw, draw right after label\r\n            if (field.hasRaw()) {\r\n                this.drawFieldRaw(fieldGroup, field, xUsed);\r\n            }\r\n\r\n            y += fm.height + c.FIELD_MARGIN_Y;\r\n        });\r\n\r\n        state.fieldPosY = y;\r\n\r\n        /**\r\n         * Draw connectors.\r\n         */\r\n        const bbox = state.bg?.bbox();\r\n        const cY = (bbox?.height ?? height) - c.FOOTER_HEIGHT;\r\n\r\n        // Previous connection (left)\r\n        if (node.previousConnection) {\r\n            const c1 = this.drawConnector(nodeGroup, state.bg, cY, 'left', colors.primary as string);\r\n            if (c1) {\r\n                state.connectorsAwaitingConnection.push({\r\n                    from: node.previousConnection,\r\n                    to: this.resolveConnectable(node.previousConnection.getFrom(), node.previousConnection) as Connection,\r\n                    fromCircle: c1 as SvgPath\r\n                });\r\n\r\n                // fill any waiting connectors from other nodes\r\n                this._fillOtherNodeConnectorCircle(node.previousConnection, c1 as SvgPath, true);\r\n            }\r\n        }\r\n\r\n        // Next connection (right)\r\n        if (node.nextConnection) {\r\n            const c2 = this.drawConnector(nodeGroup, state.bg, cY, 'right', colors.primary as string);\r\n            if (c2) {\r\n                state.connectorsAwaitingConnection.push({\r\n                    from: node.nextConnection,\r\n                    to: this.resolveConnectable(node.nextConnection.getTo(), node.nextConnection) as Connection,\r\n                    fromCircle: c2 as SvgPath\r\n                });\r\n\r\n                // fill any waiting connectors from other nodes\r\n                this._fillOtherNodeConnectorCircle(node.nextConnection, c2 as SvgPath, false);\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    drawLinesForAllNodes() {\r\n        const c = this.constants;\r\n        const wsSvg = this._ws.svg;\r\n\r\n\r\n        for (const state of (this as any)._drawStates) {\r\n            if (!state.connectorsAwaitingConnection) continue;\r\n            for (const { fromCircle, toCircle } of state.connectorsAwaitingConnection) {\r\n                if (!fromCircle || !toCircle) continue;\r\n\r\n                const a = fromCircle.rbox();\r\n                const b = toCircle.rbox();\r\n                const startX = a.cx, startY = a.cy;\r\n                const endX = b.cx, endY = b.cy;\r\n\r\n                if (c.CONNECTOR_LINE_CURVED) {\r\n                    // cubic bezier: control points spread horizontally\r\n                    const dx = Math.abs(endX - startX);\r\n                    const cp1x = startX + Math.sign(endX - startX) * Math.max(30, dx * 0.3);\r\n                    const cp2x = endX - Math.sign(endX - startX) * Math.max(30, dx * 0.3);\r\n                    const pathStr = `M ${startX} ${startY} C ${cp1x} ${startY}, ${cp2x} ${endY}, ${endX} ${endY}`;\r\n                    const line = wsSvg.path(pathStr)\r\n                        .stroke({ color: parseColor(fromCircle.fill() as Color), width: c.CONNECTOR_LINE_WIDTH })\r\n                        .fill('none')\r\n                        .attr({ class: (this.constructor as typeof Renderer).CONN_LINE_TAG });\r\n                    (this as any)._svgElements.push(line);\r\n                } else {\r\n                    // fallback straight line\r\n                    const pathStr = `M ${startX} ${startY} L ${endX} ${endY}`;\r\n                    const line = wsSvg.path(pathStr)\r\n                        .stroke({ color: parseColor(fromCircle.fill() as Color), width: c.CONNECTOR_LINE_WIDTH })\r\n                        .fill('none')\r\n                        .attr({ class: (this.constructor as typeof Renderer).CONN_LINE_TAG });\r\n                    (this as any)._svgElements.push(line);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    clearLines() {\r\n        for (let line of this.getWs().svg.find(`.${(this.constructor as typeof Renderer).CONN_LINE_TAG}`)) {\r\n            line.remove();\r\n        }\r\n    }\r\n\r\n    clearScreen() {\r\n        eventer.destroyByTag((this.constructor as typeof Renderer).ELEMENT_TAG)\r\n        this._ws.svg.clear();\r\n        this._drawStates = [];\r\n    }\r\n}\r\n\r\nexport default Renderer;\r\n","import { Color, ColorStyle } from \"./visual-types\"\r\n\r\n\r\nconst CategoryColors: {\r\n    [key: string]: ColorStyle\r\n} = {};\r\n\r\nexport default CategoryColors;","import Field from \"./field\";\r\nimport NodeSvg from \"./nodesvg\";\r\nexport type Connectable = NodeSvg | null | Field;\r\nclass Connection {\r\n    from: Connectable;\r\n    to: Connectable;\r\n    isPrevious: boolean;\r\n    constructor(from: Connectable, to: Connectable, isPrevious: boolean = false) {\r\n        this.from = from;\r\n        this.to = to;\r\n        this.isPrevious = isPrevious;\r\n    }\r\n\r\n    getTo(): Connectable {\r\n        return this.to;\r\n    }\r\n    getFrom(): Connectable {\r\n        return this.from;\r\n    }\r\n    disconnectTo() {\r\n        if (this.to instanceof NodeSvg) {\r\n            this.to.previousConnection?.disconnectFrom();\r\n        }\r\n        this.to = null;\r\n    }\r\n    disconnectFrom() {\r\n        this.from = null;\r\n    }\r\n    isolate() {\r\n        this.from = null as any;\r\n        this.to = null as any;\r\n    }\r\n}\r\nexport default Connection;","import WorkspaceController from \"../controllers/base\";\r\nimport unescapeAttr from \"../util/unescape-html\";\r\nimport Coordinates from \"./coordinates\";\r\nimport ContextOptsRegistry from \"./ctx-menu-registry\";\r\nimport NodeSvg from \"./nodesvg\";\r\nimport Widget from \"./widget\";\r\nimport WorkspaceSvg from \"./workspace-svg\";\r\n\r\nexport type Showable = 'node' | 'ws' | 'html';\r\nexport interface ContextMenuOpts {\r\n    click: (target: NodeSvg | WorkspaceSvg | HTMLElement) => void;\r\n    onHoverStart?: () => void;\r\n    onHoverEnd?: () => void;\r\n    showFor?: Showable | Showable[]\r\n    label: string;\r\n    id: string;\r\n}\r\nclass ContextMenuHTML {\r\n    workspace: WorkspaceSvg;\r\n    controller: WorkspaceController;\r\n    widget: Widget;\r\n    options: ContextMenuOpts[];\r\n\r\n    constructor(workspace: WorkspaceSvg) {\r\n        this.workspace = workspace;\r\n        this.controller = this.workspace.controller;\r\n        this.widget = new Widget(this.workspace, {\r\n            coords: new Coordinates(0, 0),\r\n            name: 'k_contextmenu',\r\n            className: 'KabelContextMenu'\r\n        });\r\n        this.widget.show = () => {\r\n            this.widget.container.classList.add('show');\r\n            this.widget.container.style.display = 'flex';\r\n            this.widget.visible = true;\r\n        };\r\n\r\n        this.widget.hide = () => {\r\n            this.widget.container.classList.remove('show');\r\n            this.widget.container.style.display = 'none';\r\n            this.widget.visible = false;\r\n        };\r\n        this.widget.container.style.removeProperty('height');\r\n        this.widget.container.style.removeProperty('width');\r\n\r\n        this.widget.hide();\r\n        this.options = ContextOptsRegistry;\r\n        this.initListeners();\r\n    }\r\n\r\n    renderOptions(target: NodeSvg | WorkspaceSvg | HTMLElement | null) {\r\n        // Clear any previous options\r\n        this.widget.container.innerHTML = '';\r\n\r\n        // Filter options based on showFor\r\n        const filteredOptions = this.options.filter(opt => {\r\n            if (!target) return false;\r\n            const showFor = Array.isArray(opt.showFor) ? opt.showFor : [opt.showFor];\r\n\r\n            if (target instanceof NodeSvg && showFor.includes('node')) return true;\r\n            if (target instanceof WorkspaceSvg && showFor.includes('ws')) return true;\r\n            if (target instanceof HTMLElement && !(target instanceof SVGSVGElement) && showFor.includes('html')) return true;\r\n\r\n            return false;\r\n        });\r\n\r\n        filteredOptions.forEach((opt, i) => {\r\n            const el = document.createElement('div');\r\n            el.className = 'KabelContextOption';\r\n            el.textContent = opt.label || 'Option ' + i;\r\n\r\n            el.addEventListener('click', () => {\r\n                if (target) opt.click(target);\r\n                this.hide();\r\n            });\r\n\r\n            if (opt.onHoverStart) el.addEventListener('mouseenter', () => opt.onHoverStart?.());\r\n            if (opt.onHoverEnd) el.addEventListener('mouseleave', () => opt.onHoverEnd?.());\r\n\r\n            this.widget.container.appendChild(el);\r\n        });\r\n    }\r\n\r\n    initListeners() {\r\n        // Show the menu on right-click\r\n        this.workspace.svg.node.addEventListener('contextmenu', e => {\r\n            e.preventDefault();\r\n            const mouseX = e.clientX;\r\n            const mouseY = e.clientY;\r\n\r\n            this.widget.setCoords(new Coordinates(mouseX, mouseY));\r\n            this.renderOptions(this.target);\r\n            this.widget.show();\r\n        });\r\n\r\n        // Hide menu on click elsewhere\r\n        document.addEventListener('mousedown', e => {\r\n            if (!this.widget.container.contains(e.target as Node)) {\r\n                this.hide();\r\n            }\r\n        });\r\n    }\r\n\r\n    hide() {\r\n        this.widget.hide();\r\n    }\r\n\r\n    get mousePos(): { x: number, y: number } {\r\n        return this.controller.mousePos;\r\n    }\r\n\r\n    get target(): NodeSvg | WorkspaceSvg | HTMLElement | null {\r\n        let el = document.elementFromPoint(this.mousePos.x, this.mousePos.y) as HTMLElement | null;\r\n\r\n        if ((el as unknown as SVGSVGElement) === this.workspace.svg.node) return this.workspace;\r\n\r\n        while (el && el !== document.body) {\r\n            // Node check\r\n            if (el.tagName.toLowerCase() === 'g' && el.hasAttribute('data-node-id')) {\r\n                const nodeId = unescapeAttr(el.getAttribute('data-node-id') as string);\r\n                const node = this.workspace.getNode(nodeId);\r\n                if (node) return node;\r\n            }\r\n            el = el.parentElement;\r\n        }\r\n\r\n        // fallback\r\n        return document.elementFromPoint(this.mousePos.x, this.mousePos.y) as HTMLElement | null;\r\n    }\r\n}\r\n\r\nexport default ContextMenuHTML;","class Coordinates {\r\n    x: number;\r\n    y: number;\r\n\r\n    constructor(x: number = 0, y: number = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    /** Set coordinates */\r\n    set(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    /** Returns a copy of this coordinate */\r\n    clone(): Coordinates {\r\n        return new Coordinates(this.x, this.y);\r\n    }\r\n\r\n    /** Calculate distance to another coordinate */\r\n    distanceTo(other: Coordinates): number {\r\n        const dx = this.x - other.x;\r\n        const dy = this.y - other.y;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    /** Convert to string */\r\n    toString(): string {\r\n        return `(${this.x}, ${this.y})`;\r\n    }\r\n\r\n    /** Convert to array [x, y] */\r\n    toArray(): [number, number] {\r\n        return [this.x, this.y];\r\n    }\r\n\r\n    /** Convert to object { x, y } */\r\n    toObject(): { x: number; y: number } {\r\n        return { x: this.x, y: this.y };\r\n    }\r\n}\r\nexport default Coordinates;","import RendererConstants from \"../renderers/constants\";\r\nimport Renderer from \"../renderers/renderer\";\r\nimport CategoryColors from \"./colors\";\r\nimport Connection, {Connectable} from \"./connection\";\r\nimport Coordinates from \"./coordinates\";\r\nimport Field, { FieldOptions, FieldVisualInfo, AnyFieldCls, AnyField, DummyField, FieldMap, NumberField, OptConnectField, TextField } from \"./field\";\r\nimport inject, { InjectMsg, InjectOptions } from \"./inject\";\r\nimport { clearMainWorkspace, getMainWorkspace, setMainWorkspace } from \"./main-workspace\";\r\nimport NodeSvg, {NodeJson, NodeEvents, InputFieldJson} from \"./nodesvg\";\r\nimport NodePrototypes from \"./prototypes\";\r\nimport WorkspaceSvg from \"./workspace-svg\";\r\nimport { NodePrototype } from \"./node-types\";\r\nimport { Color, ColorStyle, Hex, RGBObject, RGBString, RGBTuple } from \"./visual-types\";\r\nimport { parseColor } from \"../util/parse-color\";\r\nimport eventer, {Eventer} from \"../util/eventer\";\r\nimport * as Path from '../util/path';\r\nimport * as SVG from '@svgdotjs/svg.js';\r\nimport * as UID from '../util/uid';\r\nimport hasProp from \"../util/has-prop\";\r\nimport EventEmitter from \"../util/emitter\";\r\nimport userState from '../util/user-state';\r\nimport '../events/events'\r\nimport WorkspaceController from \"../controllers/base\";\r\nimport WASDController from \"../controllers/wasd\";\r\nimport { RMap } from \"./renderer-map\";\r\nimport styler, { Styler } from \"../util/styler\";\r\nimport WidgetPrototypes from \"./widget-prototypes\";\r\nimport Widget from \"./widget\";\r\nimport ContextOptsRegistry, {ContextMenu} from \"./ctx-menu-registry\";\r\nimport { Showable } from \"./context-menu\";\r\nField.register = function (name: string, cls: Function) {\r\n    FieldMap[name] = cls as AnyFieldCls;\r\n}\r\nField.unregister = function (name: string) {\r\n    delete FieldMap[name];\r\n}\r\n\r\n\r\nconst Kabel = {\r\n    UIX: {\r\n        events: eventer as Eventer,\r\n        /**\r\n         * State Manager, Makes things possible: E.G (the 'typing' state when you type in a input box..)\r\n         * Used in controllers so you dont move when typing characters like a w s or d etc.\r\n         */\r\n        userState\r\n    },\r\n    ContextMenu,\r\n    Utils: {\r\n        Path,\r\n        SVG,\r\n        parseColor,\r\n        UID,\r\n        EventEmitter,\r\n        hasProp,\r\n        styler,\r\n        Styler\r\n    },\r\n    Widget,\r\n    CategoryColors,\r\n    Connection,\r\n    Coordinates,\r\n    Field,\r\n    DummyField,\r\n    FieldMap,\r\n    NumberField,\r\n    OptConnectField,\r\n    TextField,\r\n    inject,\r\n    InjectMsg,\r\n    clearMainWorkspace,\r\n    getMainWorkspace,\r\n    setMainWorkspace,\r\n    NodeSvg,\r\n    Nodes: NodePrototypes,\r\n    Widgets: WidgetPrototypes,\r\n    WorkspaceSvg,\r\n    WorkspaceController,\r\n    WASDController,\r\n    nodeRendering: {\r\n        rendererMap: RMap,\r\n        Renderer,\r\n        RendererConstants\r\n    }\r\n};\r\n// Export a getter/setter incase someone needs more internal access to main workspace and doesnt like the method interface.\r\nObject.defineProperty(Kabel, '_mainWorkspace', {\r\n    get(): WorkspaceSvg|null {\r\n        return getMainWorkspace();\r\n    },\r\n    set(v: WorkspaceSvg|undefined|null|false|0|string) {\r\n        if (v === undefined || v === null || v === false || v === 0 || typeof v === 'string') {\r\n            return clearMainWorkspace();\r\n        }\r\n        return setMainWorkspace(v);\r\n    }\r\n})\r\n\r\nexport default Kabel;","import { ContextMenuOpts, Showable } from \"./context-menu\";\r\nimport NodeSvg from \"./nodesvg\";\r\nimport WorkspaceSvg from \"./workspace-svg\";\r\n\r\n\r\nconst ContextOptsRegistry: ContextMenuOpts[] = [];\r\n\r\nconst ContextMenu = {\r\n    registerOption(id: string, option: {\r\n        click: (target: NodeSvg | WorkspaceSvg | HTMLElement) => void;\r\n        onHoverStart?: () => void;\r\n        onHoverEnd?: () => void;\r\n        label: string;\r\n        showFor: Showable | Showable[];\r\n    }) {\r\n        const opt = {\r\n            id,\r\n            click: option.click,\r\n            label: option.label,\r\n            onHoverStart: option.onHoverStart || (() => { }),\r\n            onHoverEnd: option.onHoverEnd || (() => { }),\r\n            showFor: option.showFor || undefined\r\n        };\r\n        ContextOptsRegistry.push(opt);\r\n    },\r\n\r\n    unregisterOption(id: string) {\r\n        const index = ContextOptsRegistry.findIndex(opt => opt.id === id);\r\n        if (index >= 0) ContextOptsRegistry.splice(index, 1);\r\n    }\r\n};\r\n\r\nContextMenu.registerOption('k_delete', {\r\n    showFor: ['node'],\r\n    label: 'Delete', // required\r\n    click: (t) => {\r\n        const target = t as NodeSvg;\r\n        if (!target.workspace) return;\r\n        target.workspace.removeNode(target);\r\n    }\r\n});\r\nContextMenu.registerOption('k_deleteall', {\r\n    showFor: 'ws',\r\n    label: 'Delete all', // required\r\n    click: (t) => {\r\n        const target = t as WorkspaceSvg;\r\n        const isSure = window.confirm(`Are you sure you want to delete ${Array.from(target._nodeDB.keys()).length} nodes?`);\r\n        if (!isSure) return;\r\n        for (let [id, _] of target._nodeDB) {\r\n            target.removeNodeById(id);\r\n        }\r\n    }\r\n})\r\nContextMenu.registerOption('k_duplicate', {\r\n\tshowFor: 'node',\r\n\tlabel: 'Duplicate',\r\n\tclick: t => {\r\n\t\tconst node = t as NodeSvg;\r\n\t\tif (!node.workspace) return;\r\n\t\tnode.workspace.cloneNode(node);\r\n\t}\r\n});\r\n\r\nexport { ContextMenu }\r\nexport default ContextOptsRegistry;","import Connection from \"./connection\";\r\nimport { G, Rect, Svg, SVG } from '@svgdotjs/svg.js';\r\n/**\r\n * Options used to initialize a Field.\r\n */\r\nexport interface FieldOptions {    /** Name of the field */\r\n    name: string;\r\n    /** Human-readable label for the field */\r\n    label: string;\r\n    /** Key used to identify the field type in FieldTypesMap */\r\n    type: string;\r\n    /** Field value (optional) */\r\n    value?: any;\r\n    /** Only used by OptConnectField to determine internal value type */\r\n    fld_type?: \"number\" | \"string\";\r\n    [key: string]: any;\r\n};\r\n\r\nexport interface FieldVisualInfo {\r\n    measuredWidth: number; // The width approximated by renderer\r\n    measuredHeight: number; // The height approximated by renderer\r\n    background: Rect; // The node's background element.\r\n    svg: Svg; // The workspace's SVG.js svg\r\n    nodeGroup: G; // Group for the node\r\n    fieldGroup: G; // A group containing the label & input.\r\n}\r\n/**\r\n * Base class for all fields.\r\n * @template T The type of the value stored in the field\r\n */\r\nclass Field<T = any> {\r\n    label: string;\r\n    name: string;\r\n    type: string;\r\n    protected value: T | null;\r\n    static register(name: string, cls: Function) {};\r\n    static unregister(name: string) {};\r\n    constructor() {\r\n        this.label = '';\r\n        this.name = '';\r\n        this.type = '';\r\n        this.value = null;\r\n    }\r\n    /**\r\n     * Set field name to something else.\r\n     * @param name string\r\n     * @returns the new name.\r\n     */\r\n    setName(name: string) {\r\n        return this.name = name;\r\n    }\r\n    /**\r\n     * Initialize the field from JSON options.\r\n     * @param json FieldOptions object\r\n     */\r\n    fromJson(json: FieldOptions) {\r\n        if (json.name!== undefined) this.name = json.name;\r\n        if (json.label !== undefined) this.label = json.label;\r\n        if (json.type !== undefined) this.type = json.type;\r\n        if (json.value !== undefined) this.value = json.value;\r\n    }\r\n\r\n    /** @returns The field's name/key */\r\n    getName(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /** @returns The human-readable label */\r\n    getLabel(): string {\r\n        return this.label;\r\n    }\r\n\r\n    /**\r\n     * Set the human-readable label\r\n     * @param label New label\r\n     * @returns The updated label\r\n     */\r\n    setLabel(label: string): string {\r\n        return this.label = label;\r\n    }\r\n\r\n    /** @returns Whether this field is a raw value field (text/number) */\r\n    hasRaw(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** @returns Whether this field supports connections */\r\n    hasConnectable(): boolean {\r\n        return false;\r\n    }\r\n    /** @returns Whether we have a custom editor/input look */\r\n    isCustomEditor(): boolean {\r\n        return false;\r\n    }\r\n    /**\r\n     * Make the input's custom look.\r\n     * @param fieldVisualInfo - The visual info of the field, mutate this if needed.\r\n     */\r\n    makeInputMain(fieldVisualInfo: FieldVisualInfo) {\r\n        return;\r\n    }\r\n    /** Return width & height of your field's custom editor */\r\n    measureMyself() {\r\n        return { width: null, height: null }; // if either is null then the renderer measures for us (meaning we have a connection or other type of raw field.)\r\n    }\r\n    /** @returns The stored value */\r\n    getValue(): T | null {\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * Set the stored value\r\n     * @param val New value\r\n     */\r\n    setValue(val: T) {\r\n        this.value = val;\r\n    }\r\n\r\n    /** @returns The value as it should be displayed (can differ from internal value) */\r\n    getDisplayValue(): T | null {\r\n        return this.getValue();\r\n    }\r\n}\r\n/**\r\n * Used when you want just a label with no actual value. Any value related methods are no-op.\r\n */\r\nexport class DummyField {\r\n    label: string;\r\n    name: string;\r\n    type: string;\r\n\r\n    constructor() {\r\n        this.label = '';\r\n        this.name = '';\r\n        this.type = '';\r\n    }\r\n    /**\r\n     * Set field name to something else.\r\n     * @param name string\r\n     * @returns the new name.\r\n     */\r\n    setName(name: string) {\r\n        return this.name = name;\r\n    }\r\n    /**\r\n     * Initialize the field from JSON options.\r\n     * @param json FieldOptions object\r\n     */\r\n    fromJson(json: FieldOptions) {\r\n        if (json.name!== undefined) this.name = json.name;\r\n        if (json.label !== undefined) this.label = json.label;\r\n        if (json.type !== undefined) this.type = json.type;\r\n    }\r\n    /** @returns Whether this field is a raw value field (text/number) */\r\n    hasRaw(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @returns Whether this field supports connections */\r\n    hasConnectable(): boolean {\r\n        return false;\r\n    }\r\n    /** @returns The field's name/key */\r\n    getName(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /** @returns The human-readable label */\r\n    getLabel(): string {\r\n        return this.label;\r\n    }\r\n    /**\r\n     * Set the human-readable label\r\n     * @param label New label\r\n     * @returns The updated label\r\n     */\r\n    setLabel(label: string): string {\r\n        return this.label = label;\r\n    }\r\n    /** @returns Whether we have a custom editor/input look */\r\n    isCustomEditor(): boolean {\r\n        return false;\r\n    }\r\n    /**\r\n     * Make the input.\r\n     * @param fieldVisualInfo - The visual info of the field, mutate this if needed.\r\n     */\r\n    makeInputMain(fieldVisualInfo: FieldVisualInfo) {\r\n        return;\r\n    }\r\n    /** Return width & height of your field's custom editor */\r\n    measureMyself() {\r\n        return { width: 0, height: 0 }; // if either is null then the renderer measures for us (meaning we have a connection or other type of raw field.)\r\n    }\r\n    /**\r\n     * Dummy fields have no value.\r\n     * @returns {null}\r\n     */\r\n    getValue() {\r\n        return null;\r\n    }\r\n    /**\r\n     * No-op for dummy fields\r\n     */\r\n    setValue(_: any) { }\r\n    /** @returns The value as it should be displayed (can differ from internal value) */\r\n    getDisplayValue() {\r\n        return this.getValue();\r\n    }\r\n\r\n}\r\n/**\r\n * Base class for fields that can be connected to other fields.\r\n * @template T The type of the value stored in the field\r\n */\r\nexport class ConnectableField<T = any> extends Field<T> {\r\n    connection: Connection;\r\n\r\n    constructor() {\r\n        super();\r\n        this.connection = new Connection(this, null);\r\n    }\r\n\r\n    hasConnectable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    hasRaw(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** Disconnect this field from any connected field */\r\n    disconnect() {\r\n        this.connection.disconnectTo();\r\n    }\r\n}\r\n\r\n/** Field storing a numeric value */\r\nexport class NumberField extends Field<number> {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    setValue(val: number) {\r\n        this.value = Number(val);\r\n    }\r\n}\r\n\r\n/** Field storing a string value */\r\nexport class TextField extends Field<string> {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    setValue(val: string) {\r\n        this.value = String(val);\r\n    }\r\n}\r\n\r\n/**\r\n * Optional connectable field.\r\n * Can store either a number or string depending on fld_type.\r\n */\r\nexport class OptConnectField extends ConnectableField<number | string> {\r\n    fldType: \"number\" | \"string\";\r\n\r\n    constructor() {\r\n        super();\r\n        this.fldType = \"string\";\r\n    }\r\n    /**\r\n     * Set field type.\r\n     * @param type \"number\"|\"string\"\r\n     */\r\n    setFieldType(type: \"number\" | \"string\") {\r\n        this.fldType = type;\r\n    }\r\n    /**\r\n     * Initialize from JSON, respecting fld_type\r\n     * @param json FieldOptions\r\n     */\r\n    fromJson(json: FieldOptions) {\r\n        super.fromJson(json);\r\n        this.fldType = json.fld_type || \"string\";\r\n        if (this.value != null) {\r\n            this.setValue(this.value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the value, converting to number or string depending on fld_type\r\n     * @param val The new value\r\n     */\r\n    setValue(val: number | string) {\r\n        if (this.fldType === \"number\") this.value = Number(val);\r\n        else this.value = String(val);\r\n    }\r\n\r\n    /**\r\n     * @returns Display value for UI purposes (never null)\r\n     */\r\n    getDisplayValue(): string {\r\n        if (this.value == null) return this.fldType === \"number\" ? \"0\" : \"\";\r\n        return String(this.value);\r\n    }\r\n}\r\nexport type AnyField = Field | OptConnectField | NumberField | TextField | DummyField;\r\nexport type AnyFieldCls = typeof Field | typeof OptConnectField | typeof NumberField | typeof TextField | typeof DummyField;\r\nexport const FieldMap: {\r\n    field_both: typeof OptConnectField;\r\n    field_string: typeof TextField;\r\n    field_num: typeof NumberField;\r\n    field_dummy: typeof DummyField;\r\n    field_str: typeof TextField;\r\n    connection: typeof ConnectableField;\r\n    [key: string]: AnyFieldCls;\r\n} = {\r\n    'field_both': OptConnectField,\r\n    'field_string': TextField,\r\n    'field_num': NumberField,\r\n    'field_dummy': DummyField,\r\n    'field_str': TextField,\r\n    'connection': ConnectableField\r\n}\r\n\r\n\r\nexport default Field;\r\n","import newHeadlessNode from \"./headless-node\";\r\nimport { TblxNodeStruct } from \"./inject\";\r\nimport Toolbox from \"./toolbox\";\r\nimport { parseColor } from \"../util/parse-color\";\r\nclass Flyout {\r\n    container: HTMLDivElement;\r\n    visible: boolean;\r\n    toolbox?: Toolbox;\r\n\r\n    constructor(toolbox?: Toolbox) {\r\n        this.toolbox = toolbox as Toolbox;\r\n\r\n        this.container = document.createElement('div');\r\n        this.container.className = 'KabelFlyout';\r\n\r\n        this.visible = false;\r\n\r\n        if (toolbox) {\r\n            toolbox.workspace._wsTop.appendChild(this.container);\r\n        } else {\r\n            document.body.appendChild(this.container);\r\n        }\r\n    }\r\n\r\n    fill(nodes: TblxNodeStruct[]) {\r\n        this.container.innerHTML = '';\r\n        nodes.forEach(node => {\r\n            let _headlessNode = newHeadlessNode(node.type as string);\r\n            if (!_headlessNode) return;\r\n\r\n            const nodeEl = document.createElement('div');\r\n            nodeEl.className = 'KabelFlyoutNode';\r\n            nodeEl.textContent = _headlessNode.labelText;\r\n            nodeEl.style.backgroundColor = parseColor(_headlessNode.colors.primary);\r\n            nodeEl.style.padding = '4px 8px';\r\n            nodeEl.style.cursor = 'pointer';\r\n            nodeEl.style.fontFamily = this.toolbox!.workspace!.renderer!.constants.FONT_FAMILY;\r\n            nodeEl.style.fontSize = `${this.toolbox!.workspace!.renderer!.constants.FONT_SIZE}px`;\r\n            nodeEl.style.color = parseColor(this.toolbox!.workspace!.renderer!.constants!.FONT_COLOR);\r\n            nodeEl.addEventListener('mousedown', (e) => {\r\n                if (!this.toolbox) return;\r\n\r\n                // create ghost node element\r\n                const ghostEl = document.createElement('div');\r\n                ghostEl.className = 'KabelGhostNode';\r\n                ghostEl.textContent = _headlessNode.labelText;\r\n                ghostEl.style.position = 'absolute';\r\n                ghostEl.style.pointerEvents = 'none';\r\n                ghostEl.style.backgroundColor = parseColor(_headlessNode.colors.primary);\r\n                ghostEl.style.padding = '4px 8px';\r\n                ghostEl.style.fontFamily = this.toolbox!.workspace!.renderer!.constants.FONT_FAMILY;\r\n                ghostEl.style.fontSize = `${this.toolbox!.workspace!.renderer!.constants.FONT_SIZE}px`;\r\n                ghostEl.style.color = parseColor(this.toolbox!.workspace!.renderer!.constants!.FONT_COLOR);\r\n\r\n                document.body.appendChild(ghostEl);\r\n\r\n                const moveGhost = (ev: MouseEvent) => {\r\n                    ghostEl.style.left = ev.clientX + 4 + 'px';\r\n                    ghostEl.style.top = ev.clientY + 4 + 'px';\r\n                };\r\n\r\n                const releaseGhost = (ev: MouseEvent) => {\r\n                    document.removeEventListener('mousemove', moveGhost);\r\n                    document.removeEventListener('mouseup', releaseGhost);\r\n\r\n                    // check if over workspace svg\r\n                    const svg = this.toolbox!.workspace.svg.node as SVGSVGElement;\r\n                    const rect = svg.getBoundingClientRect();\r\n                    if (\r\n                        ev.clientX >= rect.left &&\r\n                        ev.clientX <= rect.right &&\r\n                        ev.clientY >= rect.top &&\r\n                        ev.clientY <= rect.bottom\r\n                    ) {\r\n                        // convert to svg coordinates\r\n                        const svgX = ev.clientX - rect.left;\r\n                        const svgY = ev.clientY - rect.top;\r\n\r\n                        // convert to workspace coordinates\r\n                        const { x: wsX, y: wsY } = this.toolbox!.workspace.screenToWorkspace(svgX, svgY);\r\n\r\n                        // spawn node\r\n                        this.toolbox!.workspace.spawnAt(node.type as string, wsX, wsY);\r\n                    }\r\n\r\n                    // remove ghost element\r\n                    ghostEl.remove();\r\n                };\r\n\r\n                document.addEventListener('mousemove', moveGhost);\r\n                document.addEventListener('mouseup', releaseGhost);\r\n\r\n                e.preventDefault();\r\n            });\r\n\r\n            this.container.appendChild(nodeEl);\r\n        });\r\n        this.show();\r\n    }\r\n\r\n\r\n    show() {\r\n        this.container.style.display = 'block';\r\n        this.visible = true;\r\n    }\r\n\r\n    hide() {\r\n        this.container.style.display = 'none';\r\n        this.visible = false;\r\n    }\r\n\r\n    clear() {\r\n        this.container.innerHTML = '';\r\n    }\r\n}\r\n\r\nexport default Flyout;\r\n","import { NodePrototype } from \"./node-types\";\r\nimport NodeSvg from \"./nodesvg\";\r\nimport NodePrototypes from \"./prototypes\";\r\n\r\n\r\nfunction newHeadlessNode(type: string) {\r\n    const proto : NodePrototype = NodePrototypes[type as string] as NodePrototype;\r\n    if (!proto) return;\r\n    const node = new NodeSvg(proto);\r\n    node.init();\r\n    return node;\r\n}\r\n\r\nexport default newHeadlessNode;","import RendererConstants from \"../renderers/constants\";\r\nimport Renderer, {DrawState, ConnectorToFrom} from \"../renderers/renderer\";\r\nimport CategoryColors from \"./colors\";\r\nimport Connection, {Connectable} from \"./connection\";\r\nimport Coordinates from \"./coordinates\";\r\nimport Field, { FieldOptions, FieldVisualInfo, AnyFieldCls, AnyField, DummyField, FieldMap, NumberField, OptConnectField, TextField } from \"./field\";\r\nimport inject, { InjectMsg, InjectOptions, TblxCategoryStruct, TblxObjStruct, TblxFieldStruct, TblxNodeStruct } from \"./inject\";\r\nimport { clearMainWorkspace, getMainWorkspace, setMainWorkspace } from \"./main-workspace\";\r\nimport NodeSvg, {NodeJson, NodeEvents, InputFieldJson} from \"./nodesvg\";\r\nimport NodePrototypes from \"./prototypes\";\r\nimport WorkspaceSvg from \"./workspace-svg\";\r\nimport { NodePrototype } from \"./node-types\";\r\nimport { Color, ColorStyle, Hex, RGBObject, RGBString, RGBTuple } from \"./visual-types\";\r\nimport { parseColor } from \"../util/parse-color\";\r\nimport eventer, {Eventer} from \"../util/eventer\";\r\nimport * as Path from '../util/path';\r\nimport * as SVG from '@svgdotjs/svg.js';\r\nimport * as UID from '../util/uid';\r\nimport hasProp from \"../util/has-prop\";\r\nimport EventEmitter from \"../util/emitter\";\r\n\r\nimport Kabel from \"./core\";\r\nimport { WidgetOptions } from \"./widget\";\r\nimport { WidgetPrototypeList } from \"./widget-prototypes\";\r\n\r\n\r\nexport default Kabel;\r\n\r\nexport type {\r\n    TblxCategoryStruct,\r\n    TblxNodeStruct,\r\n    TblxFieldStruct,\r\n    TblxObjStruct,\r\n    RendererConstants,\r\n    Renderer,\r\n    CategoryColors,\r\n    Connection,\r\n    Coordinates,\r\n    Field,\r\n    DummyField,\r\n    FieldMap,\r\n    NumberField,\r\n    OptConnectField,\r\n    TextField,\r\n    inject,\r\n    InjectMsg,\r\n    clearMainWorkspace,\r\n    getMainWorkspace,\r\n    setMainWorkspace,\r\n    NodeSvg,\r\n    NodePrototypes,\r\n    WorkspaceSvg,\r\n    AnyFieldCls,\r\n    AnyField,\r\n    InjectOptions,\r\n    Color, ColorStyle, Hex, RGBObject, RGBString, RGBTuple,\r\n    NodePrototype,\r\n    FieldOptions,\r\n    FieldVisualInfo,\r\n    NodeJson, NodeEvents, InputFieldJson,\r\n    Eventer,\r\n    Connectable,\r\n    DrawState,\r\n    ConnectorToFrom,\r\n    WidgetOptions,\r\n    WidgetPrototypeList\r\n}","import WorkspaceController from \"../controllers/base\";\r\nimport Renderer from \"../renderers/renderer\";\r\nimport { clearMainWorkspace, getMainWorkspace, setMainWorkspace } from \"./main-workspace\";\r\nimport WorkspaceSvg from \"./workspace-svg\";\r\nimport NodePrototypes from \"./prototypes\"; // Object\r\nimport { FieldOptions } from \"./field\";\r\nimport { Color } from \"./visual-types\";\r\nimport styler from '../util/styler';\r\n// @ts-ignore\r\nimport _kabelStyles from './styles.css'\r\nconst kabelStyles : string = _kabelStyles;\r\n\r\nexport interface TblxFieldStruct {\r\n\tvalue: any;\r\n\t[key: string]: any;\r\n}\r\n\r\nexport interface TblxNodeStruct {\r\n\ttype: keyof typeof NodePrototypes | string;\r\n\targuments: {\r\n\t\t[key: string]: TblxFieldStruct;\r\n\t};\r\n}\r\n\r\nexport interface TblxCategoryStruct {\r\n\tname: string;\r\n\tcolor: Color;\r\n\tcontents: TblxNodeStruct[];\r\n}\r\n\r\n// Discriminated union for TlbxObjStruct\r\nexport type TblxObjStruct =\r\n\t| {\r\n\t\ttype: 'flyout';\r\n\t\tcontents: TblxNodeStruct[];\r\n\t}\r\n\t| {\r\n\t\ttype?: 'category';\r\n\t\tcontents: TblxCategoryStruct[];\r\n\t}\r\n\t| {\r\n\t\ttype?: undefined; // when type is not provided\r\n\t\tcontents: TblxCategoryStruct[];\r\n\t};\r\n\r\n\r\nexport interface InjectOptions {\r\n    rendererOverrides?: {[key: string] : any};\r\n    Controller?: typeof WorkspaceController;\r\n    controls?: {\r\n        wasd?: boolean;\r\n        wasdSmooth?: boolean;\r\n        wasdAccelerate?: number;\r\n        wasdFriction?: number;\r\n    }\r\n    toolbox?: TblxObjStruct;\r\n    moveSpeed?: number;\r\n    renderer?: string|typeof Renderer;\r\n}\r\nexport class InjectMsg {\r\n    msg: string;\r\n    constructor(msg: string) {\r\n        this.msg = msg;\r\n    }\r\n    err() {\r\n        console.error(`Failed to inject workspace: ${this.msg}`)\r\n    }\r\n    wrn() {\r\n        console.warn(`Inject warning: ${this.msg}`)\r\n    }\r\n    info() {\r\n        console.info(`Inject info: ${this.msg}`)\r\n    }\r\n}\r\nexport default function inject(element: HTMLElement | string, options: InjectOptions = {}) : undefined | WorkspaceSvg{\r\n    styler.appendStyles('KabelStyles', kabelStyles);\r\n    const root = typeof element == 'string' ? document.querySelector(`#${element}`) as HTMLElement : element as HTMLElement;\r\n    if ((!root) && typeof element == 'string') {\r\n        (new InjectMsg(`Document does not contain root element (Check element ID).`)).err();\r\n        return;\r\n    }\r\n    if (!document.contains(root)) {\r\n        (new InjectMsg(`Document does not contain root element.`)).err();\r\n        return;\r\n    }\r\n    const wsTop = document.createElement('div');\r\n    wsTop.className = `KabelWorkspaceWrapper`;\r\n    root.appendChild(wsTop);\r\n    const ws = new WorkspaceSvg(root, wsTop, options);\r\n    setMainWorkspace(ws); // Set the main workspace to the newest created.\r\n\r\n    return ws;\r\n}","import WorkspaceSvg from \"./workspace-svg\";\r\n\r\n\r\n\r\nlet mainws : WorkspaceSvg | null = null;\r\n\r\nfunction getMainWorkspace(): WorkspaceSvg|null {\r\n    return mainws;\r\n}\r\nfunction setMainWorkspace(ws: WorkspaceSvg | null) {\r\n    return mainws = ws;\r\n}\r\nfunction clearMainWorkspace() {\r\n    return mainws = null;\r\n}\r\n\r\nexport {\r\n    getMainWorkspace,\r\n    setMainWorkspace,\r\n    clearMainWorkspace\r\n}","import Connection from \"./connection\";\r\nimport { NodePrototype } from \"./node-types\";\r\nimport { ColorStyle, Color } from './visual-types';\r\nimport hasProp from '../util/has-prop';\r\nimport Field, { AnyField, AnyFieldCls, DummyField, FieldMap } from \"./field\";\r\nimport CategoryColors from \"./colors\";\r\nimport Coordinates from \"./coordinates\";\r\nimport { generateUID } from \"../util/uid\";\r\nimport EventEmitter from '../util/emitter';\r\nimport { G } from \"@svgdotjs/svg.js\";\r\nimport WorkspaceSvg from \"./workspace-svg\";\r\nimport RendererConstants from \"../renderers/constants\";\r\n/** Represents a JSON structure to initialize a field on a node */\r\nexport interface InputFieldJson {\r\n    label: string;\r\n    type: string;\r\n    name: string;\r\n    [key: string]: any; // Extra field initialization properties\r\n}\r\n\r\n/** Represents a JSON structure to initialize a NodeSvg */\r\nexport interface NodeJson {\r\n    primaryColor?: Color;\r\n    secondaryColor?: Color;\r\n    tertiaryColor?: Color;\r\n    previousConnection?: any; // Presence triggers creation of a previous connection\r\n    nextConnection?: any;     // Presence triggers creation of a next connection\r\n    labelText?: string;\r\n    arguments?: InputFieldJson[];\r\n    category?: string;        // Optional node category for color theming\r\n    type: string;\r\n}\r\n\r\nexport type NodeStyle = ColorStyle & {\r\n    [key in keyof RendererConstants]?: RendererConstants[key];\r\n} & {\r\n    [key: string]: any;\r\n};\r\n\r\n\r\nexport interface NodeEvents {\r\n    \"REMOVING\": null;\r\n    \"INITING\": null;\r\n    \"NODE_DRAG\": null;\r\n}\r\nclass NodeSvg extends EventEmitter<NodeEvents> {\r\n    previousConnection: Connection | null;\r\n    nextConnection: Connection | null;\r\n    type: string | null;\r\n    prototype: NodePrototype | null;\r\n    colors: NodeStyle;      // Node's color scheme\r\n    labelText: string;       // Displayed node label\r\n    _fieldColumn: Set<AnyField>; // Stores attached fields\r\n    relativeCoords: Coordinates;\r\n    id: string;\r\n    svgGroup: G | null = null;\r\n    workspace: WorkspaceSvg | null = null;\r\n    static REMOVING: keyof NodeEvents = \"REMOVING\";\r\n    static INITING: keyof NodeEvents = \"INITING\";\r\n    constructor(prototype: NodePrototype | null, workspace?: WorkspaceSvg, svgGroup?: G) {\r\n        super();\r\n        this.type = null;\r\n        this.prototype = prototype;\r\n        this.colors = {\r\n            primary: '#000000',   // Topbar & connection color\r\n            secondary: '#000000', // Field & dropdown backgrounds\r\n            tertiary: '#000000', // Outline color\r\n            category: ''          // Node category name (optional)\r\n        };\r\n        this.previousConnection = new Connection(null, this, true); //1st arg is from, 2nd is to, third is if this conn is prev\r\n        this.nextConnection = new Connection(this, null, false); //1st arg is from, 2nd is to, third is if this conn is prev\r\n        this.labelText = '';\r\n        this._fieldColumn = new Set();\r\n        this.relativeCoords = new Coordinates(0, 0);\r\n        this.id = generateUID('nanoid', { alphabet: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0129384756!)@(#*$&%^' });\r\n        if (workspace) {\r\n            this.workspace = workspace;\r\n            this.workspace.addNode(this,)\r\n        }\r\n        if (svgGroup) {\r\n            this.svgGroup = svgGroup;\r\n        }\r\n    }\r\n    allFields() {\r\n        return Array.from(this._fieldColumn);\r\n    }\r\n    /** Get field by name */\r\n    getFieldByName(name: string): AnyField | null | undefined {\r\n        let field: AnyField | null | undefined = this.allFields().find(fld => fld.getName() === name);\r\n\r\n        return field;\r\n    }\r\n    getField(name: string): AnyField | null | undefined {\r\n        return this.getFieldByName(name);\r\n    }\r\n    getFieldValue(name: string): any | undefined {\r\n        const fld: AnyField | null | undefined = this.getFieldByName(name);\r\n        if (fld) {\r\n            return fld.getValue();\r\n        }\r\n        return undefined;\r\n    }\r\n    getFieldDisplayValue(name: string): any | undefined {\r\n        const fld: AnyField | null | undefined = this.getFieldByName(name);\r\n        if (fld) {\r\n            return fld.getDisplayValue();\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Initiates the node, calling prototype methods.\r\n     */\r\n    init() {\r\n        this.emit(NodeSvg.INITING, null);\r\n        if (this.prototype) {\r\n            if (this.prototype.init) this.prototype.init.call(this, this.prototype, this);\r\n            if (this.prototype.removed) {\r\n                this.on(NodeSvg.REMOVING, () => {\r\n                    this.prototype?.removed.call(this, this.prototype, this);\r\n                })\r\n            }\r\n        } else {\r\n            console.warn(`Node with id ${this.id} is missing a prototype.`)\r\n        }\r\n    }\r\n    /** Returns whether this node has a category style applied */\r\n    hasCategoryStyle() {\r\n        return !!this.colors?.category && this.colors?.category?.length > 0;\r\n    }\r\n\r\n    /** Returns the category name or null if none */\r\n    getCategoryName() {\r\n        return this.colors?.category || null;\r\n    }\r\n\r\n    /** Returns the node's current ColorStyle */\r\n    getStyle() {\r\n        return this.colors;\r\n    }\r\n\r\n    /** Internal helper: attach a field to this node */\r\n    _appendFieldItem(field: AnyField) {\r\n        if (!field) console.warn(\"Falsey field passed to _appendFieldItem.\");\r\n        this._fieldColumn.add(field);\r\n    }\r\n\r\n    /** Initialize node from a NodeJson object */\r\n    jsonInit(json: NodeJson) {\r\n        if (json.primaryColor) this.colors.primary = json.primaryColor;\r\n        if (json.secondaryColor) this.colors.secondary = json.secondaryColor;\r\n        if (json.tertiaryColor) this.colors.tertiary = json.tertiaryColor;\r\n\r\n        // Apply category colors if defined\r\n        if (json.category && CategoryColors[json.category]) {\r\n            const style: ColorStyle = CategoryColors[json.category] as ColorStyle;\r\n            Object.assign(this.colors, { category: json.category }, style);\r\n        }\r\n\r\n        this.previousConnection = hasProp(json, 'previousConnection') ? new Connection(null, this) : null;\r\n        this.nextConnection = hasProp(json, 'nextConnection') ? new Connection(this, null) : null;\r\n\r\n        if (json.labelText) this.labelText = json.labelText;\r\n        if (json.arguments) this.applyJsonArguments(json.arguments);\r\n        if (json.type) {\r\n            this.type = json.type;\r\n        }\r\n    }\r\n\r\n    /* JAVASCRIPT API */\r\n\r\n    /** Apply field definitions from a JSON-like array without full NodeJson */\r\n    applyJsonArguments(args: InputFieldJson[]) {\r\n        for (let field of args) {\r\n            if (!field.type || !field.name) {\r\n                console.warn(`Invalid argument definition at: ${args.indexOf(field)}.`);\r\n                continue;\r\n            }\r\n\r\n            const FieldConstructor: AnyFieldCls | undefined = FieldMap[field.type] as AnyFieldCls | undefined;\r\n            if (!FieldConstructor) {\r\n                console.warn(`Missing field constructor for ${field.type}!`);\r\n                continue;\r\n            }\r\n\r\n            const fld: AnyField = new FieldConstructor();\r\n            fld.fromJson(field); // initialize field\r\n            console.log(fld);\r\n            this._appendFieldItem(fld);\r\n        }\r\n    }\r\n\r\n    appendConnection(name: string): Field {\r\n        const fld = new (FieldMap['connection'])();\r\n        this._appendFieldItem(fld);\r\n        fld.setName(name);\r\n        return fld;\r\n    }\r\n\r\n    appendNumber(name: string): Field {\r\n        const fld = new (FieldMap['field_num'])();\r\n        this._appendFieldItem(fld);\r\n        fld.setName(name);\r\n        return fld;\r\n    }\r\n\r\n    appendText(name: string): Field {\r\n        const fld = new (FieldMap['field_str'])();\r\n        this._appendFieldItem(fld);\r\n        fld.setName(name);\r\n        return fld;\r\n    }\r\n\r\n    /** Field that can hold a connection or raw value */\r\n    appendOptLink(name: string): Field {\r\n        const fld = new (FieldMap['field_both'])();\r\n        this._appendFieldItem(fld);\r\n        fld.setName(name);\r\n        return fld;\r\n    }\r\n\r\n    setCategoryName(name: string) {\r\n        this.colors.category = name;\r\n    }\r\n\r\n    setStyle(style: ColorStyle): void {\r\n        Object.assign(this.colors, {}, style);\r\n    }\r\n\r\n    setColor(primary: Color, secondary: Color, tertiary: Color): void {\r\n        this.setStyle({ primary, secondary, tertiary });\r\n    }\r\n\r\n    setLabelText(text: string): string {\r\n        return this.labelText = text;\r\n    }\r\n\r\n    /** Add or replace a previous/next connection based on argument */\r\n    setConnection(prevOrNext: string | number | boolean): Connection | null {\r\n        const stringed = String(prevOrNext).toLowerCase();\r\n        const cast = stringed == '0' ? 0 : (stringed == '1' ? 1 : (stringed == 'true' ? 1 : (stringed == 'false' ? 0 : 3)));\r\n\r\n        if (cast === 0) return this.previousConnection = new Connection(null, this);\r\n        if (cast === 1) return this.nextConnection = new Connection(this, null);\r\n\r\n        console.warn('Invalid prevOrNext argument for NodeSvg.setConnection');\r\n        return null;\r\n    }\r\n    /** Copies another NodeSvg into this node */\r\n    fromNode(other: NodeSvg) {\r\n        if (!other) return;\r\n\r\n        // Copy primitive props\r\n        this.type = other.type;\r\n        this.labelText = other.labelText;\r\n        this.relativeCoords = new Coordinates(other.relativeCoords.x, other.relativeCoords.y);\r\n\r\n        // Copy colors\r\n        this.colors = { ...other.colors };\r\n\r\n        // Copy connections\r\n        this.previousConnection = other.previousConnection\r\n            ? new Connection(null, this, true)\r\n            : null;\r\n        this.nextConnection = other.nextConnection\r\n            ? new Connection(this, null, false)\r\n            : null;\r\n\r\n        // Copy fields\r\n        this._fieldColumn.clear();\r\n        for (let field of other._fieldColumn) {\r\n            const FieldCls = field.constructor as AnyFieldCls;\r\n            const newField = new FieldCls();\r\n\r\n            // Copy basic properties\r\n            newField.setName(field.getName());\r\n            if ('getValue' in field && 'setValue' in newField) {\r\n                newField.setValue(field.getValue());\r\n            }\r\n            if ('getLabel' in field && 'setLabel' in newField) {\r\n                newField.setLabel(field.getLabel())\r\n            }\r\n            this._appendFieldItem(newField);\r\n        }\r\n\r\n        // Copy workspace reference\r\n        this.workspace = other.workspace;\r\n\r\n        // Copy prototype reference\r\n        this.prototype = other.prototype;\r\n\r\n\r\n        return this;\r\n    }\r\n\r\n}\r\n\r\nexport default NodeSvg;\r\n","import { NodePrototype } from \"./node-types\";\r\n\r\n\r\nconst NodePrototypes : {\r\n    [key: string]: NodePrototype\r\n}= {};\r\nexport default NodePrototypes;","import Renderer from \"../renderers/renderer\";\r\n\r\ninterface RendererMap {\r\n\t[key: string]: typeof Renderer;\r\n}\r\n\r\nconst RendererMap: RendererMap = {\r\n\t[Renderer.NAME]: Renderer,\r\n\t'default': Renderer\r\n};\r\n\r\nclass RMap {\r\n\tstatic register(RendererCls: typeof Renderer, optName?: string) {\r\n\t\tconst name = optName ?? RendererCls.NAME;\r\n\t\tRendererMap[name] = RendererCls;\r\n\t}\r\n\r\n\tstatic delete(name: string) {\r\n\t\tif (name === 'default') return false;\r\n\t\tif (RendererMap[name]) {\r\n\t\t\tdelete RendererMap[name];\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tstatic get(name: string) {\r\n\t\treturn RendererMap[name] ?? RendererMap['default'];\r\n\t}\r\n\r\n\tstatic list() {\r\n\t\treturn Object.keys(RendererMap);\r\n\t}\r\n\r\n\t/**\r\n\t * Helper to normalize any renderer input into a valid Renderer class\r\n\t * @param input - Either a string (renderer name), a class, or undefined\r\n\t * @returns A Renderer constructor\r\n\t */\r\n\tstatic resolve(input?: string | typeof Renderer): typeof Renderer {\r\n\t\tif (!input) return RendererMap['default'] as typeof Renderer;\r\n\t\tif (typeof input === 'string') {\r\n            if (!RMap.get(input) ) {\r\n                return RendererMap['default'] as typeof Renderer;\r\n            }\r\n            return RMap.get(input) as typeof Renderer;\r\n        }\r\n\t\treturn (typeof input == 'function') ? input as typeof Renderer : RendererMap['default'] as typeof Renderer;\r\n\t}\r\n}\r\n\r\nexport { RMap, RendererMap };\r\n","export default \"/* Workspace wrapper: horizontal layout */\\r\\n.KabelWorkspaceWrapper {\\r\\n    display: flex;\\r\\n    flex-direction: row;\\r\\n    width: 100%;\\r\\n    height: 100%;\\r\\n    background: #f0f0f0;\\r\\n    /* light gray background */\\r\\n    overflow: hidden;\\r\\n    position: relative;\\r\\n}\\r\\n\\r\\n/* Toolbox panel (left) */\\r\\n.KabelToolbox {\\r\\n    width: 12%;\\r\\n    min-width: 150px;\\r\\n    height: 100%;\\r\\n    background: rgba(240, 240, 240, 0.95);\\r\\n    border-right: 1px solid #ccc;\\r\\n    box-sizing: border-box;\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n    padding: 8px;\\r\\n    overflow-y: auto;\\r\\n}\\r\\n\\r\\n/* Context menu container */\\r\\n.KabelContextMenu {\\r\\n    position: absolute;\\r\\n    background: #1e1e2f;\\r\\n    color: #000000;\\r\\n    border-radius: 6px;\\r\\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);\\r\\n    padding: 4px 0;\\r\\n    font-family: 'Segoe UI', sans-serif;\\r\\n    font-size: 14px;\\r\\n    min-width: 160px;\\r\\n    z-index: 9999;\\r\\n    user-select: none;\\r\\n    overflow: visible;\\r\\n    height: auto;\\r\\n    transition: opacity 0.15s ease, transform 0.15s ease;\\r\\n    opacity: 0;\\r\\n    transform: scale(0.95);\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n}\\r\\n\\r\\n/* Show state */\\r\\n.KabelContextMenu.show {\\r\\n    opacity: 1;\\r\\n    transform: scale(1);\\r\\n}\\r\\n\\r\\n/* Individual option */\\r\\n.KabelContextOption {\\r\\n    padding: 8px 16px;\\r\\n    cursor: pointer;\\r\\n    transition: background 0.15s ease, color 0.15s ease;\\r\\n}\\r\\n\\r\\n.KabelContextOption:hover {\\r\\n    background: #b0adb0;\\r\\n    color: #fff;\\r\\n}\\r\\n\\r\\n/* Optional: active click effect */\\r\\n.KabelContextOption:active {\\r\\n    background: #fff;\\r\\n    color: #000;\\r\\n}\\r\\n\\r\\n/* Scrollbar if too many options */\\r\\n.KabelContextMenu::-webkit-scrollbar {\\r\\n    width: 6px;\\r\\n}\\r\\n\\r\\n.KabelContextMenu::-webkit-scrollbar-thumb {\\r\\n    background: rgba(255, 255, 255, 0.2);\\r\\n    border-radius: 3px;\\r\\n}\\r\\n\\r\\n/* Category buttons */\\r\\n.KabelToolbox button {\\r\\n    background: #fff;\\r\\n    border: 1px solid #ccc;\\r\\n    border-radius: 4px;\\r\\n    margin-bottom: 4px;\\r\\n    padding: 6px;\\r\\n    cursor: pointer;\\r\\n    text-align: left;\\r\\n    transition: background 0.2s, color 0.2s;\\r\\n}\\r\\n\\r\\n.KabelToolbox button:hover {\\r\\n    background: #e6e6e6;\\r\\n    color: #333;\\r\\n}\\r\\n\\r\\n/* Flyout panel (right) */\\r\\n.KabelFlyout {\\r\\n    width: 20%;\\r\\n    height: 100%;\\r\\n    background: rgba(255, 255, 255, 0.95);\\r\\n    border-left: 1px solid #ccc;\\r\\n    box-sizing: border-box;\\r\\n    overflow-y: auto;\\r\\n    position: relative;\\r\\n    /* for absolute positioning of nodes inside */\\r\\n    display: none;\\r\\n    /* hidden by default */\\r\\n    padding: 8px;\\r\\n}\\r\\n\\r\\n/* Flyout nodes */\\r\\n.KabelFlyoutNode {\\r\\n    padding: 6px 10px;\\r\\n    margin-bottom: 4px;\\r\\n    border-radius: 4px;\\r\\n    cursor: pointer;\\r\\n    user-select: none;\\r\\n    transition: background 0.2s;\\r\\n}\\r\\n\\r\\n.KabelFlyoutNode:hover {\\r\\n    background: #e0e0e0;\\r\\n}\\r\\n\\r\\n/* SVG workspace area */\\r\\n.KabelWorkspaceWrapper svg {\\r\\n    flex: 1;\\r\\n    width: 100%;\\r\\n    height: 100%;\\r\\n    background: #fff;\\r\\n    /* white canvas background */\\r\\n    display: block;\\r\\n}\";","import Flyout from \"./flyout\";\r\nimport { InjectOptions, TblxCategoryStruct, TblxNodeStruct } from \"./inject\";\r\nimport WorkspaceSvg from \"./workspace-svg\";\r\n\r\nclass Toolbox {\r\n\ttype: 1 | 2;\r\n\tworkspace: WorkspaceSvg;\r\n\twsOptions: InjectOptions;\r\n\t_flyout: Flyout;\r\n\t_contents: TblxNodeStruct[] | TblxCategoryStruct[];\r\n\tcontainer: HTMLDivElement;\r\n\r\n\tconstructor(workspace: WorkspaceSvg) {\r\n\t\tthis.workspace = workspace;\r\n\t\tthis.wsOptions = this.getOptions();\r\n\t\tthis.type = this.wsOptions.toolbox?.type == 'flyout' ? 2 : 1;\r\n\t\tthis._contents = this.wsOptions.toolbox?.contents ?? [];\r\n\r\n\t\t// pass toolbox reference to flyout\r\n\t\tthis._flyout = new Flyout(this);\r\n\r\n\t\tthis.container = document.createElement('div');\r\n\t\tthis.container.className = 'KabelToolbox';\r\n\t\tthis.container.style.position = 'absolute';\r\n\t\tthis.container.style.left = '0';\r\n\t\tthis.container.style.top = '0';\r\n\t\tthis.container.style.width = '20%';\r\n\t\tthis.container.style.height = '100%';\r\n\t\tthis.container.style.background = 'rgba(240,240,240,0.9)';\r\n\t\tthis.container.style.overflowY = 'auto';\r\n\t\tworkspace._wsTop.appendChild(this.container);\r\n\r\n\t\tif (this.type === 1) this.initCategoryToolbox();\r\n\t\tif (this.type === 2) this.initFlyoutToolbox();\r\n\t}\r\n\r\n\tgetOptions() {\r\n\t\treturn this.workspace.options;\r\n\t}\r\n\r\n\tinitCategoryToolbox() {\r\n\t\tconst categories = this._contents as TblxCategoryStruct[];\r\n\t\tcategories.forEach(category => {\r\n\t\t\tconst btn = document.createElement('button');\r\n\t\t\tbtn.textContent = category.name;\r\n\t\t\tbtn.style.display = 'block';\r\n\t\t\tbtn.style.width = '100%';\r\n\t\t\tbtn.style.padding = '6px';\r\n\t\t\tbtn.style.marginBottom = '2px';\r\n\t\t\tbtn.addEventListener('click', e => {\r\n\t\t\t\te.stopPropagation();\r\n\t\t\t\tthis._flyout.clear();\r\n\t\t\t\tthis._flyout.fill(category.contents);\r\n\t\t\t\tthis._flyout.show();\r\n\t\t\t});\r\n\t\t\tthis.container.appendChild(btn);\r\n\t\t});\r\n\t\t// clicking workspace hides flyout\r\n\t\tthis.workspace.svg.on('click', () => this._flyout.hide());\r\n\t}\r\n\r\n\tinitFlyoutToolbox() {\r\n        this.container.style.display = 'none';\r\n\t\tconst nodes = this._contents as TblxNodeStruct[];\r\n\t\tthis._flyout.fill(nodes);\r\n\t}\r\n}\r\n\r\nexport default Toolbox;\r\n","import { WidgetOptions } from \"./widget\";\r\n\r\n\r\nexport interface WidgetPrototypeList {\r\n    [key: string]: WidgetOptions\r\n}\r\n\r\nconst WidgetPrototypes: WidgetPrototypeList = {};\r\nexport default WidgetPrototypes;","import WorkspaceSvg from \"./workspace-svg\";\r\nimport Coordinates from \"./coordinates\";\r\nimport { generateUID } from \"../util/uid\";\r\n\r\nexport interface WidgetOptions {\r\n    cls?: typeof Widget;\r\n    coords?: Coordinates;      // where to position the widget\r\n    width?: number;            // optional width\r\n    height?: number;           // optional height\r\n    className?: string;        // optional CSS class\r\n    html?: string;             // inner HTML\r\n    name: string;\r\n    init?: (this: WidgetOptions, widget: Widget, html: HTMLElement) => void;\r\n}\r\nclass Widget {\r\n    workspace: WorkspaceSvg;\r\n    container: HTMLDivElement;\r\n    coords: Coordinates;\r\n    width: number;\r\n    height: number;\r\n    visible: boolean;\r\n    name: string;\r\n    id: string;\r\n    options: WidgetOptions;\r\n    static WIDGET_GLOBAL_ID = 0;\r\n    constructor(workspace: WorkspaceSvg, options: WidgetOptions = { name: `Untitled(${Widget.WIDGET_GLOBAL_ID++})` }) {\r\n        this.workspace = workspace;\r\n        this.coords = options.coords ?? new Coordinates(0, 0);\r\n        this.width = options.width ?? 200;\r\n        this.height = options.height ?? 100;\r\n        this.visible = false;\r\n        this.name = options.name;\r\n        this.id = generateUID('nanoid', { alphabet: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0129384756!)@(#*$&%^' });\r\n        this.options = options;\r\n        this.container = document.createElement(\"div\");\r\n        this.container.className = options.className ?? \"KabelWidget\";\r\n        this.container.style.position = \"absolute\";\r\n        this.container.style.left = `${this.coords.x}px`;\r\n        this.container.style.top = `${this.coords.y}px`;\r\n        this.container.style.width = `${this.width}px`;\r\n        this.container.style.height = `${this.height}px`;\r\n        this.container.style.background = \"rgba(255,255,255,0.9)\";\r\n        this.container.style.border = \"1px solid #aaa\";\r\n        this.container.style.borderRadius = \"4px\";\r\n        this.container.style.boxShadow = \"0 2px 6px rgba(0,0,0,0.2)\";\r\n        this.container.style.pointerEvents = \"auto\";\r\n        this.container.style.zIndex = \"1000\"; // overlays nodes\r\n\r\n        if (options.html) this.container.innerHTML = options.html;\r\n\r\n        this.workspace._wsTop.appendChild(this.container);\r\n        this.hide();\r\n        if (typeof options.init !== 'undefined' && options.init) {\r\n            options.init(this, this.container);\r\n        }\r\n    }\r\n\r\n    // Show the widget\r\n    show() {\r\n        this.container.style.display = \"block\";\r\n        this.visible = true;\r\n    }\r\n\r\n    // Hide the widget\r\n    hide() {\r\n        this.container.style.display = \"none\";\r\n        this.visible = false;\r\n    }\r\n\r\n    // Move the widget to new coords\r\n    setCoords(coords: Coordinates) {\r\n        this.coords = coords;\r\n        this.container.style.left = `${coords.x}px`;\r\n        this.container.style.top = `${coords.y}px`;\r\n    }\r\n\r\n    // Update the HTML content\r\n    setHTML(html: string) {\r\n        this.container.innerHTML = html;\r\n    }\r\n    // Bring widget back from the dead after a .destroy call\r\n    reanimate() {\r\n        this.container = document.createElement(\"div\");\r\n        this.container.className = this.options.className ?? \"KabelWidget\";\r\n        this.container.style.position = \"absolute\";\r\n        this.container.style.left = `${this.coords.x}px`;\r\n        this.container.style.top = `${this.coords.y}px`;\r\n        this.container.style.width = `${this.width}px`;\r\n        this.container.style.height = `${this.height}px`;\r\n        this.container.style.background = \"rgba(255,255,255,0.9)\";\r\n        this.container.style.border = \"1px solid #aaa\";\r\n        this.container.style.borderRadius = \"4px\";\r\n        this.container.style.boxShadow = \"0 2px 6px rgba(0,0,0,0.2)\";\r\n        this.container.style.pointerEvents = \"auto\";\r\n        this.container.style.zIndex = \"1000\"; // overlays nodes\r\n        \r\n        if (this.options.html) this.container.innerHTML = this.options.html;\r\n\r\n        this.workspace._wsTop.appendChild(this.container);\r\n        this.workspace._addWidgetToDB(this);\r\n    }\r\n    // Destroy widget & cleanup.\r\n    destroy() {\r\n        this.container.remove();\r\n        this.workspace._delWidgetFromDB(this);\r\n    }\r\n}\r\n\r\nexport default Widget;\r\n","import Coordinates from \"./coordinates\";\r\n\r\n\r\n\r\n\r\nclass WorkspaceCoords extends Coordinates {\r\n    constructor(x = 0, y = 0) {\r\n        super(x, y);\r\n    }\r\n}\r\nexport default WorkspaceCoords;","import Coordinates from \"./coordinates\";\r\nimport NodeSvg from \"./nodesvg\";\r\nimport { Svg, SVG } from '@svgdotjs/svg.js';\r\nimport Renderer from '../renderers/renderer';\r\nimport { InjectOptions } from \"./inject\";\r\nimport WorkspaceCoords from \"./workspace-coords\";\r\nimport WorkspaceController from '../controllers/base';\r\nimport WASDController from '../controllers/wasd';\r\nimport { RMap } from \"./renderer-map\";\r\nimport Toolbox from \"./toolbox\";\r\nimport NodePrototypes from \"./prototypes\";\r\nimport newHeadlessNode from \"./headless-node\";\r\nimport Widget from \"./widget\";\r\nimport WidgetPrototypes from \"./widget-prototypes\";\r\nimport ContextMenuHTML from \"./context-menu\";\r\n\r\n\r\nfunction resolveController(options: InjectOptions): typeof WorkspaceController {\r\n    if (options?.controls) {\r\n        if (options?.controls.wasd) {\r\n            return WASDController;\r\n        }\r\n    }\r\n    return WorkspaceController;\r\n}\r\n/** \r\n * Represents the visual workspace containing nodes and connections.\r\n * Handles rendering, panning, and coordinate transformations.\r\n */\r\nclass WorkspaceSvg {\r\n    /** Top-left offset of the workspace viewport */\r\n    _camera: WorkspaceCoords;\r\n\r\n    /** Node storage by unique ID */\r\n    _nodeDB: Map<string, NodeSvg>;\r\n\r\n    /** Root HTML container for the workspace */\r\n    _root: HTMLElement;\r\n\r\n    /** Top-level wrapper for the SVG */\r\n    _wsTop: HTMLElement;\r\n\r\n    /** SVG.js instance for rendering */\r\n    svg: Svg;\r\n\r\n    /** Renderer instance for drawing nodes and connections */\r\n    renderer: Renderer;\r\n\r\n    /** Options for workspace behavior and rendering overrides */\r\n    options: InjectOptions;\r\n\r\n    /** Flag to temporarily prevent redraws */\r\n    noRedraw: boolean;\r\n    /**\r\n     * A class instance that moves the camera based on user interactions.\r\n     */\r\n    controller: WorkspaceController;\r\n    /**\r\n     * Toolbox for the workspace.\r\n     */\r\n    toolbox?: Toolbox;\r\n    /**\r\n     * A list of widgets active in this workspace\r\n     */\r\n    _widgetDB: Map<string, Widget>\r\n\r\n    /**\r\n     * A manager for the context menu widget\r\n     */\r\n    _ctxMenu: ContextMenuHTML\r\n    /**\r\n     * Creates a new WorkspaceSvg instance.\r\n     * @param root - The root HTML element containing the workspace.\r\n     * @param wsTop - The top-level wrapper element for the SVG.\r\n     * @param options - Configuration and renderer override options.\r\n     */\r\n    constructor(root: HTMLElement, wsTop: HTMLElement, options: InjectOptions) {\r\n        wsTop.style.width = '100%';\r\n        wsTop.style.height = '100%';\r\n\r\n        this._root = root;\r\n        this._wsTop = wsTop;\r\n        this.svg = SVG().addTo(this._wsTop).size('100%', '100%');\r\n        this.options = options;\r\n        let RClass: typeof Renderer = RMap.resolve(options.renderer);\r\n        this.renderer = new RClass(this, this.options.rendererOverrides || {});\r\n        if (this.options.toolbox) {\r\n            this.toolbox = new Toolbox(this);\r\n        }\r\n        this._camera = new WorkspaceCoords(0, 0);\r\n        this._nodeDB = new Map();\r\n        this.noRedraw = false;\r\n        this.controller = new (options.Controller ?? resolveController(options))(this);\r\n        this._widgetDB = new Map();\r\n        this._ctxMenu = new ContextMenuHTML(this);\r\n    }\r\n    cloneNode(nodeSvg: NodeSvg) {\r\n        const n = new NodeSvg(nodeSvg.prototype, this);\r\n        n.init();\r\n        n.fromNode(nodeSvg);\r\n        this.redraw();\r\n    }\r\n    _addWidgetToDB(wdgt: Widget) {\r\n        this._widgetDB.set(wdgt.id, wdgt);\r\n    }\r\n    _delWidgetFromDB(wdgt: Widget) {\r\n        this._widgetDB.delete(wdgt.id);\r\n    }\r\n    newWidget(type: string): void | Widget {\r\n        const opts = WidgetPrototypes[type];\r\n        if (!opts) return;\r\n        if (opts.cls) {\r\n            const wdgt = new (opts.cls)(this, opts);\r\n            this._addWidgetToDB(wdgt);\r\n            return wdgt;\r\n        }\r\n        const wdgt = new Widget(this, opts);\r\n        this._addWidgetToDB(wdgt);\r\n        return wdgt;\r\n    }\r\n    getWidget(id: string): Widget|undefined {\r\n        if (this._widgetDB.has(id)) return this._widgetDB.get(id);\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Returns the current width and height of the workspace's svg content size in pixels.\r\n     * Useful for camera positioning.\r\n     */\r\n    getContentSize(): { width: number; height: number } {\r\n        const bbox = this.svg.bbox();\r\n        return { width: bbox.width, height: bbox.height };\r\n    }\r\n    /**\r\n     * Returns the current width and height of the workspace in pixels.\r\n     * Useful for camera centering, zoom calculations, and viewport sizing.\r\n     */\r\n    getSize(): { width: number; height: number } {\r\n        const rect = this._wsTop.getBoundingClientRect();\r\n        return { width: rect.width, height: rect.height };\r\n    }\r\n\r\n    /**\r\n     * Updates all connection lines & node screen positions without a full redraw.\r\n     * Used when nodes are dragged or the camera moves.\r\n     */\r\n    refresh() {\r\n        this.renderer.refreshNodeTransforms();\r\n    }\r\n\r\n    /** Draws all nodes in the workspace. */\r\n    drawAllNodes() {\r\n        for (let [nodeId, _] of this._nodeDB) {\r\n            this.drawNode(nodeId);\r\n        }\r\n    }\r\n\r\n    /** Redraws the entire workspace unless noRedraw is set. */\r\n    redraw() {\r\n        if (this.noRedraw) return;\r\n        this.renderer.clearScreen();\r\n        this.drawAllNodes();\r\n        this.refresh();\r\n    }\r\n\r\n    /**\r\n     * Converts workspace coordinates to screen (SVG) coordinates.\r\n     * @param x - X position in workspace coordinates.\r\n     * @param y - Y position in workspace coordinates.\r\n     * @returns Screen coordinates as a Coordinates instance.\r\n     */\r\n    workspaceToScreen(x: number, y: number): Coordinates {\r\n        const { x: rx, y: ry } = this.controller.workspaceToScreen(x, y);\r\n        return new Coordinates(rx, ry);\r\n    }\r\n\r\n    /**\r\n     * Converts screen (SVG) coordinates to workspace coordinates.\r\n     * @param x - X position in screen coordinates.\r\n     * @param y - Y position in screen coordinates.\r\n     * @returns Workspace coordinates as a Coordinates instance.\r\n     */\r\n    screenToWorkspace(x: number, y: number): Coordinates {\r\n        const { x: rx, y: ry } = this.controller.screenToWorkspace(x, y);\r\n        return new Coordinates(rx, ry);\r\n    }\r\n\r\n    /**\r\n     * Draws a node by its ID.\r\n     * @param id - The ID of the node to render.\r\n     * @returns The rendered node.\r\n     */\r\n    drawNode(id: string) {\r\n        return this.renderer.renderNode(id);\r\n    }\r\n\r\n    /**\r\n     * Adds a node to the workspace.\r\n     * @param node - The node instance to add.\r\n     * @param nodeId - Optional custom ID to use instead of node.id.\r\n     */\r\n    addNode(node: NodeSvg, nodeId?: string) {\r\n        let id = nodeId || node.id;\r\n        if (this._nodeDB.has(id)) {\r\n            console.warn(`Node with id ${id} already exists, overwriting.`);\r\n        }\r\n        if (node.workspace !== this) {\r\n            node.workspace = this;\r\n        }\r\n        this._nodeDB.set(id, node);\r\n        this.redraw();\r\n    }\r\n\r\n    /**\r\n     * Create a new node of *type*.\r\n     * @param type - The node's prototype name.\r\n     */\r\n    newNode(type: keyof typeof NodePrototypes): NodeSvg | undefined {\r\n        if (!NodePrototypes[type]) return;\r\n        const node = newHeadlessNode(type as string);\r\n        if (!node) return;\r\n        this.addNode(node);\r\n        return node;\r\n    }\r\n\r\n    spawnAt(type: keyof typeof NodePrototypes, x: number, y: number): NodeSvg | undefined {\r\n        const node = this.newNode(type);\r\n        if (!node) return;\r\n        node.relativeCoords.set(x, y);\r\n        this.redraw();\r\n        return node;\r\n    }\r\n    /**\r\n     * Removes a node by its ID.\r\n     * @param id - The ID of the node to remove.\r\n     */\r\n    removeNodeById(id: string) {\r\n        const node = this._nodeDB.get(id);\r\n        if (!node) return;\r\n        this._nodeDB.delete(id);\r\n        this.redraw();\r\n    }\r\n\r\n    /**\r\n     * Removes a node by its instance.\r\n     * @param node - The node instance to remove.\r\n     */\r\n    removeNode(node: NodeSvg) {\r\n        if (!node) return;\r\n        this.removeNodeById(node.id);\r\n    }\r\n\r\n    /**\r\n     * Retrieves a node by its ID.\r\n     * @param id - The ID of the node.\r\n     * @returns The NodeSvg instance or undefined if not found.\r\n     */\r\n    getNode(id: string): NodeSvg | undefined {\r\n        return this._nodeDB.get(id);\r\n    }\r\n\r\n    /**\r\n     * Pans the camera by the given delta values.\r\n     * @param dx - Change in X direction.\r\n     * @param dy - Change in Y direction.\r\n     */\r\n    pan(dx: number, dy: number) {\r\n        this._camera.x += dx;\r\n        this._camera.y += dy;\r\n    }\r\n}\r\n\r\nexport default WorkspaceSvg;\r\n","type EventHandler<T = any> = (payload: T) => void;\r\n\r\nclass EventEmitter<Events extends Record<string, any>> {\r\n\tprivate listeners: { [K in keyof Events]?: EventHandler<Events[K]>[] } = {};\r\n\r\n\ton<K extends keyof Events>(event: K, handler: EventHandler<Events[K]>) {\r\n\t\tif (!this.listeners[event]) this.listeners[event] = [];\r\n\t\tthis.listeners[event]!.push(handler);\r\n\t\treturn this;\r\n\t}\r\n\r\n\toff<K extends keyof Events>(event: K, handler: EventHandler<Events[K]>) {\r\n\t\tif (!this.listeners[event]) return this;\r\n\t\tthis.listeners[event] = this.listeners[event]!.filter(h => h !== handler);\r\n\t\treturn this;\r\n\t}\r\n\r\n\temit<K extends keyof Events>(event: K, payload: Events[K]) {\r\n\t\tif (!this.listeners[event]) return false;\r\n\t\tthis.listeners[event]!.forEach(handler => handler(payload));\r\n\t\treturn true;\r\n\t}\r\n\r\n\tonce<K extends keyof Events>(event: K, handler: EventHandler<Events[K]>) {\r\n\t\tconst wrapper = (payload: Events[K]) => {\r\n\t\t\thandler(payload);\r\n\t\t\tthis.off(event, wrapper);\r\n\t\t};\r\n\t\tthis.on(event, wrapper);\r\n\t\treturn this;\r\n\t}\r\n}\r\nexport default EventEmitter;","function escapeAttr(s: string) {\r\n    return s.replace(/&/g, \"&amp;\")\r\n            .replace(/'/g, \"&apos;\")\r\n            .replace(/\"/g, \"&quot;\")\r\n            .replace(/</g, \"&lt;\")\r\n            .replace(/>/g, \"&gt;\");\r\n}\r\n\r\nexport default escapeAttr;","import { Svg, Rect, Circle, G, Path, Element } from '@svgdotjs/svg.js';\r\n\r\nexport type EventType = string;\r\nexport type EventArgs = Record<string, any>;\r\nexport type EventSetupFn = (el: Element, args?: EventArgs) => (() => void) | void;\r\n\r\ninterface RegisteredEl {\r\n    tags: string[],\r\n    el: Element;\r\n    type: EventType;\r\n    args?: EventArgs | undefined;      // allow undefined explicitly\r\n    destroyFn?: (() => void) | undefined; // allow undefined explicitly\r\n}\r\n\r\n/**\r\n * Used by the Kabel renderer to tag svg.js elements as interactable with the kabel system.\r\n */\r\nclass Eventer {\r\n    private elements: RegisteredEl[] = [];\r\n    private eventRegistry: Map<EventType, EventSetupFn> = new Map();\r\n\r\n    // Register an event type with a setup function\r\n    registerEvent(type: EventType, setupFn: EventSetupFn) {\r\n        this.eventRegistry.set(type, setupFn);\r\n        return this; // allow chaining\r\n    }\r\n    tagElement(el: Element, tags?: string[] | string) {\r\n        if (!tags) return this;\r\n        const tagList = Array.isArray(tags) ? tags : [tags];\r\n\r\n        // Find the registered elements for this el\r\n        for (const reg of this.elements) {\r\n            if (reg.el === el) {\r\n                for (const t of tagList) {\r\n                    if (!reg.tags.includes(t)) reg.tags.push(t);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    destroyByTag(tag: string) {\r\n        let destroyed = false;\r\n        this.elements = this.elements.filter(reg => {\r\n            if (reg.tags.includes(tag)) {\r\n                if (reg.destroyFn) {\r\n                    reg.destroyFn();\r\n                    destroyed = true;\r\n                }\r\n                return false; // remove this element\r\n            }\r\n            return true; // keep element\r\n        });\r\n        return destroyed ? 1 : 0;\r\n    }\r\n\r\n    // addElement\r\n    addElement(el: Element, types: EventType | EventType[], args?: EventArgs) {\r\n        const typeList = Array.isArray(types) ? types : [types];\r\n        for (const type of typeList) {\r\n            const destroyFn = this.setupElement(el, type, args) as (() => void) | undefined;\r\n            this.elements.push({\r\n                tags: [],\r\n                el,\r\n                type,\r\n                args,\r\n                destroyFn\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // refresh\r\n    refresh() {\r\n        for (const reg of this.elements) {\r\n            if (reg.destroyFn) reg.destroyFn();\r\n            reg.destroyFn = this.setupElement(reg.el, reg.type, reg.args) as (() => void) | undefined;\r\n        }\r\n    }\r\n\r\n\r\n    // Destroy event(s) for an element\r\n    destroyElement(el: Element, type?: EventType) {\r\n        let destroyed = false;\r\n        for (const reg of this.elements) {\r\n            if (reg.el === el && (!type || reg.type === type)) {\r\n                if (reg.destroyFn) {\r\n                    reg.destroyFn();\r\n                    destroyed = true;\r\n                }\r\n                // Remove from elements array\r\n                this.elements = this.elements.filter(r => r !== reg);\r\n            }\r\n        }\r\n        return destroyed ? 1 : 0;\r\n    }\r\n\r\n    private setupElement(el: Element, type: EventType, args?: EventArgs): (() => void) | undefined {\r\n        const setupFn = this.eventRegistry.get(type);\r\n        if (!setupFn) return;\r\n        const destroyFn = setupFn(el, args);\r\n        return destroyFn instanceof Function ? destroyFn : undefined;\r\n    }\r\n}\r\n\r\nconst eventer = new Eventer();\r\nexport default eventer;\r\nexport { Eventer };\r\n","\r\nexport default function hasProp(obj: object, name: string) {\r\n    return Object.prototype.hasOwnProperty.call(obj, name)\r\n}","// color-utils.ts\r\nimport type { Color, Hex } from '../src/visual-types';\r\n\r\n/**\r\n * Parse any Color type into a hex string \"#RRGGBB\"\r\n */\r\nexport function parseColor(color: Color): Hex {\r\n\tif (typeof color === 'string') {\r\n\t\tif (color.startsWith('#')) {\r\n\t\t\t// Already a hex string, normalize to full #RRGGBB\r\n\t\t\tlet hex = color.slice(1);\r\n\t\t\tif (hex.length === 3) hex = hex.split('').map(c => c + c).join('');\r\n\t\t\treturn `#${hex}`;\r\n\t\t} else {\r\n\t\t\t// RGB string \"r, g, b\"\r\n\t\t\tconst parts = color.split(',').map(s => parseInt(s.trim(), 10));\r\n\t\t\tif (parts.length !== 3) throw new Error(`Invalid RGB string: ${color}`);\r\n\t\t\tconst [r, g, b] = parts;\r\n            if (!r || !g || !b) {\r\n                console.warn(\r\n                    \"Invalid RGB tuple\"\r\n                );\r\n                return \"#000\";\r\n            }\r\n\t\t\treturn `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b\r\n\t\t\t\t.toString(16)\r\n\t\t\t\t.padStart(2, '0')}`;\r\n\t\t}\r\n\t} else if (Array.isArray(color)) {\r\n\t\t// RGBTuple [r,g,b]\r\n\t\tconst [r, g, b] = color;\r\n\t\treturn `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b\r\n\t\t\t.toString(16)\r\n\t\t\t.padStart(2, '0')}`;\r\n\t} else {\r\n\t\t// RGBObject {r,g,b}\r\n\t\tconst { r, g, b } = color;\r\n\t\treturn `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b\r\n\t\t\t.toString(16)\r\n\t\t\t.padStart(2, '0')}`;\r\n\t}\r\n}\r\n","// path.ts\r\n/**\r\n * Utility functions to generate SVG path strings or translate them.\r\n */\r\n\r\n/** Rounded rectangle */\r\nexport function roundedRect(width: number, height: number, radius: number): string {\r\n\tradius = Math.min(radius, width / 2, height / 2);\r\n\treturn `\r\n\t\tM${radius},0\r\n\t\tH${width - radius}\r\n\t\tA${radius},${radius} 0 0 1 ${width},${radius}\r\n\t\tV${height - radius}\r\n\t\tA${radius},${radius} 0 0 1 ${width - radius},${height}\r\n\t\tH${radius}\r\n\t\tA${radius},${radius} 0 0 1 0,${height - radius}\r\n\t\tV${radius}\r\n\t\tA${radius},${radius} 0 0 1 ${radius},0\r\n\t\tZ\r\n\t`.replace(/\\s+/g, ' ').trim();\r\n}\r\n\r\n/** Rounded triangle pointing up */\r\nexport function roundedTri(width: number, height: number, radius: number): string {\r\n\tconst halfW = width / 2;\r\n\tradius = Math.min(radius, halfW, height / 2);\r\n\treturn `\r\n\t\tM${halfW},0\r\n\t\tL${width - radius},${height - radius}\r\n\t\tA${radius},${radius} 0 0 1 ${width - radius*2},${height}\r\n\t\tL${radius*2},${height}\r\n\t\tA${radius},${radius} 0 0 1 ${radius},${height - radius}\r\n\t\tZ\r\n\t`.replace(/\\s+/g, ' ').trim();\r\n}\r\n\r\n/** Circle */\r\nexport function circle(radius: number): string {\r\n\treturn `\r\n\t\tM${radius},0\r\n\t\tA${radius},${radius} 0 1,0 ${-radius},0\r\n\t\tA${radius},${radius} 0 1,0 ${radius},0\r\n\t\tZ\r\n\t`.replace(/\\s+/g, ' ').trim();\r\n}\r\n\r\n/** Ellipse */\r\nexport function ellipse(rx: number, ry: number): string {\r\n\treturn `\r\n\t\tM${rx},0\r\n\t\tA${rx},${ry} 0 1,0 ${-rx},0\r\n\t\tA${rx},${ry} 0 1,0 ${rx},0\r\n\t\tZ\r\n\t`.replace(/\\s+/g, ' ').trim();\r\n}\r\n\r\n/** Star with n points */\r\nexport function star(radius: number, points: number = 5): string {\r\n\tif (points < 2) throw new Error('Star must have at least 2 points');\r\n\tlet path = '';\r\n\tconst step = (Math.PI * 2) / (points * 2);\r\n\tfor (let i = 0; i < points * 2; i++) {\r\n\t\tconst r = i % 2 === 0 ? radius : radius / 2;\r\n\t\tconst x = r * Math.sin(i * step);\r\n\t\tconst y = -r * Math.cos(i * step);\r\n\t\tpath += i === 0 ? `M${x},${y}` : ` L${x},${y}`;\r\n\t}\r\n\tpath += ' Z';\r\n\treturn path;\r\n}\r\n\r\n/** Regular polygon (triangle, pentagon, hexagon, etc) */\r\nexport function polygon(radius: number, sides: number = 3): string {\r\n\tif (sides < 3) throw new Error('Polygon must have at least 3 sides');\r\n\tlet path = '';\r\n\tconst step = (Math.PI * 2) / sides;\r\n\tfor (let i = 0; i < sides; i++) {\r\n\t\tconst x = radius * Math.cos(i * step - Math.PI / 2);\r\n\t\tconst y = radius * Math.sin(i * step - Math.PI / 2);\r\n\t\tpath += i === 0 ? `M${x},${y}` : ` L${x},${y}`;\r\n\t}\r\n\tpath += ' Z';\r\n\treturn path;\r\n}\r\nimport SvgPath from 'svgpath';\r\n\r\n/**\r\n * Rotate an SVG path string around a given point\r\n * @param path - SVG path string\r\n * @param angle - rotation angle in degrees\r\n * @param cx - x-coordinate of rotation center (default 0)\r\n * @param cy - y-coordinate of rotation center (default 0)\r\n * @returns new rotated SVG path string\r\n */\r\nexport function rotatePath(path: string, angle: number, cx = 0, cy = 0): string {\r\n\treturn new SvgPath(path)\r\n\t\t.rotate(angle, cx, cy)\r\n\t\t.toString();\r\n}\r\n","class Styler {\r\n\tprivate styles: Map<string, HTMLStyleElement>;\r\n\r\n\tconstructor() {\r\n\t\tthis.styles = new Map();\r\n\t}\r\n\r\n\tappendStyles(id: string, css: string): void {\r\n\t\tif (this.styles.has(id)) return; // Do not append if id exists\r\n\r\n\t\tconst styleEl = document.createElement('style');\r\n\t\tstyleEl.id = id;\r\n\t\tstyleEl.textContent = css;\r\n\t\tdocument.head.appendChild(styleEl);\r\n\t\tthis.styles.set(id, styleEl);\r\n\t}\r\n\r\n\tremoveStyles(id: string): void {\r\n\t\tconst styleEl = this.styles.get(id);\r\n\t\tif (!styleEl) return;\r\n\r\n\t\tstyleEl.remove();\r\n\t\tthis.styles.delete(id);\r\n\t}\r\n\r\n\tupdateStyles(id: string, css: string): void {\r\n\t\tconst styleEl = this.styles.get(id);\r\n\t\tif (!styleEl) return;\r\n\r\n\t\tstyleEl.textContent = css;\r\n\t}\r\n\r\n\thasStyles(id: string): boolean {\r\n\t\treturn this.styles.has(id);\r\n\t}\r\n}\r\nexport {\r\n    Styler\r\n}\r\nconst styler = new Styler();\r\nexport default styler;","// uid.ts\r\n// Tiny UID toolkit  no deps. Tabs > spaces, obviously.\r\n\r\nexport type UIDStrategy = \"uuidv4\" | \"ulid\" | \"nanoid\" | \"short\";\r\n\r\nexport interface UIDOptions {\r\n    /** For \"nanoid\": length of the id (default 21) */\r\n    size?: number;\r\n    /** For \"nanoid\": custom alphabet (default URL-safe) */\r\n    alphabet?: string;\r\n}\r\n\r\n/** Web Crypto shim (browser + Node 16+) */\r\nconst cryptoAPI: Crypto | null =\r\n    (typeof globalThis !== \"undefined\" && (globalThis as any).crypto) || null;\r\n\r\n/** Random bytes helper */\r\nfunction randBytes(len: number): Uint8Array {\r\n    if (cryptoAPI?.getRandomValues) {\r\n        const buf = new Uint8Array(len);\r\n        cryptoAPI.getRandomValues(buf);\r\n        return buf;\r\n    }\r\n    // Last resort (very old envs). Not cryptographically strong.\r\n    const buf = new Uint8Array(len);\r\n    for (let i = 0; i < len; i++) buf[i] = Math.floor(Math.random() * 256);\r\n    return buf;\r\n}\r\n\r\n/** RFC4122 UUID v4 (uses crypto.randomUUID if available) */\r\nexport function uuidv4(): string {\r\n    const g: any = globalThis as any;\r\n    if (g?.crypto?.randomUUID) return g.crypto.randomUUID();\r\n\r\n    const b = randBytes(16);\r\n    // Per RFC: set version + variant bits\r\n    // @ts-ignore\r\n    b[6] = (b[6] & 0x0f) | 0x40;\r\n    // @ts-ignore\r\n    b[8] = (b[8] & 0x3f) | 0x80;\r\n\r\n    const hex: string[] = [];\r\n    for (let i = 0; i < 256; i++) hex.push(i.toString(16).padStart(2, \"0\"));\r\n\r\n    return (\r\n        // @ts-ignore\r\n        hex[b[0]] + hex[b[1]] + hex[b[2]] + hex[b[3]] + \"-\" +\r\n        // @ts-ignore\r\n        hex[b[4]] + hex[b[5]] + \"-\" +\r\n        // @ts-ignore\r\n        hex[b[6]] + hex[b[7]] + \"-\" +\r\n        // @ts-ignore\r\n        hex[b[8]] + hex[b[9]] + \"-\" +\r\n        // @ts-ignore\r\n        hex[b[10]] + hex[b[11]] + hex[b[12]] + hex[b[13]] + hex[b[14]] + hex[b[15]]\r\n    );\r\n}\r\n\r\n/** Crockford Base32 alphabet for ULID */\r\nconst CROCK32 = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // no I L O U\r\n\r\n/** ULID: time-sortable, 26 chars */\r\nexport function ulid(date?: number): string {\r\n    const time = (typeof date === \"number\" ? date : Date.now()) >>> 0; // low 32 bits\r\n    const timeHi = Math.floor((typeof date === \"number\" ? date : Date.now()) / 0x100000000) >>> 0; // high 32\r\n    // ULID uses 48-bit time; do base32 encode 48 bits\r\n    const time48 = new Uint8Array(6);\r\n    // write 48-bit big-endian\r\n    let t = BigInt(typeof date === \"number\" ? date : Date.now());\r\n    for (let i = 5; i >= 0; i--) {\r\n        time48[i] = Number(t & 0xffn);\r\n        t >>= 8n;\r\n    }\r\n    // first 10 chars = time\r\n    let out = \"\";\r\n    let acc = 0;\r\n    let bits = 0;\r\n    for (let i = 0; i < 6; i++) {\r\n        // @ts-ignore\r\n        acc = (acc << 8) | time48[i];\r\n        bits += 8;\r\n        while (bits >= 5) {\r\n            bits -= 5;\r\n            out += CROCK32[(acc >>> bits) & 31];\r\n        }\r\n    }\r\n    if (bits > 0) out += CROCK32[(acc << (5 - bits)) & 31];\r\n    out = out.slice(0, 10);\r\n\r\n    // last 16 chars = randomness (80 bits)\r\n    const rnd = randBytes(10);\r\n    acc = 0; bits = 0;\r\n    for (let i = 0; i < rnd.length; i++) {\r\n        // @ts-ignore\r\n        acc = (acc << 8) | rnd[i];\r\n        bits += 8;\r\n        while (bits >= 5) {\r\n            bits -= 5;\r\n            out += CROCK32[(acc >>> bits) & 31];\r\n        }\r\n    }\r\n    if (bits > 0) out += CROCK32[(acc << (5 - bits)) & 31];\r\n\r\n    return out.slice(0, 26);\r\n}\r\n\r\n/** NanoID-style: URL-safe alphabet by default, configurable length/alphabet */\r\nconst DEFAULT_ALPHABET =\r\n    \"_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n\r\nexport function nanoid(size: number = 21, alphabet: string = DEFAULT_ALPHABET): string {\r\n    if (size <= 0) throw new Error(\"size must be > 0\");\r\n    const mask = (1 << Math.ceil(Math.log2(alphabet.length))) - 1;\r\n    let id = \"\";\r\n    while (id.length < size) {\r\n        const bytes = randBytes(1);\r\n        // @ts-ignore\r\n        const idx = bytes[0] & mask;\r\n        if (idx < alphabet.length) id += alphabet[idx];\r\n    }\r\n    return id;\r\n}\r\n\r\n/** Short, mostly-unique (not crypto-strong): timestamp base36 + counter + random */\r\nlet _ctr = 0;\r\nexport function shortId(): string {\r\n    const ts = Date.now().toString(36);\r\n    _ctr = (_ctr + 1) & 0xfff; // 0..4095\r\n    const c = _ctr.toString(36).padStart(3, \"0\");\r\n    const r = Array.from(randBytes(3))\r\n        .map(b => (b & 0x3f).toString(36).padStart(2, \"0\"))\r\n        .join(\"\")\r\n        .slice(0, 4);\r\n    return `${ts}${c}${r}`;\r\n}\r\n\r\n/** One-call wrapper */\r\nexport function generateUID(strategy: UIDStrategy = \"uuidv4\", opts: UIDOptions = {}): string {\r\n    switch (strategy) {\r\n        case \"uuidv4\": return uuidv4();\r\n        case \"ulid\": return ulid();\r\n        case \"nanoid\": return nanoid(opts.size ?? 21, opts.alphabet ?? DEFAULT_ALPHABET);\r\n        case \"short\": return shortId();\r\n        default: {\r\n            const _exhaustive: never = strategy;\r\n            return uuidv4();\r\n        }\r\n    }\r\n}\r\n","function unescapeAttr(s: string) {\r\n\treturn s.replace(/&lt;/g, \"<\")\r\n\t\t\t.replace(/&gt;/g, \">\")\r\n\t\t\t.replace(/&quot;/g, '\"')\r\n\t\t\t.replace(/&apos;/g, \"'\")\r\n\t\t\t.replace(/&amp;/g, \"&\");\r\n}\r\n\r\nexport default unescapeAttr;\r\n","type StateChangeCallback = (addedOrRemoved: 0 | 1) => void;\r\n\r\nclass UserState {\r\n\tprivate state: Set<string>;\r\n\tprivate callbacks: Map<string, StateChangeCallback[]>;\r\n\r\n\tconstructor() {\r\n\t\tthis.state = new Set();\r\n\t\tthis.callbacks = new Map();\r\n\t}\r\n\r\n\t/** Adds a state */\r\n\tsetState(name: string) {\r\n\t\tconst wasPresent = this.state.has(name);\r\n\t\tif (!wasPresent) {\r\n\t\t\tthis.state.add(name);\r\n\t\t\tthis.triggerCallbacks(name, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t/** Removes a state */\r\n\tremoveState(name: string) {\r\n\t\tconst wasPresent = this.state.has(name);\r\n\t\tif (wasPresent) {\r\n\t\t\tthis.state.delete(name);\r\n\t\t\tthis.triggerCallbacks(name, 0);\r\n\t\t}\r\n\t}\r\n\r\n\t/** Checks if state is active */\r\n\thasState(name: string) {\r\n\t\treturn this.state.has(name);\r\n\t}\r\n\r\n\t/** Registers a callback for state changes */\r\n\tonStateChange(name: string, cb: StateChangeCallback) {\r\n\t\tif (!this.callbacks.has(name)) this.callbacks.set(name, []);\r\n\t\tthis.callbacks.get(name)!.push(cb);\r\n\t}\r\n\r\n\t/** Internal: triggers callbacks for a state */\r\n\tprivate triggerCallbacks(name: string, addedOrRemoved: 0 | 1) {\r\n\t\tconst cbs = this.callbacks.get(name);\r\n\t\tif (!cbs) return;\r\n\t\tfor (const cb of cbs) cb(addedOrRemoved);\r\n\t}\r\n}\r\nconst userState = new UserState();\r\nexport default userState;\r\nexport { \r\n    UserState\r\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n",""],"names":[],"sourceRoot":""}